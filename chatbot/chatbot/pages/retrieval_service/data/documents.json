{
  "documents": [
    "CS 15 - Spring 2025\n\nCourse Mechanics\nLectures\nSee the courese home page for lecture times and places.\nLabs\nLabs are required and meet once a week. They provide hands-on practice with course concepts and skills and reinforce your learning.\n\nYou must sign up for and attend a lab. That means registering, attending, and submitting the lab. Your lab grade will be based on your attendance and your lab submissions. It is okay if you don't complete the entire lab assignment: you will receive full credit if you submit your best, good-faith effort.\n\nBefore some labs, we may release a pre-lab that you must do before the lab. These will orient you to the specific lab so you'll be better prepared to take full advantage of your time in lab.\n\nLab attendance is mandatory. However, we understand that things come up and people get sick. So, for grading purposes, we credit you with full attendance if you miss up to two lab sessions. Labs cover essential material that you will need for the course. Therefore, if you do miss a lab, you should still go through and submit the lab on your own, talk to a fellow student, and ask the staff any questions you have.\n\nLabs can be completed either using the lab computers, or using your personal laptop. If you feel more comfortable working on your laptop, bring it to the lab room and work on it from there.\n\nStudents often ask if they can attend a lab that the registration system says is full. Being registered for a lab guarantees you a space in that lab and, therefore, we cannot allow you to take a seat in a lab at the expense of a registered student. Labs only have a fixed number of seats, computers, and lab assistants, and it isn't fair to let some students diminish the lab experience for others.\n\nThat said, you may try to attend “stand by”: You may drop in on another lab, alert the lab leader that you are there stand-by. If there are too many students, the lab leader will take attendance and all non-registered students will be asked to leave.\n\nSubmit whatever work you were able to complete at the end of lab the lab period. If you need or want to polish things up, you may (re)submit up until 18:00 (6 pm) on Friday of that week. We will not accept lab submissions after that.\n\nCoursework\nGetting Started\nThere are a few steps to get set-up with the department servers if you have not taken a computer science class at Tufts. This involves an EECS account as well as learning how to access the department servers from your computer. You also need a text editor. It is important to get this done before the Lab 1 so that lab time is not spent trying to set-up accounts or coding environments.\n\nCS Accounts\nThis course requires the use of the department's remote login servers.\n\nStudents do not have to do anything to get an account to login to these servers: before the start of classes, the EECS IT staff gets a list of all students registered for a CS course, and they automatically create an account for any new students and send an email instructing you how to set your password. You must set your password.\n\nTo set your password, go to https://www.eecs.tufts.edu/~accounts/ and click on “Enable or reset your existing ECE/CS UNIX account.”\n\nIf you didn't get such an email, be sure to check your Tufts email and any relevant spam folders.\n\nIf you are waitlisted or not registered as of a day or two before the start of classes, then you must contact EECS IT directly to request an account. Go to the EECS IT Help Desk in Halligan, or send them an email at staff@eecs.tufts.edu for help.\n\nSoftware/Platforms\nProgramming assignments will be in the C++ programming language and will be evaluated on the department's Linux servers. If your program works in some other environment but does not work on the department servers, it will be considered broken. Therefore, you must test your code on the department server.\n\nConsult our System Setup Guide for other set-up information including instructions to access a terminal, ssh to the homework servers, and to set up the VS Code text editor.\n\nAssignments\nThere will be shorter homework assignments (usually 7 days), and longer projects (usually two weeks). Both include programming implementations in C++. Assignments are due by the published deadline on the course calendar.\n\nPlease be aware that we use automated systems to process and test your work. Thus, it is your responsibility to:\n\nFollow all instructions in the assignment specification carefully.\nSubmit your work on time.\nYou might get lucky if you submit very close to the deadline, but you should assume that any submission after the deadline will cost you one or more extension tokens (see below), or will prevent your work from being acceepted at all.\n\nBe sure to submit well before the deadline to ensure you have time to fix any unforeseen problems and re-test before submitting again.\n\nExtensions\nHomework is expected to be submitted on time. However, we recognize that the exigencies of life occasionally interfere with on-time submission. If you have difficulty getting homework in on time, there are two types of extensions:\n\nDean-requested extensions\nAutomatic (token-based) extensions\nNo extensions are granted merely on the basis of a student request (e. g., an email).\n\nDean-supported extensions are for cases of serious or extended illness (e. g., being in the hospital), family emergencies, or other unforeseeable, severe, longer-term difficulties (more than a few days). In these special circumstances, extensions are granted after we receive a request from your advising dean. The deans can protect your privacy, get you appropriate help, and coordinate with all your instructors. You can find your advising dean's name and contact information here. Do not email the deans to avoid using extension tokens (see below) or for routine illness, like a 2-day cold. The deans are there for longer term issues and those that affect all your courses.\n\nAutomatic (token-based) extensions are designed to cover less severe, shorter-term issues, such as short-term illness, catching a cold, stomach bug, headache, migrane, etc. They can also be used for other interruptions, like the need to secure a loaner laptop. Something that sets you back a few days. To support automatic extensions, we use a token system. Here's how it works:\n\nAt the start of the semester, each student receives a bank of 6 (virtual) extension tokens.\nIf you submit your work late, token(s) will be automatically deducted from your account in the following manner:\nIf your work is less than 24 hours late, one token will be used.\nIf your work is greater than or equal to 24 hours late, and less than 48 hours late, two tokens will be used.\nWork submitted later than or equal to 48 hours after the initial deadline will not be accepted and receives a 0.\nIf you have no tokens left, we will not accept late work from you (unless you have a dean-sanctioned extension). Being out of tokens is not, itself, a basis for a dean-sanctioned extension.\nProjects may have multiple submissions, e. g., there may be project part 1 and part 2 submissions. In such cases, each part counts as a separate assignment for token purposes. That is, if you use a token for the first part, you do not automatically get an extension on subsequent parts. Extending those would require their own extension tokens.\nGrading, Testing, and Submission Limits\nWe use an autograder for student submissions. The autograder runs student code against our own tests and generates a score. This autograder score will comprise a significant fraction of your final submission grade.\n\nAfter you submit your code on Gradescope, you will be able to see your autograder score (wait a few minutes after submitting, as it takes time to upload your submission and run the autograder). You will also see a description of a subset (usually 10) of the autograder tests we ran. We will not provide a description of the remaining tests; we leave it up to you to come up with other test cases yourself.\n\nWe provide you with your autograder score to prevent small, simple bugs in your program from having a big impact on your grade. For example, a single misplaced character in a program's output may cause the program to fail many autograder tests. Seeing your autograder score can help you catch such cases. However, seeing your autograder score is not a replacement for testing your own program.\n\nTo encourage your own testing, we will limit you to five submissions for an assignment. Any submissions after your fifth one will not count. Therefore, test your code thoroughly yourself, and submit only when you are convinced you have a submission you would like assessed (use your five submissions wisely!). Even if you change what you believe is a non-functional part of the code (e. g., comments), you should run your tests again. It is a shame to lose a submission because of a silly mistake. Submit your homework when you are confident that it is correct.\n\nExtension tokens (mentioned above) are for lateness. They are not a generic currency, and they cannot be used for extra submissions. The submission limit is there to encourage testing, which is a separate issue from lateness.\n\nStyle Guide\nOrganization and style are things we care deeply about in this course. When you write code, you must write for a human audience; code that is not understandable is as useless as code that does not work. To emphasize this, a fair portion of your grade on each assignment will be based on adherence to the course style guide which lays out our policies for organization, style, and documentation. You should read it at the start of the term and return to it before submitting each assignment to ensure that you are following all of the requirements.\n\nWe know that getting deductions because you forgot a space somewhere or you used the boolean symbol && instead of writing “and” can be frustrating. We promise that there are reasons for these policies in the style guide. You should not come to a staff member to ask if a certain instance of breaking the style guide is acceptable or if you will get points off for it. Anything in the style guide could be a rubric item, and the rubrics might change throughout the term to emphasize stylistic issues we have seen. Just because some style guideline has not come up in past grading does not mean it will not.\n\nDocumentation is one of the biggest things you can do to get credit even when your code does not fully work. Thus, it is in your best interest to thoroughly comment and write code that is as clear as possible.\n\nExams\nThere will be one midterm exam and a final exam during the final exam period. See the course calendar for dates. The final exam is cumulative, but with greater emphasis on the last part of the course.\n\nMissing an exam: Make-up exams will only be considered for students under rare, exceptional circumstances when attending the exam in-person is not possible. Under such circumstances, you must reach out to your advising dean to explain your situation. Assuming your excuse is valid, the advising dean will work with your instructor to accomodate your situation. Students in this situation will then have to take a make-up exam at a date and time chosen by the instructor. Failure to show up for the make-up will result in a 0 for the exam.\n\nAcademic integrity and exams: You will be instructed what materials, if any, you may bring to an exam. As a rule, our exams are closed book, closed notes, and you may not bring any electronic devices (computers, cell phones, music players, calculators, etc.). Tuft's policy on this is very clear. Do NOT bring unauthorized materials, information, or electronic equipment to an exam. Do NOT engage in behavior that gives the appearance of cheating, such as passing a note to a friend, whispering to another student while the exam is in progress, or looking at another student's exam. Do NOT bring your cell phone, tablet, music player, calculator, or any other electronic device to the exam. If you are seen handling an electronic device, even to silence a phone, the Judicial Affairs Administrator will treat it as an academic integrity violation. A typical penalty is 1 or 2 semesters suspension from Tufts. We are obliged to report all such incidents to Judicial Affairs. Please do not make us do that!\n\nIf we have online exams, the rules will likely be the same, but we will announce the rules at the time.\n\nCourse Policies\nGrading\nYour final grade will be based on a weighted sum of your homework, projects, labs, and exam scores. Specifically, 55% of the score comes from homework (including projects, see below), 5% from labs, 20% from the midterm exam, and 20% from the final exam. I. e., your final course grade (G) is determined by the following formula:\n\nG = 0.55 × HW + 0.05 × Lab + 0.20 × Emidterm + 0.20 × Efinal\nAll homework assignments are normalized to a 100-point scale. All homeworks are weighted equally, and each project counts twice as much as a weekly homework.\n\nEach project will comprise multiple installments submitted separately; that is, there may be an initial part of the project due one week, a more involved version a week later. We do not publicize the formula for combining the scores, but most of the score (80–90%) will come from the final submission.\n\nWe do not promise to curve exams. However, at the end of the term, we may make statistical corrections. Such corrections are not usually more than a few points, but they depend on the data. The corrections, if any, will never make your grade lower, only higher.\n\nLab scores are generally good. If you've missed no more than 1 or 2 labs, and you've submitted a good faith effort for every lab, then your score will be excellent. If you've missed more, then use the portion of labs you've attended and submitted as your approximate grade.\n\nQuestions about grades\nYou will receive all your evaluations online: both homework and exam grades will be reported on Gradescope www.gradescope.com\n\nWhen you receive evaluations of your work, you may have questions. You may suspect we've made a mistake. In fact, though we do our best, in a course this large, there will be mistakes in grading. This is normal, and we have a procedure to deal with it — we want to get things right! If there is a mistake in your favor, there is no need to report anything: it's your lucky day. If you feel there is a mistake that counts against you or if you would like clarification of an evaluation, follow this procedure, which is designed to help us support a large number of students and resolve issues that inevitably come up. We can't do this if all grading questions go through one or two people.\n\nDo not email grading questions. Follow the rest of these steps.\nFirst, read, re-read, and think about the comments in your evaluation. We often get questions that are directly answered in the evaluation, because students ask before they've even read the entire evaluation! Please read and think first. Often, figuring out what is meant on your own helps you learn more and allows us to help more students.\nRegrade requests on exams are done directly via Gradescope (see the link above). Click on the Regrade request link and follow the instructions.\nFor homework, bring your remaining questions to any member of the course staff during regular office hours. You do not need an appointment. Any member of the course staff (TAs or instructors) can explain things and fix errors. Do not email or post grading questions to the course forum. We have extensive office hour coverage, so you can get help quickly without the need for any special arrangements.\nWhen you ask for a correction, the grader will re-evaluate you work in whole or in part. It is possible for a grade to go down as a result. Therefore, remember step number 1 above.\nIf a TA cannot help you in office hours, then consult your lab leader or TF.\nIf the situation is still not resolved, then contact the instructors by posting a staff-only question on the course forum.\nPut [CS15] Regrade request\n        for assignment your_login in the subject.\nDescribe the steps you've followed inlcuding the names of any staff members you talked to. Briefly describe the issue and the way in which your previous efforts were not satisfactory.\nClearly say what you want done (e. g., if you would like us to reconsider a particular part of an answer on an exam, rerun some tests for a homework, etc).\nWe'll check with the TAs you name and get your situation resolved. We will not look at cases that have not gone through the proper process. Contacting instructors or a grad TA outside of office hours does not count as a contact for purposes of the 2-week statute of limitations (see below).\n\nStatute of limitations on regrade requests\nYou can get explanations and clarifications from the course staff at any time.\n\nHowever, to encourage students to read and think about their feedback in time for them to benefit, there is a one-week statute of limitations on grading corrections. We will work to address questions that come up on an assignment or exam for 1 week after the evaluations are made available to you.\n\nCollaboration and Academic Honesty\nAll of us should read the Tufts policies on academic integrity.\n\nWe can and do make routine use of automated systems for detecting plagiarism. These systems compare your submissions to submissions from both current and previous students. We do catch people, and Tufts does issue sanctions. We take it seriously, and so should you.\n\nSome critical guidance:\n\nSome work you do is to further your understanding. Some work will be used to evaluate your understanding (this work is graded). You may work with other students to further your understanding. Work submitted for evaluation is, unless otherwise stated, to be your work alone. You are bound by the basic principles of academic honesty and integrity.\n\nIt is never acceptable to present someone else's work as if it were your own. It violates the basic principle of academic honesty. All work you hand in is to be yours and yours alone, unless there is specific instruction to the contrary.\n\nWhile you are working on a homework assignment, you may collaborate with other students by talking about the problem or your solution in a natural language (e.g., in English), but you may not use any formal language, and especially not program code: high-level discussion is good, but each student must do an individual write-up in C++. In other words, you should not be looking at other people's code (assignment solutions), and you should not show your programs to anyone else. This applies to family members, roommates, and to student code from previous terms as well. Only you and the course staff are allowed to see your code. This should be obvious: Aritificial intelligence (AI) entities are no more you than your roommate. If you didn't do the work, then it is a violation of academic integrity.\n\nYou are encouraged to use the online forum to discuss course-related work, but the same rules apply: discussions should be in English and should not include code that is part of a homework solution.\n\nCite sources of help. Any discussion with others should be documented. An example might be including the following in a README file or in file comments: “Thanks to Sam Hugg for showing me how to initialize the linked list.” This includes TAs from whom you receive help. Academic honesty requires it. If you are not sure what constitutes collaboration or significant help, err on the side of caution. Giving others credit is good, and they will appreciate it, too.\n\nYou may consult public literature (books, articles, the web, etc.) for guidance. However, you must reference any sources that contribute to your solution. For example, “I used the Wikipedia page on the Poisson distribution to learn more about generating random arrival times.” You may not look at any solutions from previous versions of the course. You may not use generative artificial intelligence tools (e. g., ChatGPT) to do work for you. This applies to all work you submit for this course: code, documentation, READMEs, etc. You are here to learn as much as you can; you should not squander this opportunity by having AI models do your work for you.\n\nWhile computers enable easy collaboration and copying both from other students and materials from the internet, it is possible to use these same computers to detect plagiarism and collaboration. The course staff reserves the right to use any available computational tools, or to write new tools, to search for infractions. Remember: We have every project that has ever been submitted for this course available to us.\n\nIf any student does not understand these terms or any material outlined in The Academic Code of Conduct it is his/her responsibility to talk to the instructors or teaching assistants.\n\nPolicy on sharing course materials: It is against Tufts policy for anyone to share any content made available in this course including course syllabi, reading materials, problems sets, videos, handouts, and exams with anyone outside of the course without the express permission of the instructor. This especially includes any posting or sharing of videos or other recordings on publicly accessible websites or forums. Any such sharing or posting could violate copyright law or law that protects the privacy of student educational records.\n\nAdditionally, you may not make any of your work for this course publicly available online (e. g., in a public Github repository). Any course code you put online must only be privately accessible. Violations of this rule may be reported to the Dean of Students office for an academic integrity violation.\n\nGetting Help\nThe course can be challenging. Remember that sometimes sleeping on something will help to clarify it (a good reason not to wait until the last minute!). If you've been stuck on something for a while and you've given it a good effort, then seek help. Here are resources in the order you should try them:\n\nCourse web site You're already here!\nCourse on-line forum Sign up! See the description of the forum in this document.\nCourse resources The reference page has many useful resources that we have made or found specifically for a CS 15 level of understanding.\nOn-line resources The web is a wonderful trove of information. Some of it is good! Do be aware of the course collaboration policy. Do not use things you don't understand!\nStaff office hours During the term, the course will hold office hours as well as review sessions. The TA office hour schedule is on our course forum. Any permanent schedule changes will be reflected in the office hours post. Temporary changes, additional office hours, or one-time cancellations as well as any workshop information will be posted in individual notes there as well. Since the schedule may change, please check the forum before you come in. If you cannot find the TAs at the appointed time check the forum to see if there were changes. If they forget to post, then a gentle reminder on the forum is appreciated.\nThe professor will also hold regular office hours (see front page) and is also available by appointment.\n\nEmail Generally, please use office hours for course questions. You can post staff-only messages on on the the course forum, too. Emails may be monitored only loosely, and you will get quicker responses using the forum or office hours.\nPlease note: The course staff is not here to debug your programs. We are here to help you learn the material and gain the skills of the course. We will help you develop good programming and debugging skills, because those are crucial course skills for you to develop.\n\nWhen you come to office hours with a program bug, we will ask you to describe your plan, show us diagrams of data structures, outline your algorithms, and summarize what you have done so far. You can therefore help us to help you by coming in with a plan, pictures of your data structures, etc. If you don't have these ready, the staff will ask you to do them, and you can come back when you are prepared to receive help. Staff will also ask you what you have done so far and may ask you, for example, to determine exactly where a failure occurs and the values of all relevant variables at that point in the program.\n\nFor more tips on how to succeed in CS 15, see CS 15 Tips for Success.\n\nCourse Staff\nThere is a large staff here to help you: your instructor, graduate TAs, and a legion of able and helpful undergraduate TAs. Please come see us!\n\nFor questions of a general or technical nature, your first resource will be the course online course forum. Generally, you'll get much faster turnaround there.\n\nCourse Forum\nWe have a course forum at Piazza for class discussion (you should be added to this automatically). This is your forum. Use it to communicate with each other and the course staff. Just remember the cautions regarding collaboration. Send questions related to course material there rather than to the course staff via email: the next person who checks the site and knows the answer can respond. (The time between question and response is often just a few minutes, and the average is well under an hour!)\n\nPlease post your questions publicly. The value of an on-line forum is that many people can answer a question and many people can benefit from the answer. There is no reason to inform only one student of the scope of an exam or how a copy constructor works — post publicly! Instructor-only posts should only be for things that are truly unique to you. We also prefer that you avoid anonymous posts: it helps build a sense of community when people know whom they are talking to. Of course, the option is there if you like, but consider posting non-anonymously as much as possible.\n\nCheck the forum at least once a day: Important information and announcements will be sent there, including assignment clarifications and schedule changes.\n\nCourse Support\nInclusivity\nIn CS 15, we strive to create a learning environment that is welcoming to students of all backgrounds, regardless of race, class, gender identity, sexuality, religion, and ability. In a nutshell: computer science is for everyone. If ever you are made to feel uncomfortable or unwelcome in the class, please do not hesitate to speak to the instructors or anyone in our teaching staff, and we will work to make things better. You may also speak to your academic advisor, the department TA ombudsperson, our department chair, or your dean.\n\nStAAR Center: Subject Tutoring and Accessibility\nThe Student Accessibility and Academic Resource (StAAR) Center provides general academic support, in the form of study assistance, note taking, writing assistance, as well as specific subject tutoring, including for this class. They can help reinforce subject material, help you develop effective study strategies, and help you take responsibility for your own learning. Tutoring is available via drop-in hours as well as by appointment. There is more information available via the StAAR Center website.\n\nThe StAAR Center has a Canvas course, available all the time, with resources, including practice exams (to help with test anxiety).\n\nWe want to ensure equal access and support for all qualified students by providing reasonable accommodations to ensure each student can fully participate in the course. The Tufts StAAR Center accessibility services team helps us accommodate students with special needs. Students with special needs should contact the StAAR Center via the above link to determine and authorize appropriate accommodations.\n\nAccommodations cannot be applied retroactively (e. g., you cannot get extensions for exams or assignments already done), so it is important to do this right away.\n\nIf you qualify for accommodations, it is inportant to give that information to your instructor as soon as possible — within the first 2 weeks of the term or within a week of adding the course. It can take several days to work out accommodations, so I usually need the letter a week in advance. If you receive accommodations during the term, then please send the letter right away. This helps me plan so I can meet accommodations and support all the students in the course.\n\nMental Health Support\nAs a student, there may be times when personal stressors or emotional difficulties interfere with your academic performance or well-being. The Counseling and Mental Health Service (CMHS) provides confidential consultation, brief counseling, and urgent care at no cost for all Tufts undergraduates as well as for graduate students who have paid the student health fee. To make an appointment, call 617-627-3360. Please visit the CMHS website: http://go.tufts.edu/Counseling to learn more about their services and resources.\n\nTA Liaison/ Ombudsperson\nThe TA ombudsperson (AKA TA liaison) is here to help mediate conflicts that arise involving TAs. Specifically, the TA ombudsperson/liaison will help with the following situations:\n\nA student having a problem with a TA\nA TA having a problem with a student\nA TA having a problem with another TA\nA TA having a problem with an instructor\nIf you are involved in or aware of such an issue, please contact a TA ombudsperson, Prof. Mark Sheldon, at ta-ombudsperson@cs.tufts.edu or Prof. Karen Edwards at kedwards@cs.tufts.edu. See also the department CA information page (scroll to the bottom).",
    "Note: All lectures will be recorded and posted on the course Canvas page under \"Echo360.\"\nWeek 1: 1/12/2025\nTuesday No lab held\nLab: (Optional) Quick Intro to Writing, Running, Submitting Programs\nWednesdayLecture: Welcome - Introduction\nRead: CS15 Admin & Policies\nBrowse: CS15 Reference Page\nRead: Shaffer 1.1-1.2\nLecture: C++ Review: Classes (and more!)\nemployee code\nLecture: ArrayLists\nIntArrayList.h\nvectors.cpp\nRead: Intro to Valgrind\nThursdayFriday\nWeek 2: 1/19/2025\nMondayNo School\nTuesdayLab: Unit Testing, ArrayLists\nHW1 Out: ArrayLists\nWednesdaySubstitute Monday Schedule\nLecture: The Big Three\nshallow_example.cpp\ndeep_example.cpp\nLecture: (Virtual Mini-Lecture) Exceptions\nSlides\nexceptions.cpp\nRead: CS 15 Style Guide\nThursdayFriday\nWeek 3: 1/26/2025\nMondayLecture: Linked Lists 1\nStringLinkedList.h\nRead: Shaffer 4.1.2, 4.1.5\nTuesdayLab: Linked Lists\nHW1 due by 23:59:59\nHW2 Out: Linked Lists\nWednesdayLecture: Linked Lists 2\nLecture: Makefiles\nmake example code\nRead: Makefile Handout\nThursdayFriday\nWeek 4: 2/2/2025\nMondayLecture: Complexity\nRead: Shaffer 3.0-3.5\nTuesdayLab: make, diff\nHW2 due by 23:59:59\nProject 1 Out: MetroSim\nWednesdayLecture: Queues\nRead: Shaffer 4.3\nLecture: Stacks\nparen_matching.cpp\nRead: Shaffer 4.2\nThursdayFridayLab: (prelab) Circular buffers\nWeek 5: 2/9/2025\nMondayLecture: File I/O\nisprime.cpp\nRead: File I/O Handout\nLecture: Recursion\nTuesdayLab: Stacks, Queues, and Circular Buffers\nWednesdayProj 1 checkoff and phase 1 due by 11:59pm\nLecture: Binary Search\nis_in_array.cpp\nThursdayFriday\nWeek 6: 2/16/2025\nMondayNo School\nTuesdayLab: Recursion\nProject 1 due by 23:59:59\nProject 2 Out: CalcYouLater\nWednesdayLecture: Project 2 Background\nLecture: Trees\nint_tree_example.cpp\nThursdaySubstitute Monday Schedule: WE HAVE LECTURE!\nLecture: Binary Trees and their Traversals\nLecture: Sets\nFriday\nWeek 7: 2/23/2025\nMondayLecture: Binary Search Trees (BSTs)\nTuesdayLab: Binary Tree Traversals\nWednesdayProj 2 design checkoff and phase 1 due by 11:59pm\nLecture: BST (cont'd) and AVL Trees\nLecture Recording\nRead: Shaffer 13.2-13.2.1\nThursdayFridayLab: (prelab) AVL Trees Preview\nWeek 8: 3/2/2025\nMondayLecture: AVL (continued)\nLecture: Templates\nLinkedList.h\nListClient.cpp\nTuesdayLab: AVL Trees\nProject 2 due by 23:59:59\nWednesdayLecture: Midterm Info\nMidterm Practice Questions\nMidterm Practice Solutions\nLecture: Huffman Coding\nThursdayFriday\nWeek 9: 3/9/2025\nMondayLecture: Binary Search\nis_in_array.cpp\nLecture: Midterm Review\nTuesdayLab: Midterm Review (no spec)\nWednesdayMidterm\nThursdayFriday\nWeek 10: 3/16/2025\nMondayNo School\nTuesdayNo School\nWednesdayNo School\nThursdayNo School\nFridayNo School\nWeek 11: 3/23/2025\nMondayLecture: Priority Queues and Heaps\nRead: Shaffer 5.5\nProject 3 Out: zap\nTuesdayLab: Heaps\nWednesdayLecture: Hashes\ndict.cpp\ncollision_tester.cpp\nRead: Shaffer 9.4-9.4.2\nThursdayFriday\nWeek 12: 3/30/2025\nMondayLecture: Hashes (continued)\nTuesdayProj 3 phase 1 due by 11:59pm\nLab: Hashes\nWednesdayLecture: Intro to Graphs\nRead: Shaffer 11.0-11.2\nThursdayFriday\nWeek 13: 4/6/2025\nMondayLecture: Graph Traversals\nRead: Shaffer 11.3-11.4\nTuesdayLab: Graph Traversals\nProject 3 due by 23:59:59\nProject 4 Out: gerp\nWednesdayLecture: Dijkstra's Algorithm\nThursdayFriday\nWeek 14: 4/13/2025\nMondayLecture: Sorting I\nTuesdayLab: Dijkstra's Algorithm Worksheet\nWednesdayProj 4 design checkoff and phase 1 due by 11:59pm\nLecture: Sorting II\nThursdayFriday\nWeek 15: 4/20/2025\nMondayNo School\nTuesdayLab: Sorting\nWednesdayLecture: Sorting: Non-Comparison Sorts\nProject 4 Due by 23:59:59\nThursday\nFridaySaturday\nWeek 16: 4/27/2025\nMondayLecture: Final Info\nLecture: Wrap Up\nLecture: CS 40 Preview\nTuesdayReading Period\nWednesdayReading Period\nThursdayReading Period\nFridayFinal Exam (May 2nd)\nSec. 1: 12-2pm\nSec. 2: 3:30-5:30pm",
    "CS 15 Code Style Guide\n\nHow to write clear, concise, and modular C++ for CS 15\n\n\"A computer language . . . is a novel formal medium for expressing ideas about methodology, not just a way to get a computer to perform operations. Programs are written for people to read, and only incidentally for machines to execute.\"\n\n-- Structure and Interpretation of Computer Programs Harold Abelson, Gerald J. Sussman, Julie Sussman\n\n\nA program is a written description of your approach to solving a problem. It is a description that a computer can execute, but human readers are the target audience for whom you write. The compiler doesn't care about your variable names, code formatting, or comments-- it chews on what's underneath. People, on the other hand, rely on all those things, and you want them to understand and have confidence in your solution! Therefore, endeavor to write clear, concise, modular code.\nAll code you submit will be graded for structure and organization (including readability) as well as for functionality. Formatting matters. When you submit your work, it should be beautiful, and there should be no question of your dedication and correctness. Prepare it as if you were writing up an example for a good textbook. You wouldn't use a book that had no chapters, figures, captions, section headings, paragraph breaks, etc. Similarly, no one wants to read unorganized, undocumented code with huge functions and 500-character lines.\nJust as with a paper for a literature course, the first draft of a program that works is not usually the version to submit. We allocate points of your homework/project grades for code that meets the criteria for readability. For example, we expect that you will clearly and consistently indent your code and adhere to an 80 column limit. We will also grade your internal documentation.\nThis document contains requirements (and also hints) for how to write programs that others, including the graders, will find easy to read. No document can be complete, and if you ever have questions about what is readable and what is not, please come see us!\nFurthermore, although some of these style guidelines are specific to our course and others would not be applicable to all programming languages, writing readable, concise code is an extremely valuable skill that is important to practice early in your CS career; it will benefit you forever. No matter for whom you're writing your code, they will appreciate being able to read it without difficulty.\nFinally, this style guide is written for CS 15 students, and refers to key CS 15 concepts. Therefore, it's important to continually refer back to this style guide as you progress through the course and gain a better understanding of the ideas that will contextualize these guidelines. Check it before each homework, and you'll see your code- writing skills (and grade) soar.\nInternal Documentation (Comments)\nInternal documentation comes mainly in the form of comments, and is crucial to having easy-to-understand code. Ideally, it would allow a reader with little to no prior knowledge of C++ to understand the gist of what is happening in your code, and why. For this reason, much of your internal documentation will focus on the whys of your program — how does a given section of code contribute to the overall functionality of your program? This kind of documentation is important to include at many levels, from the README that describes your project as a whole, to the files that make up your program, to the individual functions you write, and even down to short but potentially confusing snippets of code.\n\nThere are two options for when to comment your code:\n\nBefore writing your code. Use comments (potentially combined with pseudo-code) to plan what you're going to write. As you write your code, update the comments to reflect changes in your plan.\nAs you write your code. Describe what you're doing in whatever piece of code you're currently writing. As your code becomes more complete, you can edit and potentially remove comments.\n\nWriting your comments after finishing your code is not an option! If you show code to a member of the course staff, it is acceptable for them to say \"I can't read this code without documentation. I'll help someone else while you work on that. Let me know when the documentation is complete.\"\nThe most important part of commenting is that the comments and code are in-sync with each other. Regardless of when you choose to write your comments, give them a once-over before submitting them to make sure that they still accurately represent your implementation. We have pondered for hours why code seemed to be different from what the comments said, only to conclude eventually that the code was unintentionally different from what the comments said. Then we had to find out which (if either!) was correct for the problem. Confidence in the code goes down after this.\nFile Header Comments\nFile header comments go at the top of each file. They must include some straightforward but important information — your name, the date, and the assignment title. When you edit a provided file that already has an author's name in it, you should add \"Edited by\" and then your name underneath the original author's name.\nAnother thing we look for in file headers is the purpose of the file. This is discussed in greater detail below.\nHeader comments should also include any known bugs or \"to do\" items. For example, \"Currently only supports sophomores. TODO: support students of other years.\"\nWhen you write a file's purpose in the header comments, the important thing to keep in mind is that you are writing for any potential users or clients of the file. A client will primarily be interested in what the file does at a high-level and how they can use it. A client typically does not care about low-level implementation details. With this in mind, there are typically three different types of files we must write header comments for:\nWhen a user opens your driver file (the file that contains main()), they are probably wondering: What does this program do as a whole? What purpose does it serve? Is it a good fit for what I need to accomplish? Therefore, when you write the file header for a driver file, you should describe the whole program at a high-level, leaving out any low-level implementation details.\nWhen a user opens a header (.h) file, they probably have noticed that it is a class header and are wondering: What is this class? What role does it play in the overall program? How does it interact with the other classes? What needs are best met by this class? They may be deciding whether to repurpose the class you wrote for a completely different program or, conversely, whether to use the rest of your program but replace that class with something else.\nThe file purpose for a header file should describe what instances of the class represent and what the abstract state of an instance is. For example: \"StudentList is a class that represents an ordered list of Student instances. Every new StudentList begins empty, and clients can then add and remove Students from the list.\" You may go on to describe other behavior (i.e., public functions) that the class provides. If there are limitations, document them: \"This class only handles lists of length 100 or less.\"\nThere should be very few, if any, implementation details in the header file purpose. The only implementation details included should be high-level ones that may be useful for a client to know. Here's an example of a helpful implementation detail: \"The list is implemented using an array, and therefore provides quick access to elements.\" Here's an example of unnecessary implementation details: \"The list is implemented using a pointer to a heap-allocated array, and an integer variable maintaining the capacity of that array. When the array fills up, its contents are copied to a new, larger heap-allocated array and the integer capacity is updated.\" The former focuses on efficiency, which is relevant to a client's decision process. The latter gets into low-level details that a client does not need to know about.\nIt is never the purpose of a class to \"contain nodes.\" That is an implementation detail that clients don't care about. Implementation-specific information should go in the private section of the class and/or in the implementation (.cpp) file.\nWhen a user opens a .cpp file for a class, it is probably because they have decided to use your class, either in your program or a program of their own, and want to know in greater detail how it works. They are probably wondering: How does this class actually work under the hood? Is there some bug still in this class I should know about? Is there some weird quirk or subtlety in the way this class is meant to be used?\nMany of these low-level implementation details will be contained within the function definitions within the .cpp file, as well as the contracts for those functions (see below). Therefore, in the file purpose for an implementation file, it sufficies to simply state that the file implements the corresponding class, e.g.: \"This file contains an implementation of the StudentList class.\" The only other details you may wish to include here are information about latent bugs/limitations of the class, or other quirks to the file that you believe may be helpful for a user to know.\n\nFunction Contracts\nFunction contracts appear just before the function header and are meant to explain how the function fits into the larger program. All functions should have function contracts, including int main in main.cpp. They must include the function's purpose, any parameters, any return values, and any other information that might affect the rest of the program. A function contract should not include implementation details, nor should it include information that can be found in the function prototype.\n\nPurpose should say what the function does, not how the function does it. Often this takes the form of answering how does this function fit into the larger program. It should not include any implementation details. E. g., a function's purpose might be \"To update the table so it maps the given key to the given value. The previous value associated with that key, if any, is lost.\"\nParameters should include information about what they represent in the function and larger program. This section should also include any restrictions or expectations on what will be passed as a parameter.\nThis section should not include information that can be gleaned from the function prototype: just saying \"two ints and a string\" is unhelpful.\nReturn value (if the function is non-void). \"Return the number of distinct items in the table\" or \"Return the first item in the list greater than or equal to the given value.\"\nEffects: This section should include side effects caused by the function. For example, in removeFromBack(), a list would change size (decrease in size by one). Input and output would be considered side effects, too.\nOther information: This would include any memory management obligations imposed on the client. For example, the client should be told if they will need to recycle storage returned to them. This is not likely to happen in CS 15, but arises frequently enough in industry and other courses that it's worth mentioning. One should definitely include any exit or failure conditions that would cause the program to halt or the function to throw an exception. Also include identified or suspected bugs within the function (\"this function does not work for __ reason\" or \"I think this function is causing my program to __\").\n\nHere is an example of a good function contract:\n/*\n * name:      getElement\n * purpose:   get the StringArrayList element at a given index\n * arguments: an integer idx representing a StringArrayList index\n * returns:   the string element at index idx\n * effects:   none\n * other:     throws an exception if idx is out-of-bounds\n */\nstring StringArrayList::getElement(int idx) {\n        ...\n}\n\n    \n\nIn-line Comments\nInclude:\n\nBugs. If you have identified a bug to a specific line of your program, make a note. Graders are more understanding of documented bugs versus bugs they have to suss out. At least, it shows you know it's there.\nConfusion. If there's an unclear or complicated section of your code, something that would not be obvious to someone with experience coding, explain it.\nCases. If you are writing the code to deal with a specific case that's relevant to key invariants of the data structure, you should identify the relevance of the invariant.\n\nDon't Include (in your submission):\n\nQuestions: In-line comments asking questions about the code or what should be done (\"Do I need to increment this here?\", \"I don't know if this works\") are not helpful and should not be in submitted code. Those kinds of questions can and should be addressed in office hours.\nOutdated TODOs: Comments that indicate things that need to be written and/or fixed are useful while you are working, but the things you TO-DID should not still say TODO. If a part of your implementation is missing, a TODO comment is helpful as an acknowledgement.\nComments documenting low-level details that are obvious from the code itself. For instance, here is an example of code with excessive comments:\n// increments i by 1\ni++\n// assigns x to the sum of y and z\nx = y + z\n// returns the size of s\nreturn s.size()\n          \nAll of the comments above are self-evident from the code they document.\n\nCommented-out code should not be submitted! It's great to test out multiple potential solutions to a problem, but by the time you submit, you should have chosen the code that works the best and deleted anything you decided not to use. The occasional (but notable) exception to this rule is unit testing code that is meant to crash your program.\nThe README\nA README is a file used to describe a program. Every open source project has a README file that describes what is going on in a program, what is necessary for it to work properly etc. In this course, it additionally will answer questions related to the topics/data structures covered in the assignment. The first thing someone opens when they look at a project is the README. When we are grading, that is the first file we open and the place we will go if we have questions or confusion about the code. It is crucial to fill it out thoroughly and in detail.\n\nREADME files contain some straightforward, but important information:\n\nYour name, the date, the assignment title, and the course (CS 15)\nHow to compile and run your program\nAcknowledgements of any help you received — TAs you sought help from in office hours, peers you vented about your coding struggles with (without showing them your code, of course!), snippets of code from lecture or the course website you used as inspiration, online resources you found helpful (including our class forum), etc. Even if an assignment was particularly easy for you and you didn't receive help from any of these sources, this section should not be left blank. You could instead list one obvious source of information, such as the professor's lecture on a relevant topic.\nAny bugs still in your program that you were unable to fix, and where they can be found in the code\nData structures section for you to describe the data structures and/or ADTs used in the assignemnt\nSometimes the spec will include questions that should be answered in your README. It's worth noting here that those tend to be a significant portion of your grade.\nTime spent section for you to note how many hours you spent on a particular assignemnt\n\nThere are also parts of the README that are a little less straightforward:\n\nYou should describe the purpose of your program. This can and should be done in three sentences or less, but it's important to think hard about what information would be useful to a potential user of your program. Namely, the implementation details of a program are almost always irrelevant to its purpose. When I was deciding between Atom, VSCode, Vim, Emacs, and Sublime, I considered the features of each editor and how effectively each one suited my needs. I did not wonder about the underlying implementation details of each editor at all. The only acceptable implementation details in a program purpose should be high-level and relevant to the user (see the description of .h header file comments for an example).\nYou should list and briefly describe every file you submitted. A list like the following would suffice:\n\nStudentList.cpp: Implementation of StudentList class.\nStudentList.h: Interface of the StudentList class.\nmain.cpp: Driver file which interacts with the user and the StudentList class.\nunit_tests.h: Unit tests for the StudentList class.\nREADME: This file.\ntest_data1.txt: Test input data.\ntest_data2.txt: Test input data.\n        \nIt's important to list every file you submitted, even if the description is obvious! For example, if one of your files is mistakenly left out of your submission, having it listed in the README will help the TA understand what happened and remedy that.\nYou should describe, chronologically and in detail, how you tested and debugged your program as you were working on it. In this course, you will be required to write unit tests for every program you write. Unit testing is necessarily something you do as you write your code, so the full process is not always perfectly visible from the final files you submit. This is your chance to convince the grader that you thoughtfully and thoroughly tested your program as you were writing it. Include, for example, information about how you isolated and tested particularly tricky functions, and describe bugs you found while unit testing and how you fixed those, or edge cases that came up through your testing. If you tested as you wrote code and documented your ideas throughout the assignment, this step should be trivial.\nLast but not least, seeing as this is a Data Structures course, you should describe the data structures and/or ADTs you used in your program! This is your chance to explain the implementation details of your program. What data structures or ADTs did you practice writing this week? How do they work? What are their advantages and disadvantages? Some examples of data structures you could include, if applicable, are array lists and stacks. Similarly, if you learned and practiced implementing a new algorithm, briefly explain how it works. Write as if this section is meant to be read by somebody who has only taken an introductory computer science course, but is really interested in learning about the concepts from our course.\nThe Code Itself\nOrganization into Classes and Structs (Data Structures!)\nIf a struct is meant to be used in a class, it should be defined inside of that class. If it is used internally to the class, it should be private. For example, a Node struct used inside a linked list should be private. If a struct needs to be declared outside of any other class for whatever reason, it should be declared in its own header file.\nNon-interface functions in a class should be declared private. The only functions that should be public are the ones required for the client to be able to use the class.\nAll data members should be declared private.\nRecursion\nRecursive functions should only be concerned with the current element. Avoid dereferencing \"next\" or children pointers in the function body; rather, just recurse to the next or child node.\nVariables\nNo global variables: no variables should be declared or defined outside of functions with the exception of global constants.\nUse of literals should be avoided; use global (or static) constants instead. If your program calls for an 8x8 two-dimensional array, for example, create a global constant ARRY_SIZE = 8, then declare your array with int[ARRY_SIZE][ARRY_SIZE] rather than int[8][8].\nVariable names should be descriptive, with the exceptions of variables with very limited scope: i and j for loops (triple-nested loops should not occur); curr_<type> (e.g. curr_node) as a pointer; temp or aux for very temporary variables (accessed by 3 lines of code or fewer). One appropriate use for temp would be swapping two elements in an array, for example. Foo, var, and x are not descriptive variable names and should never be used.\nBrevity\nUse boolean expressions and values. For example, there is no reason to write\nif (isBig == true)\nwhen you can write\nif (isBig)\nDon't write functions longer than 30 lines between the opening and closing brace. This will affect your modularity grade.\nDo not rewrite code that is given to you, create functions with nearly identical uses, or write in-place code when there is a function you can call to do the same work.\nUse helper functions to simplify code, especially if they can be called in many places. But a helper function can also be useful if it provides a name for a computation that makes other code clearer. For example, rather than test\nif (front == nullptr)\nall the time, you can define a function called\nif (isEmpty())\nTry to avoid doing unnecessary work. For example, rather than recomputing something several times, compute it once and save it in a well-named variable.\nWhitespace\nIndentations should be made up of either 4 or 8 spaces, not tab characters (with the important exception of makefiles. If you don't understand why a Makefile must contain tabs, ask a TA). Tabs display differently based on a computer's settings, but spaces always look the same. Most text editors have a setting to output a specified number of spaces instead of a tab character whenever you press the \"tab\" key.\nFurthermore, indentation should be consistent! Indentation is a crucial part of code's readability, as it helps readers understand how code fits together. Make sure the levels of indentation accurately reflect which function or code block(s) any given line is part of.\nIn our course, the width of your indentation should be either 4 or 8 spaces. Indentation of only two spaces makes your code more difficult for us to read. If this causes you to struggle to adhere to the 80 column rule, then your code has too many levels of nesting, and needs to be more concise, more modular, or both.\nBinary operators (operators that take two pieces of input, such as '+', '*', '=', and '=='') should have spaces around them. There are two exceptions to this rule. The first is the dot operator (.) for accessing struct or class members. The second is the arrow operator (->) for dereferencing a struct or class pointer and then accessing a member. There should not be spaces around either of these operators. To clarify, you should do object.member and object_ptr->member.\nUnary operators (operators that take only one piece of input, such as '++'') should not have spaces around them.\nWhen declaring pointers, the asterisk should be attached to the variable name, not the type (Node *curr rather than Node* curr).\nRationale: The compiler interprets the * as a decoration of the variable name on its right, not part of the type: Node* np1, np2; declares one pointer variable and one variable that contains a Node, which is confusing as written. Putting the * next to the variable it modifies makes it clear to the reader which variables, if any, hold pointer values: Node *np1, np2;. (np2 is poorly named, but its status in the declaration is clear.)\nIn lists declaring and initializing variables, there should be a space after every comma.\nThere should be a single space between a loop or conditional keyword (such as for, if, and while) and its corresponding opening parenthesis, but no space between the name of a function and its corresponding opening parenthesis.\nThis should go without saying, but do not violate any of these guidelines in order to make your code adhere to the 30 line or 80 column rules. This will make your code difficult for the grader to read, and therefore will not help your score.\nOther Guidelines\nNo line should be longer than 80 characters. In other words, no files that you wrote should have more than 80 columns. Typing \"wc -L *\" into the terminal will display the number of columns in each file in your current folder.\nThere are some style rules that pertain to conditional statements and loops, as well. These determine the control flow of your program, so having easy-to-read conditional statements and loops is immensely important to a reader's ability to understand what is happening in your code.\nUse the keywords \"and,\" \"or,\" and \"not\" as opposed to the older, equivalent operators \"&&,\" \"||,\" and \"!\" so your code is both easier to read and less prone to difficult-to-spot bugs caused by typos. (Note: You should use \"!=\"\" when checking for inequality)\nDon't treat non-boolean variables as booleans — we know that when a number is 0 or pointer is null, it will evaluate to false. For readability, however, you should explicitly compare the variable to zero. For example, write while (n > 0) rather than while (n) (Sorry, Python programmers.)\nThe break keyword should only be used when you have a switch statement. In addition to making loops more difficult for a reader to understand, it undermines one objective of our course, which is to learn to write code (including loop conditions) thoughtfully.\nReturning from inside of a loop, however, is often useful and encouraged. The continue keyword may be used occasionally, but should be avoided when possible.\nCurly braces. We are somewhat flexible on this, but be consistent, but here are some notes:\nIf an open curly brace ({) is placed at the end of a line of code, there should be a space before it to separate it from what came before. It may also be placed on the next line lined up under the beginning of the statement it's part of.\nClose curly braces (}) should be on a line by themselves unless the statement they are part of continues. For example, you may write \"} else {\" all on one line (or you can put each item on its own line).\nWe do not require the use of curly braces for blocks of a single statement. That is, you may write an if statement or a for loop without any curly braces if the body is one line long. However, as a rule, do not put an entire if statement on one line.\nThe keyword auto should only be used when declaring variables of the iterator type. This is a Data Structures course — you're expected to develop a very strong grasp of which class, struct, or primitive data type you are working with at any given time.\nWhen working with pointers, the keyword nullptr is preferable to the old-fashioned, C-style constant NULL.\n[EDIT: Added Jan - 27 - 2022] Finally, we gently recommend against using this-> to refer to a class' members from inside of one of its functions. Points will not be taken off for doing so, but students should know that it is typically unnecessary.\n\nFinally, our parting word of advice is to always give your code a quick once-over immediately before submitting. Maybe there are function contracts or file headers that are no longer relevant; maybe you forgot to document something as you were writing; or maybe there is a particularly complicated function that you will realize needs better in-line commenting. Documentation and Style points are, in many ways, the easiest points to earn on any given CS 15 assignment — whether or not you have time to get your code working perfectly (or at all) before the due date, you can always get full points for this section. Don't let yourself miss out on what should be very reliable credit just because something slipped your mind!\n",
    "Welcome to CS 15!\n\nCS 15 is all about building your programming toolkit. The tools are data structures, the means by which we store, organize, and access data. We will implement and utilize the key data structures and algorithms that every programmer must know, learn about the useful abstractions that they provide, and study the costs in time and space associated with them.\n\nThe structure and assignments of this course are based largely on prior versions of the course taught by Marty Allen, Mark Sheldon, Mati Korman, Chris Gregg, Ben Hescott, and Bruce Molay. Thank you!\nCourse Information\nCourse Policies: All students are expected to know and adhere to our course policies. Please take the time to read our admin page in full.\n\nPrerequisites: CS 11 or consent of instructor.\n\nTextbook: No purchase required. We will regularly post online readings from Data Structures and Algorithm Analysis by Clifford A. Shaffer.\n\nInstructor: Milod Kazerounian\nEmail: milod.kazerounian@tufts.edu\nOffice: JCC 469\nOffice Hours: Tuesdays from 1-2pm in JCC 469, Thursdays from 2-3pm on zoom\n\nOur graduate TA is Max Liu. Our teaching fellows are Arya Prasad, Hameedah Lawal, Kathy Quintanilla, and Liam Drew. We also have a horde of teaching assistants who will hold office hours in the third floor common space in the Joyce Cummings Center. Schedules for office hours will be regularly updated on our course forum, Piazza.\n\nLecture Section 1: (Mon/Wed) 10:30 – 11:45am\nLocation: Barnum Hall LL08\nFinal exam: May 2nd from 12-2pm\n\nLecture Section 2: (Mon/Wed) 3:00 – 4:15pm\nLocation: Robinson 253\nFinal exam: May 2nd from 3:30-5:30pm\n\nFor Spring 2025, both lectures will be automatically recorded by Tufts IT and posted on the CS 15 Canvas site under Echo 360. If you miss a lecture, you can find it there.\nWe do not use Canvas for anything else in CS 15!\n\nBecause all lectures are recorded, we are all on video with audio. The videos are for use by this class only and must not be downloaded or distributed.",
    "    CS 15 Project 2: CalcYouLater\nIntroduction\n\nPreamble\nWelcome to the second project! It’s a calculator, but it’s even more. It’s almost a real programming\nlanguage! This is a more involved project, for which you have been given ample time, if you start\nright away.\n\n                               Do not try to do it in one sitting\n\nRead it right away. Jot down and draw ideas. It’s better to work on it in 90 minute or 2 hour\nchunks of time. If you do that, and you’re organized, it will go smoothly. The stack implementation\nitself should be doable in a single sitting. Be sure to note the multiple phases of the project. Come\nin to talk to one of us about your plan as early as you can.\n\nNote on File I/O\nFor this project, you’ll find knowledge you acquired about file I/O in Project 1 helpful. In particular,\nthe ability to pass a reference to an std::istream to a function makes it easy to modularize your\ncode by allowing a function to process input from any input stream, whether it be std::cin or a\nstream that you attached to a file using open.\n    There is an additional piece here. C++ has a way for you to treat a std::string as if it were\nan input stream! It has a class,\ncalled std::istringstream. Its constructor and an example of how to use a std::istringstream\nfor input can be found here. A istringstream has eof and fail member functions, just like\nstd::cin or any other input stream. The idea for our purposes is to make an std::istringstream\nfrom a std::string, and then pass that std::istringstream to a function that requests an\nstd::istream &, and it will work!\n\n\nIntroduction\nIn this project you will implement a Reverse Polish Notation (RPN) calculator. RPN is also known\nas “postfix” notation1 . This means that the operator comes after its operands rather than in\nbetween. For example:\n\n      • 3 4 + is equal to 7\n\n      • 3 4 * is equal to 12\n\n      • 1 2 - is equal to -1 (note the order)\n\n      • 8 2 / is equal to 4 (note the order)\n\nCool fact: RPN does not need any parentheses as long as each operator has a fixed number of\noperands (which is the case in this assignment). For example, the infix expression:\n\n      5 + ((1 + 2) * 4) - 3\n\ncan be written in postfix notation as follows:\n\n      5 1 2 + 4 * + 3 -\n\nYour RPNCalc will support more than just integers, however! It will support Datum objects! More\non this in a moment.\n\n\n\n\nProject Planning and Deliverables\n\n    Before writing any functions, sit down and read the assignment specification in full. There is a\nlot of complexity here! Then, begin to plan your solution. It would be prudent to organize and plan\nyour solution to be as modular as possible. Use helper functions! Doing this initial planning will be\nextremely helpful down the road when it comes to testing and debugging; it also helps the course\nstaff more easily understand and read your work (which can only help you). It is not advisable\nthat you sit down and attempt to write this in one sitting, particularly if that sitting is close to\nthe deadline. For that reason, the CS 15 course staff has come up with a project implementation\nplan, split into three required (read: graded) phases:\n  1\n      The notation you’re used to, with the operator between the operands is called “infix” notation.\n\nWeek One\nDeliverable #1: Design Checkoff\nFirst, complete the required design checkoff questions given in the starter file cyl design checkoff.txt,\nand submit your answers on Gradescope under the assignment “CalcYouLater Design Checkoff.”\nYou must submit this file prior to meeting with a TA.\n    Then, go to office hours and talk to a TA about your plan. You should be prepared to discuss\nthe answers you submitted. You are welcome to bring other materials as well, though you are not\nrequired to: drawings, pseudocode, etc.\n    The design checkoff helps twofold: you plan out your project and get your brain working on\nit in the background, and you also get design feedback before it’s too late. TAs will check off\nyour design, but reserve the right to not check off your design if they believe your design was not\nthoroughly mapped out enough. Please sign up for a design check off on the form linked here.\n\nDeliverables #2 and #3: DatumStack class and parseRString\nWrite and submit the DatumStack class and parseRString function (these are described in detail\nunder sections of their own names below). These are not expected to be strenuous exercises, but\nhave been known to occasionally hide latent bugs that mess up the rest of your RPNCalc. So, start\nthem early, get them right, and make sure they are well-tested.\n\n\nWeek Two\nDeliverable #4: CalcYouLater\nWrite CalcYouLater! (described in detail below) Implement some of the less involved operations\nfirst. Then do the more complicated operations.\n\nDatum Class\n\nIntroduction\nBefore diving in to the details of the RPNCalc and DatumStack clases, we will go over the Datum\nclass. A Datum object is essentially a container for one of three things:\n   • int\n   • bool\n   • rstring (short for RPN string)\nThe type of the value contained by any given Datum object is chosen from the above three options\nat construction-time, and does not change during the lifetime of that Datum object. We have coded\nthe Datum class for you, but it would be worth your while to understand the interface.\n\fDatum Interface\n   • Four Constructors: one constructor for each type a Datum object can contain, plus a copy\n     constructor. Note that there is no default constructor. Also note that, under the hood,\n     rstrings are represented as C++ strings.\n  1   Datum(int i);\n  2   Datum(bool b);\n  3   Datum(string s);\n  4   Datum(const Datum &d);\n\n   • A destructor\n\n   • An assignment operator overload\n\n   • Three type query functions:\n  1   bool isInt();\n  2   bool isBool();\n  3   bool isRString();\n\n\n   • An equals (==) operator for comparing two different Datum objects. This allows us to call,\n     e.g., d1 == d2 where d1 and d2 are instances of the Datum class. If d1 and d2 contain values\n     of different types, this would return false. If d1 and d2 contain values of the same type,\n     then the underlying values will be compared.\n\n   • The less-than (<) operator for Datum holding integers. Using the less-than operator and\n     the is-equal-to operator, we can build less-than-or-equal (<=), greater-than-or-equal (>=), and\n     greater-than (>). Use of any of these operators on Datum which hold booleans or rstrings\n     will raise a std::runtime_error with the message “datum_not_int”.\n\n   • Three data access functions:\n  1   int getInt(); // throws \"datum_not_int\"\n  2   bool getBool(); // throws \"datum_not_bool\"\n  3   std::string getRString(); // throws \"datum_not_rstring\"\n\n\n      These functions each throw an std::runtime_error with the associated message above if\n      they are called on a Datum of the wrong type. For instance, if I have a Datum that contains a\n      boolean value, and I call getRString() on it, it will raise a std::runtime_error with the\n      message datum_not_rstring.\n\n   • toString(), a function that creates a string representation of the Datum. This is useful for\n     printing and debugging.\n\n\nFile Organization for the Provided Datum Files\nThe Datum class is given to you as two files: Datum.h and Datum.o. Datum.h contains the interface\nof the Datum class; Datum.o contains a pre-compiled object file. That is, it is a non-human-readable\nfile which was compiled from a .cpp file, and it contains all of the working machine code that you\ncan use in your project, but does not give you any information about how it works. What it\ndoes, however, can be gleaned from Datum.h (the interface). To use the Datum class, you must\n\n\f#include \"Datum.h\" at the top of whichever file will use it, and you must link Datum.o with your\ncompiled code. To review linking .o files, see the Makefile lecture and lab.\n\n\nDatumStack Class\n\nIntroduction\nThe DatumStack class will maintain a stack of Datum objects, and will be used heavily by the\nRPNCalc class. Part of your Week 1 assignment is to to implement this interface.\n\n\nDatumStack Interface\nYou DatumStack class must have the following interface (all the following members are public):\n\n   • Two constructors as follows:\n\n        ◦ A default constructor, which takes no parameters and initializes an empty stack.\n        ◦ A constructor which takes an array of Datum and an integer specifying the size of the\n          array as parameters and creates a stack initialized so that the elements of the array are\n          on the stack with the array’s element 0 pushed on first and it’s (size - 1)th element\n          at the top of the stack. Example:\n       1   Datum data[2] = { Datum(5), Datum(true) };\n       2   DatumStack d(data, 2);\n       3   // d now has a true Datum as the top element\n\n\n   • If necessary, define the Big Three (destructor, copy constructor, assignment operator).\n\n   • An isEmpty function that takes no parameters and returns a boolean value that is true if\n     this specific instance of the DatumStack class is empty and false otherwise.\n\n   • A clear function that takes no parameters and has a void return type. It makes the current\n     stack into an empty stack.\n\n   • A size function that takes no parameters and returns an integer value that is the number of\n     Datum elements on the stack.\n\n   • A top function that takes no parameters and returns the top Datum element on the stack.\n     NOTE: It does not remove the top element from the stack. If the stack is empty, it throws\n     a std::runtime_error exception with the message “empty_stack”.\n\n   • A pop function that takes no parameters and has a void return type. It removes the top\n     element on the stack. NOTE: It does not return the element. If the stack is empty it throws\n     a std::runtime_error exception with the message “empty_stack”.\n\n   • A push function that takes a Datum element and puts it on the top of the stack.\n\n\nRPNCalc Class\n\nIntroduction\nThe interface for the RPNCalc class is rather straightforward—the complexity is not in the number\nof functions, but rather is in the logic of processing the commands that come to the run function.\n\n\nRPNCalc Interface\n   • Define a default constructor which takes no parameters and initializes the RPNCalc object.\n\n   • Define a run function that takes no parameters and returns nothing. This function reads\n     in commands from standard input (std::cin). Each command can be read as a string and\n     commands will be separated by whitespace. Commands do not have to be on different lines.\n     See below for details.\n\n   • Optional: Define a destructor that destroys/deletes/recycles any heap-allocated data you\n     may have used in the RPNCalc instance.\n\n\nThe ‘Simpler’ RPNCalc Commands\nThe supported operations will be extended by the “harder” commands, but implement these simpler\ncommands first and get them working before continuing on.\n   • A number causes a Datum containing the number to be pushed onto the stack.\n\n   • #t causes a Datum with the boolean true to be pushed on the stack.\n\n   • #f causes a Datum with the boolean false to be pushed on the stack.\n\n   • not reads and pops the top element off the stack, a boolean, and causes a Datum with the\n     opposite boolean value of the popped element to be pushed on the stack.\n\n   • print prints the value on the top of the stack to std::cout (without popping it) followed\n     by a new line.\n\n   • clear clears the calculator, emptying the stack.\n\n   • drop causes the top element on the stack to be removed.\n\n   • dup duplicates the top element on the stack.\n\n   • swap swaps the top two elements on the stack.\n\n   • quit, quits the calculator completely. When the program quits, it prints the following message\n     to std::cerr: “Thank you for using CalcYouLater.\\n” (It should print this message whether\n     it quits with the quit command or by reaching the end of input on std::cin).\n\n   • The operators +, -, *, /, or mod. Any of these causes the top two elements (which must both\n     be integers) to be popped off the stack, the operation to be performed on them (addition,\n     subtraction, multiplication, division, or remainder), and a Datum with the result to be pushed\n     on the top of the stack. The first operand of the operation is the first (deeper) item on the\n     stack. NOTE: The result does not print.\n\n   • The operators <, >, <=, >=, or ==. Any of these causes the top two elements to be popped off\n     the stack, the operation to be performed on them (some kind of logical comparison) and a\n     Datum with the result (a boolean) to be pushed on the top of the stack. The first operand of\n     the operation is the first (deeper) item on the stack. NOTE: The result does not print.\n\n\nThe ‘more Complex’ Commands\nAny rstring\nYou can think of an rstring as a sequence of commands to be saved and executed later. For our\npurposes, an rstring will be defined as a sequence of characters that follows this pattern:\n\n   • The sequence must begin with \"{ \" (note the space!).\n\n   • The sequence must end with \" }\" (note the space!).\n\nAny rstring that is provided as input to RPNCalc will be put inside of a Datum as an std::string,\nand the Datum will be pushed onto the stack. To clarify, “rstring” itself is not a command; rather,\nan example of a command that would be parsed as an rstring and pushed onto the stack would\nbe “{ 2 8 + }”. Another example would be “{ 2 + }”.\n    Note: The braces must match up, and the spacing around the beginning and ending\nbraces must be correct. I.e., { 2 + } is treated as an rstring, while {2 +} is treated as\ntwo unrecognized commands (think about why that is!). Also, rstrings can be nested\n- to see an example of nested rstrings, read on about if.\n    Clearly, processing rstrings will be important for the success of your RPNCalc class. Thus, part\nof your Week 1 assignment is to implement a function to parse rstrings. While reading in input,\nonce you read a \"{ \", you should call this parsing function. See the section titled parseRString\nSpecification (below) for details.\n\nexec\nexec takes the topmost element on the stack, which must be an rstring, and processes its contents\nas a sequence of commands. If the topmost element of the stack is not an rstring, it should print\n“Error: cannot execute non rstring\\n” to std::cerr, and your program should continue to accept\ninput.\n\nfile\nfile pops the top element off of the stack, which must be an rstring. If it is not an rstring it\nshould print “Error: file operand not rstring\\n” to std::cerr, and continue to accept input.\n\n   For example, the rstring might be “{ square.cylc }”, in which case the filename is “square.cylc”.\nThe contents of the named file is then read and processed as if its commands had been typed into the\ncommand loop. If the file cannot be opened or read, the message “Unable to read FILENAME\\n”\n(where “FILENAME” is replaced with the name of the file specified in the command) is printed to\nstd::cerr. The program does not crash or throw an exception. The command loop then continues\nreading data from its last input source.\n\nif\nif Overview\nif has a few steps. The command if:\n\n     1. pops an rstring off of the stack—this rstring will be executed if the condition is false.\n\n     2. pops another rstring off of the stack—this rstring will be executed if the condition is true.\n\n     3. pops a boolean off of the stack—this is the condition to test.\n\nTo clarify, if assumes that the stack will look like this at the time it is called:\n\ntop:            | FalseCase     |\n                | TrueCase      |\nbottom:         | TestCondition |\n                -----------------\n\nIf the test condition is the boolean true, then the TrueCase in the diagram above should be exec’d.\nIf the test is the boolean false, the FalseCase in the diagram above should be exec’d. If any of\nthe elements encountered are of the wrong type, choose the appropriate error message to print to\nstd::cerr:\n\n     • “Error: expected rstring in if branch\\n”\n\n     • “Error: expected boolean in if test\\n”\n\nYour program should not throw an exception. After printing to std::cerr, it should continue\naccepting input.\n\nif Examples\nHere are some examples of if in action that you might find helpful. Please note that the > characters\nbelow are the prompt (which you should not output, but we have included for readability in this\ndocument), not the greater-than sign.\n                                            useless if input to RPNCalc\n    > 3 4 <\n    > { #t } { #f } if\n    > print\n    #t\n    >\n\n\n                                                 translated to C++\n1   if (3 < 4) {\n2       return true;\n3   } else {\n4       return false;\n5   }\n\n\n                                      if   that mimics the behavior of “not”\n    > 3 4 <\n    > { #f } { #t } if\n    > print\n    #f\n    >\n\n\n                                                 translated to C++\n1   if (3 < 4) {\n2       return false;\n3   } else {\n4       return true;\n5   }\n\n\n                                           A more complicated nested if\n    > 4 dup 10 ==\n    > { 1 0 / }\n    > { 6 + dup 10 < { 10 > } { 10 == } if }\n    > if\n    > print\n    #t\n    >\n\n    Which should read as follows:\n\n       • Push 4 onto the stack twice. Check if 4 is equal to 10.\n\n       • If so, execute the rstring “{ 1 0 / }”.\n\n       • If not:\n\n            ◦ try adding 6 to the 4 on the stack.\n            ◦ check if that result is smaller than 10 (it shouldn’t be).\n                   - If it is, check if it is greater than 10 (it shouldn’t be).\n                   - If it is not, check if it is equal to 10 (it should be).\n\f    CONTENTS                                                                                      11\n\n\n                                           translated to C++\n1     if (4 == 10) {\n2         return 1 / 0;\n3     } else {\n4         if (4 + 6 < 10) {\n5              return 10 > 10;\n6         } else {\n7              return 10 == 10;\n8         }\n9     }\n\n\n\n    Just For Fun Exercises!\n       • set followed by the name of a variable causes the variable to be set to the value on the top\n         of the stack, which is then popped.\n\n       • get followed by the name of a variable pushes the value of the variable onto the stack. If\n         the variable has not yet been defined, print the variable name and then “: undefined” on\n         std::cerr (e.g. “x: undefined”). It should not throw an exception. After printing, it should\n         continue accepting input.\n",
    "              CS 15 Project 4: gerp\n\nIntroduction\n\nWe’re all familiar with web search engines, and we also have tools for searching our personal\ncomputers. Have you ever wondered how the Mac Spotlight works, for example? We’ll look at\none approach now! In this assignment you will design and implement a program that indexes and\nsearches files for strings. Your program will behave similarly to the unix grep program, which can\nsearch through all the files in a directory and look for a sequence of characters.\n\n\nBackground: grep\nHere’s an example of calling unix grep:\ngrep -IRn Query DirectoryToSearch\n\n\nIn this example:\n\n    • grep is the program we’re calling\n\n    • Query is the target string we’re searching for\n\n    • DirectoryToSearch is the directory where we will look for the Query\n\n    • the option I means to search all files, including binary files\n\n    • the option R means to traverse all files under the provided directory recursively (including\n      following symbolic links)\n\n    • the option n means to print each output line from grep with the line number of the match of\n      the “Query” within the matched file.\n\nFor example,\ngrep -IRn #include /comp/15/files\n\n\nwill produce something like\n\n/comp/15/files/hw1/CharArrayList.cpp:12:#include \"CharArrayList.h\"\n/comp/15/files/hw1/simple_exception.cpp:27:#include <iostream>\n/comp/15/files/hw1/simple_exception.cpp:28:#include <string>\n/comp/15/files/hw1/simple_exception.cpp:29:#include <stdexcept>\n/comp/15/files/hw1/unit_tests.h:15:#include \"CharArrayList.h\"\n/comp/15/files/hw1/unit_tests.h:16:#include <cassert>\n/comp/15/files/lab2/LinkedList.cpp:13:#include \"LinkedList.h\"\n/comp/15/files/lab2/LinkedList.cpp:14:#include <sstream>\n/comp/15/files/lab2/LinkedList.cpp:15:#include <string>\n/comp/15/files/lab2/LinkedList.h:15:#include \"Planet.h\"\n/comp/15/files/lab2/Planet.cpp:11:#include \"Planet.h\"\n/comp/15/files/lab2/Planet.cpp:12:#include <sstream>\n/comp/15/files/lab2/Planet.cpp:13:#include <string>\n/comp/15/files/lab2/Planet.h:14:#include <string>\n/comp/15/files/lab2/planet-driver.cpp:14:#include \"LinkedList.h\"\n/comp/15/files/lab2/planet-driver.cpp:15:#include \"Planet.h\"\n/comp/15/files/lab2/planet-driver.cpp:16:#include <iostream>\n/comp/15/files/lab2/unit_tests.h:6:#include \"LinkedList.h\"\n/comp/15/files/lab2/unit_tests.h:7:#include \"Planet.h\"\n/comp/15/files/lab2/unit_tests.h:8:#include <cassert>\n/comp/15/files/lab2/unit_tests.h:9:#include <iostream>\n/comp/15/files/hw2/CharLinkedList.cpp:12:#include \"CharLinkedList.h\"\n/comp/15/files/lab0/welcome.cpp:7:#include <iostream>\n/comp/15/files/lab1/ArrayList.cpp:15:#include \"ArrayList.h\"\n/comp/15/files/lab1/ArrayList.cpp:16:#include <sstream>\n/comp/15/files/lab1/ArrayList.h:14:#include <string>\n/comp/15/files/lab1/unit_tests.h:19: * Be sure to #include any .h files as necessary\n/comp/15/files/lab1/unit_tests.h:37:#include \"ArrayList.h\"\n/comp/15/files/lab1/unit_tests.h:38:#include <cassert>\n/comp/15/files/lab1/unit_tests.h:39:#include <iostream>\n/comp/15/files/lab1/unit_tests.h:40:#include <string>\n/comp/15/files/compilation_tests/hw1_test.cpp:13:#include <iostream>\n/comp/15/files/compilation_tests/hw1_test.cpp:14:#include \"CharArrayList.h\"\n/comp/15/files/compilation_tests/hw2_test.cpp:14:#include \"CharLinkedList.h\"\n/comp/15/files/compilation_tests/hw2_test.cpp:13:#include <iostream>\n\n\nThe first line of this output tells you that #include can be found on line 12 of the file located at\n/comp/15/files/hw1/CharArrayList.cpp, and that the line itself is #include \"CharArrayList.h\".\nAlthough there are many optional flags you might use with grep (see https://linux.die.net/\nman/1/grep for the details), our gerp program is designed to replicate the core functionality above,\nwith a twist!\n\n\nProgram Design Overview\nHow might we build something like this? We will start by limiting the constraints of our solution—\nwhereas grep produces near-instantaneous results of matches at each run of the program, we will\ntake a two-step approach with gerp:\n\n    1 Build a data structure that indexes a set of files\n\n    2 Use that index to respond to queries\n\nThat is, when gerp is run, it will require the user to provide a directory up front. Your first task\nwill thus be to process the files of that directory (including subdirectories). You will then enter\na loop where the user provides queries that your program will (quickly) answer. The queries are\neffectively searches for words in the indexed files. Described in English, a query might be: “Tell\nme all the files that have the word ‘potato’ inside the directory /comp/15.”\n    While processing the files, you might find it useful to store information about those files such\nas their names, their relative paths on the filesystem, and information about their contents, in\none or more data structure(s) that is/are easily searched and queried. The choice of data\nstructure(s) for this assignment is up to you!\n\f    That said, we have provided you with modules to help with indexing files (see Building the Index\nsection below). Also, for this assignment, you may use certain classes from the C++ Standard Tem-\nplate Libary (STL). Descriptions of the STL implemetations that you are allowed to use are listed\nin their own section named STL Usage.\n    To help you learn the interface and get a feel for the program, we have also provided you with\na working reference implementation. For help on how to test your work agains the reference, see\nthe section\nTesting and Reference Implementation.\n\n\nFiles to Implement\nWe will not specify most of the files or functions you will need to write. Instead, your program\nis required to function as described in this specification. You may accomplish this task using any\ncombination of files, functions, and classes you wish. We will, of course, evaluate your design.\n    However, in addition to writing .h and .cpp files for your classes, you will need to write a\nmain() for your program, and write a Makefile. The default make action should be to compile\nand link the entire program, and to produce an executable program named gerp, which you can\nrun by typing ./gerp in the terminal. If you have a clean target in your Makefile, be sure you\ndo not delete the .o files we give to you.\n    You will want to write code to test the various parts of your program separately so that you\ndo not have to debug compound errors. To that end, you are encouraged to use the unit_test\nframework to unit test your classes; however, testing details will be up to you. As usual, you will\nalso be required to submit a README. See the README section for details.\n\n\nPair Programming\nFor this project, you will be working together with a partner! You will be responsible for choosing\nyour partner. It is essential that you and your partner have compatible working schedules, because\nyou are required to work together for all stages of the project. For more information on our pair\nprogramming guidelines, see our reference document.\n\n\nStarter Files\nTo copy the starter files, run the following command on the server\n/comp/15/files/proj_gerp/setup\n\nNote that you should not run cp except in the following situation.\n   Sometimes strange things happen with the provided object (.o) files. For example, students\nmay accidentally try to re-compile the files or add incorrect (and unnecessary) Makefile rules for\nthem. If you see something weird going on with any of the provided .o files, copy the original files\nback into your directory with:\ncp /comp/15/files/proj_gerp/*.o .\n\nThis is generally the first thing a TA would try.\nProgram Specification\n\nIntroduction\nYour program will be run from the command line like this:\n./gerp DirectoryToIndex OutputFile\n\nwhere DirectoryToIndex determines which directory will be traversed and indexed, e.g. /comp/15/files,\nand OutputFile names the file to which the query results will be sent.\n   If the user did not specify exactly two command line arguments (in addition to the program\nname), print this message to std::cerr:\nUsage: ./gerp inputDirectory outputFile\n\nand terminate the program by returning EXIT_FAILURE from main.\n     After being called, your program will first traverse a file tree created using a module provided\nby the course staff (details are in the section titled Building the Index below). It will index each\nfile that it finds in the tree. After indexing all of the files, it will enter a command loop (similar\nto the “interactive” modes that you have implemented in previous homeworks) where the user can\nenter various commands to modify the search, and to quit the program.\n\n\nCommand Loop\nSpecifically, your program will print Query? followed by a single space to std::cout (NOT to the\nOutputFile), and then wait for a command from the user. The possible query commands are:\n   • AnyString\n     A word (see the What is a Word? section below)is treated as a query. The program will take\n     this string and print all of the lines in the indexed files where AnyString appears. Note that\n     this is a case sensitive search, so we and We are treated as different strings/words, and so\n     should have different results.\n\n   • @i AnyString or @insensitive AnyString\n     Preceeding a query string by @i or @insensitive causes the program to perform a case\n     insensitive search on the string that was passed. For example, we and We would be treated as\n     the same string/word and will have the same results.\n\n   • @q or @quit\n     These commands will completely quit the program, and print:\n     Goodbye! Thank you and have a nice day.\n     This statement should be followed by a new line. Note that the program should also quit if\n     it reaches End-Of-File (EOF).\n\n                                                  5\n\f   • @f newOutputFilename\n     This command causes the program to close the current output file. Any future output should\n     be written to the file named\n     newOutputFilename.\n\nBeware!\nBeware! There are two output streams.\n   • The “Query? ” prompt always goes to std::cout\n\n   • The result of the query always goes to the output file, which will either be the OutputFile\n     or the file named in the last @f command.\nAlso, treat a multi-word query as several independent 1-word queries - e.g.\n         Query? We are the champions\nis the same as\n         Query? We\n         Query? are\n         Query? the\n         Query? champions\nNote, as seen when running the reference implementation, that this will actually appear as:\n         Query? we are the champions\n         Query? Query? Query? Query?\n\n\nOutput Formatting\nIf the word (see the What is a Word? section below) in a query is found in the index, then, for\neach line it appears in, you will print to the designated output file a line of the form:\nFileNameWithPath:LineNum: Line\n\nWhere:\n  1. FileNameWithPath is the full pathname of the file (including the path from the command\n     line), followed by a colon\n\n  2. LineNum is the line number within that file that the query word appears on, followed by a\n     colon and a space\n\n  3. Line is the full text of the line from the file\n\n  4. A newline\n   For example, if you ran\n$ ./gerp small_test out.txt\nQuery? we\n\nwhich queries we on our small_test directory, and then sends output to the file out.txt, the file\nout.txt might read:\nsmall_test/test.txt:5: we are the champions\nsmall_test/test.txt:6: we we we\n\n\n                                                  6\n\fNOTE: There is one newline after the last line. Also, each line that the query appears in only\nprints once. If the query is not found using the default search, then print:\nquery Not Found. Try with @insensitive or @i.\n\nIf the query is not found using the insensitive search, then print:\nquery Not Found.\n\n\n\nWhat is a Word?\nIt is important to outline what a word is when dealing with a word search engine. We will define\na word as a string that starts and ends with an alphanumeric (letter or number)\ncharacter. This means that you will need to do a little string parsing to determine the output of\nyour gerp implementation. To help you with this nuance we have included a couple of examples.\n     When searching for the word comp using case insensitive search, gerp should treat the following\nstrings as comp:\n\n   • comp\n\n   • comp.\n\n   • Comp\n\n   • -comp\n\n   • &&comp\n\n   • comp?!\n\n   • @#comp?@!\n\nIf any of the bulleted strings were submitted as a query, gerp should print the lines in files that\ncontain any of the strings on the list (however, it should print them as they exist in the file, not a\nprocessed version).\n    Note that gerp should only compare strings where all leading and trailing non-\nalphanumeric characters are stripped. This includes both the queries and the strings\nin the data files.\n    Note that words can contain non alphanumeric characters in the middle. For instance, comp&!$15\nis considered all one word. It should not be split into two queries as with spaces.\n\n\nBuilding the Index\nYou do NOT need to write the FSTree or DirNode classes described below\n- we have implemented them for you. However, they will be critical to the\nsuccess of your project!\n\fFSTree\nWe will use a file-system tree to represent directories, subdirectories, and files. The data structure\nwe will use is an n-ary tree, so called because a node of the tree could have any number of children.\nThe main usage of this class is to help you navigate through folders and directories inside the\ncomputer. For example, a snapshot of a home directory might be represented in an n-ary tree like\nthis:\n/h/mkorman\n       /coursework\n              /comp11\n              /comp15\n                     /exams\n                     /labs\n                     /assignments\n                     /hws\n              /comp160\n                     /hw\n       /public_html\n\nSpecifically, a FSTree is an n-ary tree which consists of DirNodes (which are described below). The\nFSTree class has the following public functions:\n\n   • FSTree(std::string rootName)\n     This is the constructor of the FSTree. It creates a file tree of DirNodes where the root of the\n     tree is the directory that is passed as the parameter rootName. If there is an error opening\n     directories or files, the constructor will fail and halt your program. Be careful and do not run\n     this on just any directory - if a directory structure has a loop in it, the constructor can run\n     forever!\n\n   • ∼FSTree()\n     The destructor deallocates all of the space allocated when the tree was built.\n\n   • DirNode *getRoot()\n     This function returns the root of the tree. Normally, we do not want to return the private\n     members of an object or class, however in this case it is necessary so that you can traverse\n     the tree and index its contents.\n\nDirNode\nThe DirNode class is the key building block of the FSTree class. It is our representation of a folder.\nEach DirNode instance has: a name, a list of files in the directory, and a list of subdirectories. It\ncontains the following public methods:\n\n   • bool hasSubDir()\n     Returns true if there are any sub-directories in this directory.\n\n   • bool hasFiles()\n     Returns true if there are files in this directory.\n\n   • bool isEmpty()\n     Returns true if there are no files or sub-directories in this directory.\n\f   • int numSubDir()\n     Returns the number of sub directories in this directory.\n\n   • int numFiles()\n     Returns the number of files in this directory.\n\n   • std::string getName()\n     Returns the name of this directory.\n\n   • DirNode *getSubDir(int n)\n     Returns a pointer to the nth subdirectory.\n\n   • std::string getFile(int n)\n     Returns the nth file name in this directory.\n\n   • DirNode *getParent()\n     Get the parent directory of this directory.\n\nThe DirNode class contains other public functions that are necessary for our implementation of\nFSTree. You should not have to use them. In order to get a file’s full path, you will need to\ntraverse the FSTree and concatenate the names of the directories you enounter along the way. You\nwill then use this full path to open the file in an std::ifstream and index its contents.\n\n\nSTL Usage\nFor this assignment, you will be allowed to use ONLY the following STL implementations:\n\n   • vector\n\n   • queue\n\n   • stack\n\n   • set\n\n   • list\n\n   • functional\n\nYou may also find certain function(s) in the cctype library useful. You are also allowed to use pair\nfrom utility. That being said, you could easily make your own struct. If you have questions\nabout using a particular library or class, clarify with a TA first. In general, if using something\nmakes all or part of the assignment trivial, we will likely say no (e.g. you can’t use unorderedmap).\n    You are not required to use any particular item of the STL. If you feel that one or more of\nthese would be useful, you will need to learn about their respective interfaces. You can find more\ninformation about them at:\n    http://www.cplusplus.com/reference\nAny other data structures that you need you must implement yourself. Moreover, you may not\nuse any kind of parallel programming or concurrency in your implementation.\n\fCompiler Options\nWhen compiling your implementation of gerp, you should compile with the flag -O2 (That’s a\ncaptial letter ‘O’, not the numeral zero). This will optimize your program for the system that it is\ncompiling on, which will result in an implementation with a faster runtime. This will help during\nthe testing phase because you will receive your results faster.\n",
    "CS 15 ArrayLists Homework\nIntroduction\nIn this assignment you will implement a version of the array list data structure discussed in class that\ncontains characters.\n    Recall that an array list is a kind of list: an ordered collection of data values. “Ordered” here does\nnot mean “sorted,” it just means that, if there are items in the list, there is a distinct first element,\nsecond element, etc. We will use 0-based indexing, i.e., the first element in an array list will be element\n0. Note that an array list cannot have “holes”: if you remove the fifth element (element 4) from a\n10-element array list, then there are 9 elements left, and their positions are 0 through 8.\n    You will write both the public and private sections of the CharArrayList class. The class def-\ninition will go in a file named CharArrayList.h; the class implementation will go in a file named\nCharArrayList.cpp. You will also write test code in unit_tests.h (described below). Your goal is\nto implement a well-tested array list that a client could pick up and use in their own program.\n    We will describe the (public) interface first, give some implementation specifics, and finally sub-\nmission instructions.\nProgram Specification\nImportant Notes\n\n    • The names of your functions/methods as well as the order and types of parameters and return\n      types must be exactly as specified. This is important because we will be compiling the class you\n      wrote with our own client code!\n    • Any exception messages should likewise print exactly as specified and use the given error type.\n    • You may not have any other public functions.\n    • All data members must be private.\n    • You may not use any C++ strings in your CharArrayList implementation except for:\n\n         ◦ In the toString() and toReverseString() functions.\n         ◦ When throwing exception messages.\n\n    • You may not use std::vector or any other built-in facility that would render the assignment\n      trivial.\nInterface\nYour class must have the following interface (all the following members are public):\n   • Define the following constructors for the CharArrayList class:\n        ◦ CharArrayList()\n          The default constructor takes no parameters and initializes an empty array list. This array\n          list has an initial capacity of 0.\n        ◦ CharArrayList(char c)\n          The second constructor takes in a single character as a parameter and creates a one element\n          array list consisting of that character. This array list should have an initial capacity of 1.\n        ◦ CharArrayList(char arr[], int size)\n          The third constructor takes an array of characters and the integer length of that array of\n          characters as parameters. It will create an array list containing the characters in the array.\n          This array list should have an initial capacity equal to the length of the array of characters\n          that was passed.\n        ◦ CharArrayList(const CharArrayList &other)\n          A copy constructor for the class that makes a deep copy of a given instance.\n     Recall that all constructors have no return type.\n   • ∼CharArrayList()\n     Define a destructor that destroys/deletes/recycles all heap-allocated data in the current array\n     list. It has no parameters and returns nothing.\n   • CharArrayList &operator=(const CharArrayList &other)\n     Define an assignment operator for the class that recycles the storage associated with the instance\n     on the left of the assignment and makes a deep copy of the instance on the right hand side into\n     the instance on the left hand side.\n    • bool isEmpty() const\n      An isEmpty function that takes no parameters and returns a boolean value that is true if this\n      specific instance of the class is empty (has no characters) and false otherwise.\n\n    • void clear()\n      A clear function that takes no parameters and has a void return type. It makes the instance\n      into an empty array list. For example if you call the clear function and then the isEmpty\n      function the isEmpty function should return true.\n\n    • int size() const\n      A size function that takes no parameters and returns an integer value that is the number of\n      characters in the array list. The size of an array list is 0 if and only if it isEmpty.\n\n    • char first() const\n      A first function that takes no parameters and returns the first character in the array list. If the\n      array list is empty it should throw an std::runtime_error exception with the message “cannot\n      get first of empty ArrayList”. Note that this exception message does not end with a newline.\n\n    • char last() const\n      A last function that takes no parameters and returns the last element (char) in the array list.\n      If the array list is empty it throws a std::runtime_error exception with the message “cannot\n      get last of empty ArrayList”. Note that this exception message does not end with a newline.\n\n    • char elementAt(int index) const\n      An elementAt function that takes an integer index and returns the element (char) in the array\n      list at that index. NOTE: Indices are 0-based. If the index is out of range it should throw a C++\n      std::range_error exception with the message “index (IDX) not in range [0..SIZE)” where IDX\n      is the index that was given and SIZE is the size of the array list. For example: “index (6) not in\n      range [0..3)” if the function were to be called using the index 6 in a size 3 array list. Note the\n      braces and the spacing, and also note that there is no newline!1\n\n    • std::string toString() const\n      A toString function that takes no parameters and has a std::string return type. It returns\n      a string which contains the characters of the CharArrayList. The string will be formatted like\n      this:\n                 [CharArrayList of size 5 <<Alice>>]\n\n      where, in this example, 5 is the size of the array list and the elements are the characters\n      ‘A’, ‘l’, ‘i’, ‘c’, ‘e’. The empty array list would be formatted like this:\n                 [CharArrayList of size 0 <<>>]\n\n      Note: There is no newline after the last ].\n      Caution: The format of strings is essential to get exactly right, because your output will be\n      verified automatically. There is no whitespace printed, except the single spaces shown between\n      the words inside the square brackets (i.e. “CharArrayList ‘space’ of ‘space’”, etc. ). The\n      capitalization must be exactly as shown.\n\n    • std::string toReverseString() const\n      A toReverseString function that takes no parameters and has a std::string return type. It\nreturns a string which contains the characters of the CharArrayList in reverse. The string will\n  be formatted like this:\n           [CharArrayList of size 5 <<ecilA>>]\n\n  where, in this example, 5 is the size of the array list and the elements are the characters\n  ‘A’, ‘l’, ‘i’, ‘c’, ‘e’. The empty array list would be formatted like this:\n           [CharArrayList of size 0 <<>>]\n\n  Note: There is no newline after the last ].\n\n• void pushAtBack(char c)\n  A pushAtBack function that takes an element (char) and has a void return type. It inserts the\n  given new element after the end of the existing elements of the array list.\n\n• void pushAtFront(char c)\n  A pushAtFront function that takes an element (char) and has a void return type. It inserts\n  the given new element in front of the existing elements of the array list.\n\n• void insertAt(char c, int index)\n  An insertAt function that takes an element (char) and an integer index as parameters and\n  has a void return type. It inserts the new element at the specified index and shifts the existing\n  elements as necessary. The new element is then in the index-th position. If the index is out of\n  range it should throw a C++ std::range_error exception with the message “index (IDX) not\n  in range [0..SIZE]” where IDX is the index that was given and SIZE is the size of the array list.\n  NOTE: It is allowed to insert at the index after the last element. Note that the braces in this\n  message are different from those in the elementAt range error.\n\n• void insertInOrder(char c)\n  An insertInOrder function that takes an element (char), inserts it into the array list in\n  ASCII order, and returns nothing. When this function is called, it may assume the array list is\n  correctly sorted in ascending order, and it should insert the element at the first correct index.\n  Example: Inserting ‘C’ into “ABDEF” should yield “ABCDEF” You can rely on the built-in\n  <, >, <=, >=, and == operators to compare two chars.\n\n• void popFromFront()\n  A popFromFront function that takes no parameters and has a void return type. It removes the\n  first element from the array list. If the list is empty it should throw a C++ std::runtime_error\n  exception with the message “cannot pop from empty ArrayList”.\n\n• void popFromBack()\n  A popFromBack function that takes no parameters and has a void return type. It removes the\n  last element from the array list. If the list is empty it should throw a C++ std::runtime_error\n  exception initialized with the string “cannot pop from empty ArrayList”.\n\n• void removeAt(int index)\n  A removeAt function that takes an integer index and has a void return type. It removes the\n  element at the specified index. If the index is out of range it should throw a std::range_error\n  exception with the message “index (IDX) not in range [0..SIZE)” where IDX is the index that\n  was given and SIZE is the size of the array list.\n\n   • void replaceAt(char c, int index)\n     A replaceAt function that takes an element (char) and an integer index as parameters and has\n     a void return type. It replaces the element at the specified index with the new element. If the\n     index is out of range it should throw a std::range_error exception with the message “index\n     (IDX) not in range [0..SIZE)” where IDX is the index that was given and SIZE is the size of the\n     array list.\n\n   • void concatenate(CharArrayList *other)\n     A concatenate function that takes a pointer to a second CharArrayList and has a void return\n     type. It adds a copy of the array list pointed to by the parameter value to the end of the array\n     list the function was called from. For example if we concatenate CharArrayListOne, which con-\n     tains “cat” with CharArrayListTwo, which contains “CHESHIRE”, CharArrayListOne should\n     contain “catCHESHIRE”. Note: An empty array list concatenated with a second array list is\n     the same as copying the second array list. Concatenating an array list with an empty array list\n     doesn’t change the array list. Also an array list can be concatenated with itself, e.g concatenating\n     CharArrayListTwo with itself, results in CharArrayListTwo containing “CHESHIRECHESHIRE”.\n\n    You may add any private methods and data members. We particularly encourage the use of private\nmember functions that help you produce a more modular solution.\n    Before you start writing any functions please sit down and read this assignment specification. Some\nof these functions do similar tasks. Perhaps it would be prudent to organize and plan your solution\nusing the principles of modularity, e.g., helper functions. This initial planning will be extremely\nhelpful down the road when it comes to testing and debugging; it also helps the course staff more\neasily understand your work (which can only help).\n    Also, the order in which we listed the public methods/functions of the CharArrayList class, is not\nthe easiest order to implement them in. If you plan your functions out and identify the easy ones it\nwill make your work easier and your final submission better.\n    If you are having issues planning out your assignment we encourage you to come in to office hours\nas early as possible.\n\n\nJFFEs (Just For Fun Exercises)\nIf you complete the above functions, you may add the following functions. There is no extra credit,\nbut they’re fun and educational.\n\n   • void sort()\n     A sort function that takes no input and has a void return type. It sorts the characters in the\n     list into alphabetical order.\n\n   • CharArrayList *slice(int left, int right)\n     A slice function that takes a left index and a right index and returns a pointer to a new,\n     heap-allocated CharArrayList. The new array list contains the characters starting at the left\n     index and up to, but not including, the right index. If the first index is equal to or greater than\n     the second, it returns a new, empty array list. The left index must be in the range [0..SIZE)\n     and the right index must be in the range [0..SIZE] where SIZE is the size of the array list. Since\n     the right index is not included in the final slice, requesting a slice where the right index is 1\n     index past the last element is still a valid request. If the either index passed is out of range the\n     function should throw a std::range_error with an appropriate message.\nImplementation Details\nCopy the starter files from /comp/15/files/hw_arraylists to get the exception examples and pro-\ngram files with header comments:\n   • CharArrayList.h\n   • CharArrayList.cpp\n   • unit_tests.h\n   • timer_main.cpp\n   • Makefile\n   • simple_exception.cpp\n    You will be editing the first three files listed—you should not edit timer_main.cpp, Makefile,\nand simple_exception.cpp.\nNote: The array list files just contain starter header comments; the testing file contains some examples\nto help you get started with testing. You will need to program everything else yourself.\n    You should fill out the header comments appropriately (with your name, a statement of purpose\nin your own words, etc.), and, of course, you will need to put the C++ code in!\n    Implement the array list using a dynamically allocated array as discussed in class. You should\nutilize a private expand or ensureCapacity function that increases/expands your capacity by a rea-\nsonable factor (and by enough to hold the required data!) each time your array list reaches its capacity.\n    The file CharArrayList.h will contain your class definition only. Put the implementation in\nCharArrayList.cpp. The file unit_tests.h will contain your unit tests. We will assess the work in\nall three files.\n    We may not cover exceptions in class. Don’t worry! You can look up how to throw exceptions,\nwhich is all that is required for this assignment. Be sure to read simple_exception.cpp, which came\nwith the starter code. That file has a few examples of how an exception can be thrown and shows how\nexceptions impact program execution. You should play around editing the file until you feel comfort-\nable with exceptions. For this assignment, your exceptions should include a string with a relevant error\nmessage (which we’ve specified above). You’ll use the std::runtime_error or std::range_error ex-\nception type, depending on the circumstance.\n    You will need to write unit tests to test your code. The advice section (below) has more about\nwhat kinds of things to include here; also, see the provided unit_tests.h for some examples.\ntimer main.cpp\nAs mentioned above, when you copy the starter files, you will receive a file named timer_main.cpp.\nThis file has been fully implemented for you. It contains a main() function, and when compiled and\nlinked to your completed CharArrayList class, an excutable will be created which runs a number of\nCharArrayList operations and prints out the times (in nanoseconds) taken to run those operations. All\nof these operations are run on a fresh CharArrayList instance containing 1,000,000 random characters.\nTake a look over this file—it’s okay if you don’t understand all of it, but you may find it interesting.\n    Once you have fully completed your CharArrayList implementation, you can compile this timer\nprogram by running “make timer” in terminal. This will run the compilation rules we have defined\nin the Makefile, and create a new executable which you can run using ./timer. Observe the table of\noperations and their time measurements that gets printed. Do these times match your expectations?\nWe will ask more questions about these times below, to be answered in your README.\n\nImplementation Advice\nDo NOT implement everything at once!\nDo NOT write code immediately!\n\nBefore writing code for any function, draw before and after pictures and write, in English, an algorithm\nfor the function. Only after you’ve tried this on several examples should you think about coding.\n    First, just define the class, #include the .h file in your unit_tests.h (we have already done\nthis for you), write a dummy test (that does nothing), and run the unit_test command from the\ncommand line.\n    This will test whether your class definition is syntactically correct.\n    Then implement just the default constructor. Add a single variable of type CharArrayList to a\nunit test function, and run your tests.\n    Then you have some choices. You could add the destructor next, but certainly you should add the\ntoString function soon.\n    You will add one function, then write code in your test file that performs one or more tests for\nthat function. Write a function, test a function, write a function, test function, .... This is called “unit\ntesting.” As you write your functions, consider edge cases that are tricky or that your implementation\nmight have trouble with. You should write specific tests for these cases.\n    Testing is an important part of programming. To give you some guidance on how to thoroughly\nunit test a function, we have already included some tests for the insertAt function in unit_tests.h.\nThe contents of these tests are currently commented out—you should uncomment them after you have\nimplemented insertAt (and the other functions used in those tests).\n    In the example tests we have given, you can see that we have considered many different cases that\nthe insertAt function may be used in: insertion into an empty list, insertion at the front and back of\na 1-element list, inserting a large number of elements, and inserting into the front, middle, and back\nof a larger list. We have even written tests that attempt to insert into and out-of-range index, then\ncheck that the correct exception was raised—you can see these for examples of how to test exceptions.\n    It is important to consider all cases a function can be used in when writing tests! This can help\nyou catch bugs that may not be obvious to the human eye. You should use the insertAt tests we\nhave provided as guidance for testing your other array list functions—we expect you to be similarly\nthorough. If you need help, the TAs will ask about your testing plan and ask to see what tests you\nhave written.\n    We will evaluate your testing strategy and code for breadth (did you test all the functions?) and\ndepth (did you identify all the normal and edge cases and test for error conditions?). Don’t write a\ntest for a function and then delete it!\n    In addition to testing, be sure your files have header comments, and that those header comments\ninclude your name, the assignment, the date, and the file’s purpose. See our style guide for more\ninformation about commenting your code.\n    Finally, you should review the grading process outlined on the course administration webpage.\nThis includes useful information like how to view your autograder score, the maximum number of\ntimes you can submit, and how many late tokens you can use.\n\n\nREADME\nWith your code files you will also submit a README file, which you will create yourself. The file is\nnamed README. There is no .text or any other suffix. The contents is in plain text, lines less than 80\ncolumns wide. Format your README however you like, but it should be well-organized and readable.\nInclude the following sections:\n\n (A) The title of the homework and the author’s name (you)\n\n (B) The purpose of the program\n\n (C) Acknowledgements for any help you received\n\n (D) The files that you provided and a short description of what each file is and its purpose\n\n (E) How to compile and run your program\n\n (F) An outline of the data structures and algorithms that you used. Given that this is a data\n     structures class, you need to always discuss the ADT that you used and the data structure\n     that you used to implement it and justify why you used it. Specifically for this assignment please\n     discuss the features of array lists, and major advantages and major disadvantages of utilizing an\n     array list as you have in this assignment. The algorithm overview is always relevant. Please\n     pick a couple interesting/complex algorithms to discuss in the README\n\n (G) Details and an explanation of how you tested the various parts of assignment and the program\n     as a whole. You may reference the testing files that you submitted to aid in your explanation.\n\n (H) Please let us know approximately how many hours you spent working on this project. This\n     should include both weeks one and two.\n\n  (I) Answer the following questions regarding the time measurements taken for the CharArrayList\n      operations (see the section titled timer main.cpp for instructions on taking these measure-\n      ments).\n\n        1. There are three categories of operations listed (insertion, removal, and access). Within each\n           category, list the times each operation took and rank the operations from fastest to slowest.\n        2. Discuss these rankings. Why were certain operations so much faster or slower than others?\n           Which operations took approximately the same amount of time? What are the features of\n           array lists that caused these disparities or similarities in times?\n\nEach of the sections should be clearly delineated and begin with a section heading describing the\ncontent of the section. It is not sufficient to just write “C” as a section header: write out the section\ntitle to help the reader of your file.\n\n\nSubmitting Your Work\nBe sure to read over the style guide before submitting to make sure you comply with all the style\nrequirements. You will need to submit the following files:\n      CharArrayList.h, CharArrayList.cpp\n      Makefile\n      unit_tests.h\n      README\n     You must submit them via your browser on Gradescope to the assignment hw_arraylists. Submit\nthese files directly, do not try to submit them in a folder. Note, you should only be submitting these\nfiles. If you feel that you need multiple classes or structs in your solution, please consolidate them into\nCharArrayList.h and CharArrayList.cpp.\n     Finally, remember that you only get 5 submissions for this (and most) assignments, so use\nyour submissions wisely. After submitting, you can wait a few minutes then check Gradescope to view\nyour autograder score.\n\n    Before submitting your work, please make sure your code and documentation (including sections\nof the README) conform to the course style guide.\n\f",
    "CS 15 LinkedLists Homework\n\nIntroduction\nIn this assignment you will implement a linked list data structure. The list for this assignment will\nbe a doubly linked character list. You will have to write both the public and private sections of the\nCharLinkedList class. The class definition will go in a file named CharLinkedList.h, and the class\nimplementation will go in a file named CharLinkedList.cpp. We’ll describe the interface first, then\ngive some implementation specifics, ask you some questions, and finally give submission instructions.\nDon’t forget to answer the questions in your README!\n\n\nProgram Specification\nImportant Notes\n\n    • The names of your functions/methods as well as the order and types of parameters and return\n      types must be exactly as specified. This is important because we will be compiling the class you\n      wrote with our own client code!\n\n    • Any exception messages should likewise print exactly as specified and use the given error type.\n\n    • You may not have any other public functions.\n\n    • All data members must be private.\n\n    • You may not use any C++ strings in your CharLinkedList implementation, except for\n\n         ◦ In the toString() and toReverseString() functions.\n         ◦ When throwing exception messages.\n\n    • You may not use std::vector, std::list, or any other built-in facility that would render the\n      assignment trivial.\n\n    • Some functions are required to be implemented with recursion. For these functions, you are\n      welcome to write private helper functions that do the recursion.\n\nInterface\nYour class must have the following interface (all the following members are public):\n\n   • Define the following constructors for the CharLinkedList class:\n        ◦ CharLinkedList()\n          The default constructor takes no parameters and initializes an empty list.\n        ◦ CharLinkedList(char c)\n          The second constructor takes in a single character as a parameter and creates a one element\n          list consisting of that character.\n        ◦ CharLinkedList(char arr[], int size)\n          The third constructor takes an array of characters and the integer length of that array of\n          characters as parameters. It will create a list containing the characters in the array.\n        ◦ CharLinkedList(const CharLinkedList &other)\n          A copy constructor for the class that makes a deep copy of a given instance.\n\n     Recall that all constructors have no return type.\n\n   • ∼CharLinkedList()\n     Define a destructor that destroys/deletes/recycles all heap-allocated data in the current list. It\n     has no parameters and returns nothing. This function must use a private recursive helper\n     function.\n\n    • CharLinkedList &operator=(const CharLinkedList &other)\n      Define an assignment operator for the class that recycles the storage associated with the instance\n      on the left of the assignment and makes a deep copy of the instance on the right hand side into\n      the instance on the left hand side.\n\n    • bool isEmpty() const\n      An isEmpty function that takes no parameters and returns a boolean value that is true if this\n      specific instance of the class is empty (has no characters) and false otherwise.\n\n    • void clear()\n      A clear function that takes no parameters and has a void return type. It makes the instance\n      into an empty list. For example if you call the clear function and then the isEmpty function\n      the isEmpty function should return true.\n\n    • int size() const\n      A size function that takes no parameters and returns an integer value that is the number of\n      characters in the list. The size of a list is 0 if and only if it isEmpty.\n\n    • char first() const\n      A first function that takes no parameters and returns the first element (char) in the list. If the\n      list is empty it should throw a C++ std::runtime_error exception with the message “cannot\n      get first of empty LinkedList”. Note that there is no newline at the end of this message.\n\n    • char last() const\n      A last function that takes no parameters and returns the last element (char) in the list. If the\n      list is empty it throws a\n      C++ std::runtime_error exception with the message “cannot get last of empty LinkedList”.\n\n    • char elementAt(int index) const\n      An elementAt function that takes an integer index and returns the element (char) in the list\n      at that index. NOTE: Indices are 0-based. If the index is out of range it should throw a\n      C++ std::range_error exception with the message “index (IDX) not in range [0..SIZE)” where\n      IDX is the index that was given and SIZE is the size of the linked list. For example: “index (6)\n      not in range [0..3)” if the function were to be called using the index 6 in a size 3 list. Note the\n      braces and the spacing!1 This function must use a private recursive helper function.\n\n    • std::string toString() const\n      A toString function that takes no parameters and has a std::string return type. It returns\n      a string which contains the characters of the CharLinkedList. The string will be formatted like\n      this:\n                 [CharLinkedList of size 5 <<Alice>>]\n\n      where, in this example, 5 is the size of the list and the elements are the characters\n      ‘A’, ‘l’, ‘i’, ‘c’, ‘e’. The empty list would print like this:\n                 [CharLinkedList of size 0 <<>>]\n\n      Note: There is no new line after the last ].\n      Caution! Your output will be verified automatically, so the format of strings is\n      essential to get right. There is no whitespace printed, except the single spaces\n1\n    [N1 ..N2 ) is interval notation for a “half open interval”. See Wikidpedia for more.\n\f                                                                                                   4\n\n\n  shown between the elements inside the square brackets. (i.e. “CharLinkedList\n  ‘space’ of ‘space’”, etc. ). The capitalization must also be exactly as shown.\n\n• std::string toReverseString() const\n  A toReverseString function that takes no parameters and has a std::string return type. It\n  returns a string which contains the characters of the CharLinkedList in reverse. The string will\n  be formatted like this:\n          [CharLinkedList of size 5 <<ecilA>>]\n\n  where, in this example, 5 is the size of the list and the elements are the characters\n  ‘A’, ‘l’, ‘i’, ‘c’, ‘e’. The empty list would print like this:\n          [CharLinkedList of size 0 <<>>]\n\n  Note: There is no new line after the last ]. For this function, you are not allowed to make a\n  copy of the list—the fact that it’s doubly linked should be a great help! Also, if you’re not using\n  a tail pointer, consider how a recursive helper function might be useful here (hint: this fn might\n  also come in handy elsewhere where recursive helper functions are required!)\n\n• void pushAtBack(char c)\n  A pushAtBack function that takes an element (char) and has a void return type. It inserts the\n  given new element after the end of the existing elements of the list.\n\n• void pushAtFront(char c)\n  A pushAtFront function that takes an element (char) and has a void return type. It inserts\n  the given new element in front of the existing elements of the list.\n\n• void insertAt(char c, int index)\n  An insertAt function that takes an element (char) and an integer index as parameters and has\n  a void return type. It inserts the new element at the specified index. The new element is then\n  in the index-th position. If the index is out of range it should throw a C++ std::range_error\n  exception with the message “index (IDX) not in range [0..SIZE]” where IDX is the index that\n  was given and SIZE is the size of the list. NOTE: It is allowed to insert at the index after the\n  last element. Also, the braces in this message are different from those in the elementAt range\n  error.\n\n• void insertInOrder(char c)\n  An insertInOrder function that takes an element (char), inserts it into the list in ASCII order,\n  and returns nothing. When this function is called, it may assume the list is correctly sorted in\n  ascending order, and it should insert the element at the first correct index. Example: Inserting\n  ‘C’ into “ABDEF” should yield “ABCDEF” You can rely on the built-in <, >, <=, >=, and\n  == operators to compare two chars.\n\n• void popFromFront()\n  A popFromFront function that takes no parameters and has a void return type. It removes\n  the first element from the list. If the list is empty it should throw a C++ std::runtime_error\n  exception with the message “cannot pop from empty LinkedList”.\n\n• void popFromBack()\n  A popFromBack function that takes no parameters and has a void return type. It removes\n  the last element from the list. If the list is empty it should throw a C++ std::runtime_error\n  exception initialized with the string “cannot pop from empty LinkedList”.\n\n   • void removeAt(int index)\n     A removeAt function that takes an integer index and has a void return type. It removes the ele-\n     ment at the specified index. If the index is out of range it should throw a C++ std::range_error\n     exception with the message “index (IDX) not in range [0..SIZE)” where IDX is the index that\n     was given and SIZE is the size of the list.\n\n   • void replaceAt(char c, int index)\n     A replaceAt function that takes an element (char) and an integer index as parameters and has\n     a void return type. It replaces the element at the specified index with the new element. If the\n     index is out of range it should throw a C++ std::range_error exception with the message\n     “index (IDX) not in range [0..SIZE)” where IDX is the index that was given and SIZE is the\n     size of the list. This function must use a private recursive helper function.\n\n   • void concatenate(CharLinkedList *other)\n     A concatenate function that takes a pointer to a second\n     CharLinkedList and has a void return type. It adds a copy of the list pointed to by the pa-\n     rameter value to the end of the list the function was called from. For example if we concatenate\n     CharLinkedListOne, which contains “cat” with CharLinkedListTwo, which contains\n     “CHESHIRE”, CharLinkedListOne should contain “catCHESHIRE”. Note: An empty list\n     concatenated with a second list is the same as copying the second list. Concatenating a\n     list with an empty list doesn’t change the list. Also a list can be concatenated with itself,\n     e.g concatenating CharLinkedListTwo with itself, results in CharLinkedListTwo containing\n     “CHESHIRECHESHIRE”.\n\n    You may add any private methods and data members. We particularly encourage the use of private\nmember functions that help you produce a more modular solution.\n    Before you start writing any functions please sit down and read this assignment specification. Some\nof these functions do similar tasks. Perhaps it would be prudent to organize and plan your solution\nusing the principles of modularity, e. g., helper functions. This initial planning will be extremely\nhelpful down the road when it comes to testing and debugging; it also helps the course staff more\neasily understand your work (which can only help).\n    Also, the order in which we listed the public methods/functions of the CharLinkedList class, is\nnot necessarily the easiest order to implement them in. If you plan your functions out and identify\nthe easy ones it will make your work easier and your final submission better.\n    If you are having issues planning out your assignment we encourage you to come in to office hours\nas early as possible.\n\n\nJFFEs (Just For Fun Exercises)\nIf you complete the above functions, you may add the following functions. There is no extra credit,\nbut they’re fun and educational.\n\n   • void sort()\n     A sort function that takes no input and has a void return type. It sorts the characters in the\n     list into alphabetical order.\n\n   • CharLinkedList *slice(int left, int right)\n     A slice function that takes a left index and a right index and returns a pointer to a new,\n     heap-allocated CharLinkedList. The new list contains the characters starting at the left index\n     and up to, but not including, the right index. If the first index is equal to or greater than the\nsecond, it returns a new, empty list. The left index must be in the range [0..SIZE) and the right\n      index must be in the range [0..SIZE] where SIZE is the size of the list. Since the right index is\n      not included in the final slice, requesting a slice where the right index is 1 index past the last\n      element is still a valid request. If the either index passed is out of range the function should\n      throw a C++ std::range_error with an appropriate message.\n\n\nImplementation Details\nCopy the starter files from /comp/15/files/hw_linkedlists to get the following files with header\ncomments:\n\n   • CharLinkedList.h\n\n   • CharLinkedList.cpp\n\n   • unit_tests.h\n\n   • timer_main.cpp\n\n   • Makefile\n\n    Implement the list using a doubly linked list. This means that each node has both a next and\na previous pointer.\n    The file CharLinkedList.h will contain your class definition only. The file CharLinkedList.cpp\nwill contain your implementation. The file\nunit_tests.h will contain your unit testing functions. We will assess the work in all three files.\n    Once again, we have provided you with a fully implemented timer_main.cpp and Makefile—you\nshould not edit these. As with HW1, once your have completed your CharLinkedList implemen-\ntation, run “make timer” to compile your timer executable program, and run ./timer to execute it\nand take time measurements.\n\n\nImplementation Advice\nDo NOT implement everything at once!\nDo NOT write code immediately!\n\nBefore writing code for any function, draw before and after pictures and write, in English, an algorithm\nfor the function. Only after you’ve tried this on several examples should you think about coding.\n    First, just define the class, #include the .h file in your unit_tests.h (we have already done\nthis for you), write a dummy test (that does nothing), and run the unit_test command from the\ncommand line.\n    This will test whether your class definition is syntactically correct.\n    Then implement just the default constructor. Add a single variable of type CharLinkedList to a\nunit test, and run your tests.\n    Then you have some choices. You could add the destructor next, but certainly you should add the\ntoString function soon.\n    You will add one function, then write code in your test file that performs one or more tests for\nthat function. Write a function, test a function, write a function, test function, ... This is called “unit\ntesting.” As you write your functions, consider edge cases that are tricky or that your implementation\nmight have trouble with. You should write specific tests for these cases.\n\f                                                                                                     7\n\n\n    If you need help, TAs will ask about your testing plan and ask to see what tests you have written.\nThey will likely ask you to comment out the most recent (failing) tests and ask you to demonstrate\nyour previous tests.\n    It is important to consider all cases a function can be used in when writing tests! This can help\nyou catch bugs that may not be obvious to the human eye. If you need help, the TAs will ask about\nyour testing plan and ask to see what tests you have written. As a hint for writing tests: Notice that\nthe interface for the CharLinkedList class is the same as the interface for the CharArrayList class\nyou implemented last assignment.\n    We will evaluate your testing strategy and code for breadth (did you test all the functions?) and\ndepth (did you identify all the normal and edge cases and test for error conditions?). Don’t write a\ntest a function and then delete it!\n    In addition to testing, be sure your files have header comments, and that those header comments\ninclude your name, the assignment, the date, and the file’s purpose. See our style guide for more\ninformation about commenting your code.\n    Finally, you should review the grading process outlined on the course administration webpage.\nThis includes useful information like how to view your autograder score, the maximum number of\ntimes you can submit, and how many late tokens you can use.\n\n\nREADME Outline\nWith your code files you will also submit a README file, which you will create yourself. The file is\nnamed README. There is no .text or any other suffix. The contents is in plain text, lines less than 80\ncolumns wide. Format your README however you like, but it should be well-organized and readable.\nInclude the following sections:\n\n (A) The title of the homework and the author’s name (you)\n\n (B) The purpose of the program\n\n (C) Acknowledgements for any help you received\n\n (D) The files that you provided and a short description of what each file is and its purpose\n\n (E) How to compile and run your program\n\n (F) An outline of the data structures and algorithms that you used. Given that this is a data\n     structures class, you need to always discuss the ADT that you used and the data structure\n     that you used to implement it and justify why you used it. Specifically for this assignment\n     please discuss the features of linked lists, major advantages and major disadvantages of utilizing\n     a linked list as you have in this assignment. The algorithm overview is always relevant. Please\n     pick a couple interesting/complex algorithms to discuss in the README\n\n (G) Details and an explanation of how you tested the various parts of assignment and the program\n     as a whole. You may reference the testing files that you submitted to aid in your explanation.\n\n (H) Please let us know approximately how many hours you spent working on this project. This\n     should include both weeks one and two.\n\n (I) Answer the following questions regarding the time measurements taken for the CharLinkedList\n     operations (see the explanation of timer main.cpp for instructions on taking these measure-\n     ments).\n\f                                                                                                       8\n\n\n        1. There are three categories of operations listed (insertion, removal, and access). Within each\n           category, list the times each operation took and rank the operations from fastest to slowest.\n        2. Discuss these rankings. Why were certain operations so much faster or slower than others?\n           What are the features of linked lists that cause these disparities?\n        3. Now compare these measurements with the measurements you took for HW1. Which op-\n           erations are faster when using array lists? Which are faster using linked lists? Why?\n\nEach of the sections should be clearly delineated and begin with a section heading describing the\ncontent of the section. It is not sufficient to just write “C” as a section header: write out the section\ntitle to help the reader of your file.\n\n\nQUESTIONS\nIn addition, answer the following questions in your README file:\n\n   • Q1: Which functions in the interface were easier to implement for linked lists compared to array\n     lists? Why?\n\n   • Q2: Which functions in the interface were harder to implement for linked lists compared to array\n     lists? Why?\n\n   • Q3: If a client had an existing program that uses CharArrayLists, what changes would they have\n     to make to their code to switch to CharLinkedLists?\n\n\nSubmitting Your Work\nBe sure to read over the style guide before submitting to make sure you comply with all the style\nrequirements. You will need to submit the following files:\n      CharLinkedList.h, CharLinkedList.cpp\n      unit_tests.h\n      Makefile\n      README\n    You must submit them using Gradescope to the assignment hw_linkedlists. Submit these files\ndirectly, do not try to submit them in a folder. Note, you should only be submitting these files.\nIf you feel that you need multiple classes or structs in your solution, please consolidate them into\nCharLinkedList.h and CharLinkedList.cpp.\n\n    Before submitting your work, please make sure your code and documentation (including sections\nof the README) conform to the course style guide.\n\f",
    "CS 15: Unit Testing,\nArrayLists Lab\n\nIntroduction\nWelcome to CS 15! The purpose of this lab is twofold:\n\n       • To familiarize you with the concept of unit testing and unit_test, a\n         unit testing framework which will help you easily test your code as\n         you write it.\n\n       • To write a simplified ArrayList class and test it with the unit_test\n         framework.\n\nNote: If you are unfamiliar with accessing a terminal, using ssh, etc., please\nread the System Setup guide on the course website now.\n\n\nUnit Testing\nTesting code is important! We are strict and serious about testing because\nit is an essential tool for a computing professional. Writing tests while you\nwrite your code will save you time by helping you catch bugs early — when\nthey are often easier to figure out and fix. The general rule is: as soon as\nyou write a function, write some basic tests for it.1\n\n\nWhat Makes a Good Test\nGood tests are small functions which test precise areas of your code. They\nhave easily understandable function names and often use helpful print state-\nments. Small test functions that test a single specific thing are useful because\nif something goes wrong you know where in the code to begin looking.\n    For example, if a test function named removeFromEmptyArray fails, you\nknow immediately that, when you call the remove function on an empty\narray, something goes wrong. You can comb through your remove function\nto find the bug.\n    Often, such tests need not do too much—a few lines of code is great.\nThe goal is to be clear on specifically what you’re trying to test.\n    At first glance, each of the functions you’ll write can be tested “at\nface value”—i.e., if you’re writing a function to insert elements into an\nArrayList, you’ll want to write a function that ensures that elements are\ninserted as you expect them to be. But that is just where testing begins!\n\nEdge Cases\nWhat happens, for instance, when you try to insert an element into an\nArrayList when the underlying Array is already at maximum capacity?\n    For many of the functions you will write in this class, there will be cases\nlike this one which are very important—while they don’t necessarily occur\nall the time, if they’re not handled properly, they will wreak havoc on your\nunderlying implementation.\n    In the ’biz, these kinds of cases are commonly called “edge cases” or\n“corner cases”. Indeed, edge cases are not just something you’ll face in\nthis class, but are very common in industry - and are painful for everyone.\nLearning to write code that is resilient to edge cases will make your work\nmore reliable, resilient, and robust, not only for yourself, but for the other\nprogrammers who will use/work with your code, and for the end users as\nwell!\n    Therefore, our autograders will be testing for such situations whenever\npossible. Common edge-cases situations include:\n\n   • Empty containers, especially removing from them\n\n   • Full containers, especially inserting into them\n\n   • Off-by-one errors when iterating through a collection\n\n   • Memory leaks/errors (and we’ll see more about these during the term)\n\n   • Searching for non-existent things\n\n   • Out of range accesses\n\f                                                                               3\n\n\n   • Invalid input (either accidental or malicious) from the user\n\n   But there are certainly many more...\n\nComing Up With Tests\nWhile you work on various functions for the assignments in this class, ques-\ntions or ideas might arise in your mind. One way to work is to jot these\ndown in comments (which you will remove later)—they can often become\nuseful tests.\n    For example, if you are unsure whether your for loop should have\ni < array_length or i <= array_length, write that down and make a\ntest for it! Trust your instincts: if you are not sure about some\ncode, write extra tests to prove it to yourself. And even if you are\nsure about some code, write some tests to prove it to yourself anyway! You’ll\nbe surprised how many bugs you catch this way. Writing a few extra tests\nearly on is relatively easy in terms of time, effort, and overall pain; debugging\noff-by-one errors when you’re segfaulting “for no reason”, on the other hand,\nis a nightmare.\n    Regarding edge-case testing, a good way to catch these is to imagine\nwhat might cause the program to segfault or throw an exception. In other\nwords, how would you crash your own program?\n    For this lab, you may not be able to test all of the cases mentioned above\nand that is fine. For now, focus on writing short test functions that target\nspecific aspects of your code.\n\nTesting Logistics\nTesting code is difficult! Not only is it challenging to come up with tests, but\nkeeping things organized so your testing process and development workflow\nis as smooth as possible presents its own challenge as well.\n    There are many strategies you might use to approach testing. Although\nwe are going to be using our unit_test framework for this lab, and encour-\nage you to use it for the future, here are some of the methods you might\nconsider on your own—along with some of their pros and cons.\n\n   1. You could have a single very long main function that interacts with\n      and tests your program. This is often difficult to read, particularly\n      when you have a lot of tests. However, it is relatively easy to compile\n      and run your work. That said, the output of the testing program is\n     very likely going to be difficult to read and managing all of your tests\n     as you run them together becomes a bit of a headache.\n\n  2. You could have one main function, which calls other individual test\n     functions. This is certainly better than the previous option, as you can\n     manage the complexity of a single main function more easily, and don’t\n     have to comment out large blocks of code. However, you’ll still need\n     to remember to run valgrind manually to check for memory leaks—a\n     common problem is that students forget to do this often, and then\n     miss critical bugs until they’re nearly ready to submit! And, again,\n     your testing output is likely going to be difficult to parse.\n\n  3. You could have many different testing main.cpp files (i.e. main00.cpp,\n     main01.cpp, etc.). This is nice in that each test is individual, and\n     isolated from all others (in fact, our autograder works this way!). Then\n     you’d use some kind of shell script to run them in sequence. This shell\n     script could also run valgrind on your tests automatically to check for\n     memory leaks / errors. Downsides of this approach are that jumping\n     between many testing files will be quite annoying, each test will need to\n     be compiled separately from the others, which takes time, and, again,\n     your testing output will be difficult to parse.\n\n  4. You can use our unit_test framework! This framework attempts to\n     ameliorate the various problems listed above, but will require you to\n     organize your work a little differently than how you’ve been used to.\n     Read on below for details!\n\n\nunit test\nWhat is unit test?\nunit_test is a unit testing framework that we’ve created to make your\ndevelopment workflow as smooth as possible. More precisely, it is a script\n(note: it is not only a C++ program) which will:\n\n  1. Create a testing driver program (which contains main()).\n\n  2. Run each of your tests individually (one failed test won’t stop the\n     others from running).\n\n  3. Run valgrind on your tests.\n\n\n      4. Output the results of your tests, including error messages, number of\n         passing/failing tests, etc..\n\n    In order to use the framework, your testing code will need to be organized\n    in a way that the framework can “understand.” This will take a bit of\n    getting used to (for instance, you won’t have a main() function when using\n    unit_test!), but will pay off in the long run. Specifically, in order to run\n    unit_test, you will have to:\n\n      1. Write your tests.\n\n      2. Edit your Makefile (we do this for you early on in the semester).\n\n      3. Run unit_test.\n\n    See below for details.\n\n    Organizing your tests\n    The way unit_test works, you are required to put your tests into a single\n    testing file named unit_tests.h. Each test is a function which must:\n\n       • have return type void\n\n       • take no arguments\n\n       • have a unique function name\n\n       For example, a valid test signature might be:\n1   void my_first_test()\n\n    unit_test will find and run each function that matches the above parame-\n    ters, and each test that finishes execution will be considered successful—see\n    the section “What makes a successful test” for details.\n     Note! The way that unit_test works is each test function will be run as\n     its own process. This way, one failed test will not stop the others from\n     running. The details of how this happens are beyond the scope of this\n     document, so, for now, just think of each test in your unit_tests.h file\n     as being its own main(). Indeed, the unit_test script has a file which\n     it builds for you which has main() in it, which is run one time for each\n     of your testing functions. Thus, your testing code cannot have a\n     main()! Again, thinking of each testing function as its own main is the\n     right way to approach the situation.\n\n    Editing the Makefile\n    In order to use unit_test, your Makefile must have a target named\n    unit_test which links your code with a file named unit_test_driver.o.\n    This driver file will be built for you by the framework; however, you must\n    compile your .cpp files into .o files. Early on in the semester, we will be\n    supplying you with a Makefile which has the appropriate targets; later on\n    you will be responsible for writing them yourself.\n\n    Running unit test\n    Great! You’re ready to go. Once you have your unit_tests.h file and\n    Makefile in place, you just need to run the command unit_test from\n    terminal. When you run this command, your code is compiled, the tests are\n    run, and the results are reported to you.\n\n    What makes a successful test?\n    Great question! A test is considered successful by unit_test if it fin-\n    ishes execution. Consider writing a test for a constructor of an ArrayList\n    class. Here’s a first draft:\n1   void test_constructor() {\n2       ArrayList my_list;\n3   }\n\n    While this may seem quite simple, this is actually a great first test of the\n    default constructor. If this test is successful, then you know that your code\n    does not crash when initializing an ArrayList with a default constructor,\n    and you’ll also be sure that your code doesn’t have a memory leak when\n    the list’s destructor is called as the list goes out of scope. This is a lot of\n    information for a one-line test! That said, what else might we do? Here’s\n    another test:\n1   void test_constructor() {\n2       ArrayList my_list;\n3       assert(my_list.size() == 0);\n4   }\n\n    Notice the use of the assert function. This function asserts that the boolean\n    expression inside is true. If it is true, the program continues; if it is false,\n    then the program crashes immediately. Recall that a test is considered\n    successful by the unit_test program if it finishes completion. Thus, the\n    assert function will be a very useful tool in your unit testing. (Note\n\f                                                                                 7\n\n\nthat to use this function, you’ll need to add #include <cassert> at the top\nof your testing file.)\n    Clearly, this second test is a bit more thorough—it ensures that the size\nof the list is both correctly set and reported. Technically, if it fails, you might\nhave a bug in either the constructor or the size function, but it certainly\nalerts you to an issue with relatively narrow scope.\n\nTest overlap\nGiven this style of testing, often it can be difficult to write tests that only\ntest one function. For instance, how can you test the pushAtBack function\nof the ArrayList class without also testing the toString function? In these\ncases, just do the best you can to make the tests as specific as possible. Some\noverlap is perfectly fine. The key idea here is that tests which are as precise\nas possible will help you debug problems before they get out of hand and\ncause you major headaches down the road.\n\nInitial setup to run unit test on the Halligan server\nThe unit_test program is located at comp/15/bin/unit_test. In order\nto run it, please perform the following steps:\n   • ssh to the homework server.\n   • run the command (include the quotes!):\n      echo \"use -q comp15\\n\" >> ∼/.cshrc\n\n\n   • Now, either log in again, or run the command:\n      source ∼/.cshrc\n\n\nThe use -q comp15 command will now be run automatically every time you\nlog in to the homework server. Among other things, this puts /comp/15/bin\ninto your PATH, which means you can run the unit_test command without\nspecifying a directory.\n\n\nThe Lab\nGetting Started\nYou should have a cs15 folder. cd into it, make a lab1 directory (mkdir lab1),\nand run the following command:\n\f                                                                            8\n\n\ncp /comp/15/files/lab_arraylists/* .\n\nThis will copy the starter code for the lab. To help you with the lab, we\nhave provided you with all of the necessary files to make unit_test work:\n   • A testing file named unit_tests.h.\n   • The beginnings of an ArrayList class.\n   • A Makefile which is used by unit_test.\n        ◦ We won’t discuss the Makefile in detail for this lab—that dis-\n          cussion is for another day. You should know, however, that you\n          do not need to run make with unit_test. unit_test runs\n          make for you! So, just run unit_test.\n\nIntroduction\nStart by familiarizing yourself with the ArrayList.h file. You will see a very\nsimple interface for an ArrayList class with a few functions defined for you.\nNotice also that the data type that the ArrayList holds is an integer.\n    Next, open the ArrayList.cpp file. Inside you will find an incomplete\nimplementation. The functions have been left blank intentionally, except for\nthe toString() function, which is only partially implemented. It is your\ntask to complete and test these functions using the given unit_tests.h file.\n    Now, open the unit_tests.h file. Here you will find a few tests imple-\nmented for you. However, the ArrayList.cpp code is not implemented, so\nat least one of the tests will fail at first!\n\nTo-Do Items\nYour tasks are:\n  1. Add any necessary elements to ArrayList.h (see the TODO in the\n     private section there).\n  2. Implement each of the unimplemented functions in ArrayList.cpp\n  3. After you write each function in ArrayList.cpp, think of and write\n     at least one test function for it in unit_tests.h.\n  4. Whenever you’re ready to run a test, just run the command unit_test\n     in your terminal. Your code will be compiled, tests will run, and the\n     output will show you the results.\n\f                                                                         9\n\n\n  5. Fill in the missing sections of the README provided for you.\n\n\nTips\n   • Recall that an ArrayList is a data structure which dynamically resizes\n     itself as elements are inserted/removed. Notice that in ArrayList.h,\n     we have not given you the data member that is required to *hint*\n     point to the actual data members of the list—you must add this your-\n     self. Refer to lecture if you need help with this.\n\n   • For this lab, we will have an ArrayList which does not shrink—it\n     only expands. This should make your life easier. Remember that the\n     ArrayList expands when the size is equal to the capacity - in that\n     case, you must:\n\n        ◦ Allocate a new array of the current capacity * 2 + 2.\n        ◦ Copy each element of the old array to the new array.\n        ◦ Free the memory of the old array (using delete []).\n        ◦ Don’t forget to update the capacity variable, and to update any\n          other private member variables!\n\n   • The toString function provided has some starter code which uses\n     std::stringstream. Don’t be afraid of std::stringstreams! You\n     can use it just as you would std::cout, but then calling .str() on\n     a std::stringstream object produces a std::string. How cool!\n     Again, all of the setup code is there for you, so you can just use the\n     provided ss (short for ‘stringstream’) variable as you would normally\n     use std::cout.\n\n   • Just because you wrote a lot of tests doesn’t mean they’re good! Be\n     careful about thinking that passing your own tests will pass the auto-\n     grader for homeworks. Think hard about good tests to run!\n\n\nPart 4: Submitting Your Lab\nYou will need to submit the following files:\n      ArrayList.h\n      ArrayList.cpp\n      Makefile\n      unit_tests.h\n      README\n   You must submit them using Gradescope to the assignment lab_arraylists.\nSubmit these files directly, do not try to submit them in a folder.\n   Reference the style guide for what should be included in your README,\nbut keep in mind that lab README’s can be brief.\n\n\nA Note on Lab Grading\nLabs are for hands-on practice in a supervised setting so you can develop\nyour skill. They are designed to be low-pressure and fun. Come to lab, do\nyour best, submit your work at the end of the period (your best effort given\nthe time), and you will get a high score. If for some reason you miss your lab\nsession, you can go to another one (provided there is space, see the course\nsyllabus). If you cannot attend any session for a whole week, do it in your\nown time so you will gain the skills. See the syllabus for course policies on\nlabs.\n\f",
    "CS 15 AVL Trees Lab\n\nIntroduction\nIn this lab, we will be working with AVL trees. As we saw in lecture, AVL\ntrees are just a kind of binary search tree (BST), but, in addition to the\nBST invariants, they have an additional invariant: the tree must be AVL-\nbalanced at every node; that is, the heights of the left and right subtrees of\nevery node differ by at most 1. This property ensures the height of the tree\nis at most 2 log n (where n is the number of nodes in the tree) and, thus,\nboth the worst and average time complexity of insert, search, and delete are\nO(log n).\n    The key task of an AVL tree implementation is to maintain the balance\nafter each modification of a tree.\n\n\nGetting Started\nTo start,\n\n   • Create a directory for this lab and move into it.\n\n   • Copy the lab starter files over from the usual place.\n\n   • Remember: write a little, compile, link, test, repeat.\n\n   • Use the provided Makefile (do not modify it).\n\n   Compile the code provided (type make in the console) and execute it\n(with ./avl_trees). You will see that the result is a BST containing the\nnumbers inserted, but it is not balanced to AVL standards. Your task is to\nmake sure that the resulting tree is balanced.\n\n\n\n\n                                      1\n\f                                                                                 2\n\n\n     Inserting into an AVL Tree\n     The function Node *insert(Node *node, int value) from the file\n     AVLTree.cpp is in charge of insertion. The code is given below and has\n     been implemented for you. You will notice it is quite similar to a simple\n     BST insertion but with some additional lines after the insertion to make\n     sure it remains balanced. You do not need to make any changes in this\n     function.\n 1   Node *AVLTree::insert(Node *node, int value)\n 2   {\n 3          /* node is an empty position, a child of a leaf node: insert here!\n                 */\n 4          if (node == nullptr) {\n 5                  return newNode(value);\n 6          }\n 7          /* if value already exists in the AVL Tree, do not insert */\n 8          else if (value == node->data) {\n 9              return node;\n10          }\n11          /* traverse to and insert value somewhere in node’s left subtree */\n12          else if (value < node->data) {\n13                  node->left = insert(node->left, value);\n14          }\n15          /* traverse to and insert value somewhere in node’s right subtree */\n16          else if (value > node->data) {\n17                  node->right = insert(node->right, value);\n18          }\n19\n20          /* AVL Tree rebalancing starts */\n21          node->height = 1 + max(nodeHeight(node->left),\n22                                nodeHeight(node->right));\n23\n24          Node *newNode = balance(node);\n25          /* AVL Tree rebalancing ends */\n26\n27          return newNode;\n28   }\n\n     Your task for this lab is to implement the following functions:\n 1   Node *AVLTree::balance (Node *node)\n 2   Node *AVLTree::rightRotate(Node *node)\n 3   Node *AVLTree::leftRotate (Node *node)\n\n     Functions rightRotate and leftRotate implement the right and left rota-\n     tions we saw in lecture: given a pointer to a node of the tree, they perform\n     a left or right rotation, update the heights of all nodes accordingly, and re-\n\f                                                                            3\n\n\nturn a pointer to the new root of the subtree. Function balance is similar.\nYou are given a pointer to a subtree that may have just become unbalanced\nafter an insertion. The first task of this function is to check if the tree is\nindeed unbalanced. If so, make sure that you do whatever rotations are\nneeded to make sure it is balanced (those rotations are handled by invoking\nrightRotate and leftRotate). Once finished, you return the new root of\nthe tree.\n    Make sure to update pointers of the nodes in these operations correctly.\nAs usual with handling pointers, you must also check for possible null point-\ners to prevent segmentation faults.\n    Once you are done, look into main.cpp. You will see that the driver\nonly inserts 5 nodes into the tree. Go ahead and change it so that you can\ninsert 17, 2, or even other numbers. Make sure that your tree is balanced\nno matter what you insert (other than repeated numbers!).\n\n\nSubmitting Your Work\nYou will need to submit the following files:\n    main.cpp\n    AVLTree.cpp\n    AVLTree.h\n    pretty_print.cpp\n    README\n    Makefile\n   You must submit them using Gradescope to the assignment lab_avl_trees.\nSubmit these files directly, do not try to submit them in a folder.\n\f",
    "CS 15: Circular deBuggers\nLab\n\n                           ,\n             _,-’\\    /|   .     .    /‘.\n         _,-’      \\_/_|_ |\\     |‘. /    ‘._,--===--.__\n        ^        _/\"/ \" \\ : \\__|_ /.      ,’    :. :. .‘-._\n               // ^    /7 t’\"\"     \"‘-._/ ,’\\    :     : : .‘.\n               Y       L/ )\\          ]],’    \\ :      : :  : ‘.\n               |         / ‘.n_n_n,’,’\\_       \\ ;     ; ;  ; _>\n               |__     ,’      | \\‘-’      ‘-.__\\_______.==---’\n              // ‘\"\"\\\\         |   \\             \\\n              \\|      |/       /    \\              \\\n                             /      |               ‘.\n                            /       |                  ^\n                           ^        |\n          From: https://www.asciiart.eu/animals/insects/ants\n\n\nIntroduction\nThis week, we will be working on debugging code by introducing a new\ndata structure: a circular buffer! We will also be reviewing stacks and\nqueues.\n\n\nKey Data Structures\nIn this lab, we will be fixing a buggy implementation of a circular buffer, and\nyou’ll see how to use a circular buffer to implement higher-level abstractions\nlike stacks and queues.\n\n\n\n\n                                      1\n\f                                                                              2\n\n\nStacks\nStacks are a Last-In/First-Out (LIFO) data structure. Imagine a stack of\nbooks. The book at the top of the stack would be the book that was most\nrecently added to the stack. Note that if we tried to take a book directly\nout of any part of this stack besides the top, it would fall over! The only\nbook that we can pull from the stack without creating an avalanche is the\none at the top. We can add to the top and remove from the top.\n\nQueues\nQueues are a First-In/First-Out (FIFO) data structure. This time, imagine\na line at the grocery store. The first person who entered the line will be the\nfirst person to leave. Again, note that if the cashier tried to take the second\nperson in line before the first, the other customers wouldn’t be happy. So,\nlike stacks, we can only directly access elements at the front of a queue. We\nadd elements at the back and remove from the front.\n\nImplementing stacks and queues\nHow should we implement these data structures? As we can see, both stacks\nand queues are essentially just lists with certain restrictions. This is a great\nhint that we should use either an ArrayList or LinkedList. But which one\nwould be better? Can both be used without taking any major hits to run-\ntime? Consider the computational complexity of adding/removing from the\nfront or back of a list when you think about this question!\n\nCircular Buffers\nA buffer is a place to store data temporarily. Circular Buffers combine the\nbest traits of LinkedLists and ArrayLists into one structure. Through some\ncareful maintenance of indexing variables, circular buffers offer O(1) inser-\ntion and deletion to the front and back of the list, as well as O(1) access to\nany element.\n\nLike ArrayLists, circular buffers store data in standard C++ arrays located\non the heap. They also have member variables that track the number of\nitems inserted into the array and capacity of the array. Where things get\nfunky, though, is with the front and back member variables. These will be\nintegers that track the index of the first element in the array and the index\nof the last element + 1 respectively.\n\f                                                                              3\n\n\nFor example, consider a buffer with capacity 6 that has already had 4 char-\nacters inserted into it:\n\n                           a    b   c   d\n                           ↑                ↑\n                           f                b\n\nHere, we get that f = 0, and b = 3 + 1 = 4.\n\nOkay! What if we remove ‘a’ ?\n\n                                b   c   d\n                                ↑           ↑\n                                f           b\n\nBoom! All we had to do was increment f from f = 0 to f = 1! What if we\nremove ‘b’ ?\n\n\n                                    c   d\n                                    ↑       ↑\n                                    f       b\n\nNow, f = 2, b = 4.\n\nIs this too easy? What if we want to add ‘e’ to the back?\n\n\n                                    c   d   e\n                                    ↑           ↑\n                                    f           b\n\nWe put ‘e’ in the first available slot, given by b, and then incremented b.\n\nWhat if we want to add ‘f’ to the back?\n\n\n                                    c   d   e   f\n                                    ↑           ↑\n                                    f           b\n\f                                                                         4\n\n\nProblem! What is b now? It can’t point past the end of the array. Let’s\nthink circular buffers! How about we point b to the front?\n\nAlso think about how you would go about moving b from the last element\nin the list to being the front—can any of the 5 operations (+, -, x, ÷, %)\nhelp you?\n\n\n                                  c   d   e   f\n                          ↑       ↑\n                          b       f\nNow, what happens when we insert ‘g’ at array[back], then update back?\n\n\n                          g       c   d   e   f\n                              ↑   ↑\n                              b   f\n\nLet’s remove the element at array[front] (‘c’), then update front.\n\n\n                          g           d   e   f\n                              ↑       ↑\n                              b       f\nNotice that we still need to expand the array if we need to store more\nelements than we have capacity. Otherwise, you’ll risk adding elements and\nhaving them overwrite existing data. Expansion is similar to ArrayLists,\nexcept now we need to be mindful of our front and back member variables.\nTalk about how you might go about expanding a circular buffer with the\nperson sitting next to you!\n\n\nThe Lab\nNow that you have a better understanding of how circular buffers work,\nwe’re going to have you debug our implementation of a circular buffer!\n\n\nGetting Started\nGet the lab files in the usual way—the lab is called lab_debug_circular_buffers.\n(It is important that you master the Unix commands!)\n\f                                                                          5\n\n\nTo-Do Items\nYour tasks are:\n  1. Find and fix the bugs in our implementation:\n\n      (a) Start with the compilation errors, then run our code to debug\n          the runtime errors\n      (b) main.cpp calls and tests each of the circular buffer functions. If\n          you need hints on what could be creating issues, that’s a great\n          first place to look!\n\n  2. Implement each of the unimplemented functions in Stack.cpp\n\n  3. Implement each of the unimplemented functions in Queue.cpp\n\n\nRunning Our Code\nTo compile our code, use the command make pokedex. To execute, run\n./pokedex in terminal. Happy debugging!\n\n\nDebugging Tips and Tricks\nThere are a few steps that we want you to follow when debugging. These\nwill help you to diagnose, then fix whatever is broken in your code. Use the\nfollowing strategies to fix our buggy implementation of the circular buffer!\n\n  1. Add print statements to narrow down the location of the bug to one\n     specific line or function.\n\n  2. Perform thorough tests. Note that assert() statements that fail will\n     lead to a big Valgrind dump—to avoid these, comment out assert\n     statements and replace them with print statements that check the\n     same thing.\n\n  3. Run Valgrind. See our guide to fixing Valgrind errors (also accessible\n     from the course website).\n\n  4. Read the spec, provided documentation, and style guide. Sometimes\n     the answer you want is easily accessible!\n\f                                                                         6\n\n\n  5. Check Piazza, Stack Overflow, and other online resources. These\n     should not be used to write programs/functions in their en-\n     tirety, but for help with specific compilation errors, details on C++\n     libraries, etc.\n\n\nSubmitting\nYou will need to submit the following files:\n    CircularBuffer.cpp\n    CircularBuffer.h\n    ElementType.h\n    main.cpp\n    Makefile\n    Queue.cpp\n    Queue.h\n    Stack.cpp\n    Stack.h\nYou must submit them using Gradescope to the assignment\nlab debug circular buffers. Submit these files directly, do not try to\nsubmit them in a folder.\n                                    _ _\n                                    | )/ )\n                               \\\\   |//,’ __\n                                 (\")(_)-\"()))=-\n                                    (\\\\\n\n          From: https://www.asciiart.eu/animals/insects/ants\n\f",
    "CS15 Dijkstra’s Algorithm\nLab\n\nIntroduction\nToday for lab we are going to run Dijkstra’s Algorithm on two different\ngraphs. Dijkstra’s Algorithm is useful when we want to find the shortest\nand most cost-effective path between two vertices. Instead of implementing\nDijkstra’s algorithm using C++, today we will use pen and paper (or tablet\nand stylus) to report the results of running the algorithm. Please fill out\nthe table provided as shown in lecture, starting from vertex A. Remember:\ninitially, the “Known” column should be false for all vertices, and the “Dist”\ncolumn should be 0 for the starting vertex, and infinity for all others. Once\nyou have completed filling out the tables, please submit your work by doing\nthe following:\n\n\n   • Copy table.txt into your lab 12 folder by running:\n     cp /comp/15/files/lab_dijkstras_algorithm/* .\n\n   • Fill out table.txt and then you will need to submit the following\n     files:\n                                table.txt\n\n     You must submit them using Gradescope to the assignment lab_dijkstras_algorithm.\n     Submit these files directly, do not try to submit them in a folder.\n\n\n\n\n                                      1\n\fV   Known   Prev   Dist   v=   v=   v=   v=   v=   v=   v=\n\n\nA\n\n\nB\n\n\nC\n\n\nD\n\n\nE\n\n\nF\n\n\nG\n\n\n\n\n                                    2\n\fV   Known   Prev   Dist   v=   v=   v=   v=   v=   v=   v=\n\n\nA\n\n\nB\n\n\nC\n\n\nD\n\n\nE\n\n\nF\n\n\nG\n\n\n\n\n                                    3\n\f",
    "                                  Lab 11: Dijkstra’s Algorithm\n                                               COMP 15\n\n\n1       Introduction\n   Today for lab we are going to run Dijkstra’s Algorithm on two different graphs. Dijkstra’s Algorithm\nis useful when we want to find the shortest and most cost-effective path between two vertices. Instead of\nimplementing Dijkstra’s algorithm using C++, today we will use pen and paper (or tablet and stylus) to\nreport the results of running the algorithm. Please fill out the table provided as shown in lecture, once\nyou have completed filling out the tables, please submit your work using the usual provide command.\n\n\n\n\n    V    Known    Prev     Dist    v=A       v=B        v=D      v=C       v=F       v=E       v=G\n\n    A      FT\n           S      0         0\n\n    B      FT\n           S      A         5        5\n\n    C      FT\n           S      B         7                   7\n\n    D      FT\n           S      B         6                   6\n\n    E      FT\n           S      D         9                             9\n\n    F      FT\n           S      C         8                                       8\n\n    G      FT\n           S      FE\n                  S         11                                               12        11\n\n\n\n\n                                                    1\n\fV   Known   Prev   Dist   v=A   v=C      v=B   v=D   v=E   v=F   v=G\n\n\nA    FT\n     S      0       0\n\n\nB    FT\n     S      AC\n            @       3      5     3\n\n\nC    FT\n     S      A       2      2\n\n\nD    FT\n     S      C       6            6\n\n\nE    FT\n     S      CB\n            @       7            9        7\n\n\nF    FT\n     S      DE\n            @       10                          14    10\n\n\nG    FT\n     S      D       12                          12\n\n\n\n\n                                     2\n\f",
    "CS 15 DFS and BFS in\nGraphs Lab\n\nIntroduction\nToday’s lab will focus on graph traversal algorithms. The question of\ngraph traversal is - given a starting vertex s and a destination vertex d,\ncan you report a valid path from s to d? Today you will implement two\nstrategies for graph traversal\n\n  1. breadth-first search (BFS)\n\n  2. depth-first search (DFS)\n\n   Your implementations will function with a Graph class that we have\nwritten for you. This class stores vertices in a 1-dimensional array and\nedges in a 2-dimensional array. It also has useful helper functions.\n\nBFS Review\nBreadth-first search explores a graph in waves. That is, starting at a\ngiven vertex s, BFS finds every vertex reachable in one step from s, then\nevery vertex reachable in two steps from s, and so on until all vertices in\nthe graph have been visited. Recall that BFS always find a shortest path\nfrom s to d in an unweighted graph (today’s graphs will be unweighted).\nThere can be several shortest paths, but we’ll only have to find one in this\nlab.\n\nDFS Review\nDepth-first search does a ‘deep dive’ on one path of the graph until it\nhas no more unexplored vertices, and then ‘bubbles up’ until it finds a new\n\n\n                                     1\n\f                                                                            2\n\n\npath to explore. Consider the tree traversal algorithms, preorder, inorder,\nand postorder traversals. Each of these three is an implementation of DFS\nin a tree.\n\n\nBFS Implementation Details\nNote: there are many valid ways of implementing this strategy. We’ve picked\none for this lab. Please stick with the approach given in the starter code. If\nyou want to explore others on your own later, that’s great!\n\nExample\nConsider this example graph:\n\n\n\n\nTo solve a problem that involves getting from any vertex from, say, Ariana\nGrande, in a BFS style, we’ll ask:\n\n   • Which vertices can I reach from Ariana Grande in one step?\n\n   • Which vertices can I reach from Ariana Grande in two steps?\n\n   • Which vertices can I reach from Ariana Grande in three steps?\n\nWe start at our source vertex Ariana Grande. We visit all of its neighbors\n(that is, nodes that we can be reached in one step from Ariana Grande).\nThen we visit all of its neighbors’ neighbors (i.e., nodes that we can reach\n\f                                                                            3\n\n\nin two steps), and so on. Eventually we will have explored all the nodes and\nfailed or we will have reached the desired destination. In the latter case, we\nhave found a path!\n\nMarking vertices\nWe want to explore each vertex only once; this ensures we find the shortest\npossible path from source Ariana Grande to destination Jessie J. In the\nexample above, we can get to vertex Jessie J directly from Ariana Grande\n(a one-step path). We could also get to Jessie J by going through Calvin Harris,\nbut there would be no point\nAriana Grande - Calvin Harris - Katy Perry - Kanye West - Jay-Z\n- Nicki Minaj - Jessie J\n\nis a longer path than Ariana Grande - Jessie J - so we don’t bother\ndealing with Jessie J once we’ve seen it the first time. In order to prevent\nrevisiting vertices, we will mark visited nodes. Initially, all vertices are\nunmarked. Whenever we explore a new vertex, we mark it so that we do\nnot explore it a second time.\n\nAuxiliary Data Structures\nWe’ll use a Queue as an auxiliary data structure for BFS, plus an array to\ntrack the path from source to destination.\n   • The Queue will contain the nodes to be explored, as we saw in class. s\n     is the first node to be enqueued. We dequeue a vertex from this queue\n     when we explore it.\n   • The predecessor array helps us track the path from any vertex back\n     to source. At any given moment, there is a “current” vertex whose\n     neighbors we are exploring. For each of the neighbors, we denote that\n     its predecessor is the current vertex. We use -1 to indicate that we do\n     not know the predecessor of a vertex (or that there is no path between\n     source and that node).\n\n\nBFS Implementation Example\nGetting Started\nStart by setting all vertices (except the source) as unmarked. Then initialize\nthe predecessor array so that no vertex has a (known) predecssor - i.e., all\n\f                                                                           4\n\n\nvalues are set to -1. Finally, enqueue the source vertex (say, Jay-Z from the\ngraph above) in the Queue.\n\nCore of the Algorithm\nThe main part of the algorithm is as we say in class: while the Queue is not\nempty, take the first element off it, and explore it.\n\nCleaning up up\nThe BFS algorithm can end in two ways:\n\n  1. We can explore all possible paths without finding the destination, in\n     which case, there is no path. You can’t get there from here.\n\n  2. At some point in the exploration, we have found (and marked) the\n     target destination. That means that we have a path from the target\n     to the source and we need to reconstruct it. For that we need to look\n     at the predecessor array. We will walk backwards from the destination\n     to the source.\n\n\nDFS Implementation Details\nDFS is very similar, but uses a Stack rather than a Queue. You can imple-\nment this in one of two ways:\n\n  1. Use recursion! The function call stack will work as an implicit Stack.\n\n  2. Use a Stack object.\n\n\nYour Job!\nFor the lab, we simply ask that you implement the BFS and DFS functions in\nPathFinder.cpp. That’s it! You’re highly encouraged to check out the Graph\nclass - particularly Graph.h - this will reveal the API you can use to mark\nvertices as visited, etc. The lab code is in /comp/15/files/lab_graph_traversals.\n    You will need to submit the following files:\n    PathFinder.cpp\n    PathFinder.h\n    City.cpp\n    City.h\n\f                                                                        5\n\n\n    Graph.cpp\n    Graph.h\n    Makefile\n   You must submit them using Gradescope to the assignment lab_graph_traversals.\nSubmit these files directly, do not try to submit them in a folder.\n\nNote\nYou may have noticed that we don’t need the marking array. We can just\nthe Queue for the nodes, and we can deduce that a node is marked by the\npresence of a predecessor (except for the source). We encourage you to use\nthe structures we set up, however, to keep the code simpler.\n\f",
    "CS15: Hash Tables\n\n                                    ,+*^^*+___+++_\n                              ,*^^^^               )\n                           _+*                       ^**+_\n                        +^        _ _++*+_+++_,           )\n         _+^^*+_      (      ,+*^ ^           \\+_          )\n         {         ) (      ,(    ,_+--+--,       ^)         ^\\\n       { (@)      } f    ,( ,+-^ __*_*_ ^^\\_       ^\\          )\n      {:;-/      (_+*-+^^^^^+*+*<_ _++_)_       )     )        /\n     ( / (       (          ,___     ^*+_+* )   <     <         \\\n      U _/       )     *--< ) ^\\-----++__)      )     )          )\n       (        ) _(^)^^)) ) )\\^^^^^))^*+/          /          /\n     (        / (_))_^)) ) ) ))^^^^^))^^^)__/            +^^\n   (       ,/     (^))^)) ) ) ))^^^^^^^))^^)             _)\n     *+__+*          (_))^) ) ) ))^^^^^^))^^^^^)____*^\n     \\                \\_)^)_)) ))^^^^^^^^^^))^^^^)\n      (_                ^\\__^^^^^^^^^^^^))^^^^^^^)\n         ^\\___               ^\\__^^^^^^))^^^^^^^^)\\\\\n               ^^^^^\\uuu/^^\\uuu/^^^^\\^\\^\\^\\^\\^\\^\\^\\\n                  ___) >____) >___      ^\\_\\_\\_\\_\\_\\_\\)\n                 ^^^//\\\\_^^//\\\\_^          ^(\\_\\_\\_\\)\n                    ^^^ ^^ ^^^ ^^\n\n------------------------------------------------\nFrom: https://asciiart.website/index.php?art=holiday/thanksgiving\n\n\n\n\nIntroduction\nHash tables are often a very fast way to store and retrieve data. The basic\nidea of hashing is to use an array of buckets — places to put information —\nand insert values based on an integer value computed from a key values. The\n\n\n                                       1\n\f                                                                                   2\n\n\n    key to efficient hashing (pun!) is a good function to tell you which bucket\n    to use for a given key. For this lab, we will explore a bad and a good hash\n    function, and we’ll also implement two strategies to handle when a bucket\n    is already in use (collision).\n\n\n    Review\n    Collisions\n    Recall that the input value to a hash function is a key to hash, and the\n    output of the hash function (after compression) is an index of your array.\n    What happens when something is already present at that index? This is\n    known as a collision. We will explore two methods of collision resolution\n    in this lab — linear probing and chaining.\n\n    Linear Probing\n    For linear probing, you simply search for the next open index. So, if your\n    hash function outputs the index 3, and something is occupying 3, then you\n    search at index 4, then 5, and so on. Make sure to wrap around if you go\n    over the end of the table! In other words:\n1   indexForKey(x) = (hashFunction(x) + attempt) % table_size\n\n    where we start with attempt 0, and keep going until we find an empty slot.\n\n    Chaining\n    Handle collisions by storing a linked list in each slot of the array. If there is\n    a collision, simply add the element to the back of the linked list at that slot.\n\n\n    The Lab\n    Introduction\n    Hector Hash and his friends are hosting a Thanksgiving dinner. Hector\n    wants to remember the delicious dishes served at the feast by storing them in\n    a hash table. He wants to be able to quickly retrieve information associated\n    with each dish for future gatherings. In particular, he wants to associate\n    each dish name with its serving size and preparation time in minutes (so\n    they know how much time to set aside next year). While discussing hash\n\f                                                                              3\n\n\n     functions with his friends, Hector and the group come up with two hash\n     function ideas:\n\n          1. Use the length of the dish name as the hash value.\n          2. Use the C++ std::hash facility.\n\n     The friends also disagree on which way of handling collisions is best. They\n     consider probing and chaining as options. Hector has started writing two\n     classes that implements both ideas for the hash function, as well as both\n     collision resolution techniques, but he needs your help to finish the job!\n\n     Representing Dishes\n     For the table, Hector is using C++ strings to represent the dish name (the\n     keys), and the following struct (defined in DishInfo.h) to represent the\n     values:\n 1   struct DishInfo {\n 2          int servingSize;\n 3          int prepTime;\n 4\n 5            /* Constructors for struct */\n 6            DishInfo()\n 7            {\n 8                   servingSize = prepTime = -1;\n 9            }\n10\n11            DishInfo(int servings, int minutes)\n12            {\n13                   servingSize = servings;\n14                   prepTime = minutes;\n15            }\n16   };\n\n\n\n     Hash Table Classes\n     Hector is writing two hash table classes, TurkeyChainingTable and\n     TurkeyLinearTable, which maintain a hash table that handles collisions\n     with chaining and linear probing, respectively.\n\n     Implementation Details\n     You’ll notice a few details in the TurkeyChainingTable and TurkeyLinearTable\n     classes. For instance,\n\f                                                                               4\n\n\n1   typedef std::string KeyType;\n2   typedef DishInfo ValueType;\n\n    These type definitions allow us to abstract the hash table classes over the\n    details of the key and value type. In the implementation, the only code that\n    depends on knowing the types is the print function, which could be removed\n    after debugging. Then we could make this a template! Similarly, defined in\n    HashFunction.h\n1   enum HashFunction { BAD_HASH_FUNCTION, GOOD_HASH_FUNCTION };\n\n    This allows us to use variables of type HashFunction, whose values are either\n    GOOD_HASH_FUNCTION or BAD_HASH_FUNCTION. This is simply a convenience\n    to make our code more readable.\n\n    TurkeyChainingTable\n    Hector is using chainedTable, a std::vector, to implement chaining:\n1      std::vector<std::list<ChainNode>> chainedTable;\n\n    Each index of the of the vector holds a std::list of ChainNodes. Declar-\n    ing a TurkeyChainingTable instance will create, resize, and initialize chainedTable\n    to empty lists.\n\n     Index    Chain (std::list of ChainNodes)\n       0      []\n       1      []\n       2      []\n       3      []\n       4      []\n    After a few calls to insertChaining, chainedTable might look something\n    like this:\n\n     Index    Chain (std::list of ChainNodes)\n       0      “Dish A”: {5, 128}\n       1      []\n       2      []\n       3      “Dish B”: {30, 117} → “Dish C”: {21, 126}\n       4      []\n\f                                                                              5\n\n\n    TurkeyLinearTable\n    Hector is using linearTable, a std::vector, to implement linear probing:\n1      std::vector<TableEntry> linearTable;\n\n    Each index of the of the vector holds a TableEntry. Declaring a TurkeyLinearTable\n    instance will create, resize, and initialize linearTable to empty TableEntrys.\n\n     Index      0       1        2        3       4\n     Bucket     Empty   Empty    Empty    Empty   Empty\n    After a few calls to insertProbing, linearTable might look something like\n    this:\n\n     Index      0             1               2            3               4\n     Bucket     Empty         \"Dish A\":       \"Dish C\":    Empty           \"Dish B\":\n                              {5, 128}        {30, 117}                    {21, 126}\n\n    Functions to Write\n    Your job will be to write the functions described below (along with any\n    helper functions you’d like to write). The functions you will write for this\n    lab are:\n1      TurkeyLinearTable::insertProbing(KeyType key, ValueType value,\n2      HashFunction hashFunction);\n\n    Adds a dish and its information to the hash table using using either the\n    GOOD_HASH_FUNCTION or the BAD_HASH_FUNCTION. This function handles\n    collisions by using the linear probing method.\n1      TurkeyChainingTable::insertChaining(KeyType key, ValueType value,\n2      HashFunction hashFunction);\n\n    Adds a dish and its information to the hash table using either the\n    GOOD_HASH_FUNCTION or the BAD_HASH_FUNCTION. This function handles\n    collisions by using the chaining method.\n    Finally:\n1      TurkeyLinearTable::expand();\n2      TurkeyChainingTable::expand();\n\n    Expand both tables to accommodate more values. You should expand when\n    the load factor, which is the number or items in the table divided by the\n    table capacity, exceeds something like 0.7.\n\f                                                                       6\n\n\nOther Notes\nMake a directory for this lab and get the files from the usual place. You\ncan use the make command to compile and link the files. The executable\ngenerated is named turkey.\n   You will need to submit the following files:\n    main.cpp\n    TurkeyChainingTable.cpp\n    TurkeyChainingTable.h\n    TurkeyLinearTable.cpp\n    TurkeyLinearTable.h\n    Makefile\n    README\n   You must submit them using Gradescope to the assignment lab_hash_tables.\nSubmit these files directly, do not try to submit them in a folder.\n   Well done!\n\f",
    "CS 15: Heaps\n\nIntroduction\nIn this lab, you will implement some functions of a Heap class. The Heap for\nour lab will be a min heap of strings that is implemented with an array. The\nprovided main driver will use these functions in order to sort the elements in\nan array of strings using an instance of the Heap. Once the array is sorted,\na secret message will be printed out!\n\n\nStarter Code\nHeap Class\nMuch of the Heap has been implemented for you already. The header file is\ncomplete- check there for some useful comments! In the heap.cpp file, you\nwill find that the constructors, insert (which you won’t use in this lab), and\nsize functions are all already implemented. An ensureCapacity function,\nused by insert, is also written for you. Also, helper functions to access the\nright/left children or parent indices of a given index are implemented for\nyou.\n\nDriver\nThe driver, in main.cpp, is written for you. It builds a heap, sorts the\nelements with repeated calls to removeMin(), and prints the results. Note\nthat we will discuss a better way to do this sorting algorithm in class — to\ndo it “properly” requires private access to the heap and destroys the data\nstructure, but is more space efficient. However, the idea behind the lab is\nfor you to write various functions of the Heap.\n\n\n\n\n                                      1\n\f                                                                             2\n\n\nCode to Write\nYou will be responsible for implementing the following functions:\n\n   • Heap::∼Heap()\n     Heap destructor.\n\n   • std::string Heap::min()\n     Returns the minimum element in the heap.\n\n   • void Heap::downHeap(int location)\n     This function repeatedly swaps a node with its smallest child until the\n     heap property is restored. Remember: all children are bigger than\n     their parent.\n\n   • std::string Heap::removeMin()\n     This function is exactly as discussed in class: the root value will be\n     returned, the heap size shrinks by one, and the value in the rightmost\n     node of the last level of the tree is copied to the root. Then, down\n     heaping begins from the root to reestablish the heap invariants.\n\n   • void Heap::buildHeap()\n     This function will start halfway through the list (array) and repeatedly\n     call downHeap on the first half of the list. It is used by the non-default\n     constructor, which takes in a list of strings and builds a heap from the\n     list.\n\n   • (optional) void Heap::upHeap(int location)\n     Fixes heap invariant by ‘bubbling up’ from the current index.\n\n\nGetting Started\nFirst, make a directory for this lab, change into that directory, and copy the\nlab files from the usual place. Next, look in the Makefile. You’ll see the\nname of the executable program it builds.\n\n\nSubmitting\nYou will need to submit the following files:\n    main.cpp\n    heap.cpp\n\f                                                                   3\n\n\n   heap.h\n   Makefile\n   You must submit them using Gradescope to the assignment lab_heaps.\nSubmit these files directly, do not try to submit them in a folder.\n\f",
    "                                                                                       CS 15\n                                Introductory Lab                                  Spring 2025\n\nThe purpose of this assignment is to introduce you to the basics of writing, running, and\nsubmitting programs in this class. You can work on this assignment from the lab computers\nin the Joyce Cummings Center—in fact, you may do this for all assignments this semester,\nbut we recommend taking this opportunity to learn how to work remotely, so that you can\ncomfortably work from your own computer.\n\nImportant: Do not copy and paste the commands we give you.\nType them by hand. This goes for the whole semester!\nIf you copy and paste, you won’t actually learn the commands, and\nthat will cost you lots of time later. Learn them now. Learn them by\ntyping, observing, and thinking.\nCopy and paste is evil!\nAnd as always, don’t be afraid to ask questions.\n\nYou can work remotely by accessing the CS department’s Linux computers—we call these\ncomputers servers because they remotely provide a service to us, the clients.\nWe will learn the basic ideas and skills of using a Linux system. Linux is an operating system,\njust like macOS or Windows. We commonly operate a Linux system using the text-based\nterminal mode. But first, we must log in to the CS department’s server.\n\n\n0.1    Remotely Logging In\nWe will access the department servers by using ssh, a popular protocol for remotely operating\ncomputers. To use ssh, you’ll first need to open a terminal:\n\n   • On Mac/Linux: Open your native terminal program. On Mac, that’s done using\n     Applications -> Utilities -> Terminal in Finder, or by pressing the command and\n     space bar on your keyboard at the same time and then typing in terminal.\n   • On Windows: You’ll need to download the program MobaXterm from http://\n     mobaxterm.mobatek.net/. Once installed, open it up. You may want to go to\n     Settings/Configuration -> terminal tab, and uncheck “Backspace sends ˆH”.\n\nWhen you get a terminal, type\n\nssh username @homework.cs.tufts.edu\n\nwhere “username” is your CS department username. You will be prompted for your password.\nOnce logged in, you will now be operating on the department server!\nYou are operating on the department server using the command line, a text-based way of\nnavigating a computer. In reality, you are just running another computer program called the\nLinux shell.\n\nTo confirm you successfully logged in, try typing hostname into the command line and hitting\nenter. You should get back the name of the department machine you are operating on, which\nwill look something like vm-hwXX, where XX is replaced by numbers. NOTE: if you see a\nname that looks different from this, you are probably not logged in correctly—it could just\nbe the name of your own computer! Re-follow the above steps until you see a hostname that\nlooks like the above.\nMake sure you are able to log in following these instructions. You will need to do this a lot\nthis semester! If you have any questions or concerns about remotely logging in, ask them\nnow.\n\n\n0.2    Using the Command Line\nYou have successfully accessed the department server! Now, let’s try running some com-\nmands.\n\n  ⇒ Type in the following commands one at a time and see what they do:\n    hostname\n    who\n    date\n    cal\n    cal 2020\n    cal 1 2020\n    cal 1 20\n\n  ⇒ Use the cal command to find out what day of the week you were born.\n\nThe things you just typed are called commands. These are names of programs. Nowadays,\npeople refer to programs by the term “apps.” We shall refer to them as commands, programs,\nor tools.\n\n   • command — the name of a program, like cal\n\n   • arguments — The extra information you give to a command to specify what it should\n     do. For example, the number 2020 tells the cal program to print the calendar for\n     the year 2020. If you do not specify arguments, the command will perform its default\n     action.\n\nThe Manual All commands are explained in the online help system, called the manual.\nTo learn about the cal tool, for example, use the man tool:\n\n  ⇒ man cal\n\nThis will display the help page for the cal tool. These help pages can be terse but have all\ninformation about the command. You can exit out of a manual by typing q.\nThese days, this information is also available on the internet. You can search there. The\nsystem man information, however, is the definitive source of information for your system.\n\n\n0.3    Files and Directories\nFor this class, all programs you write will be stored in folders in your account on the server.\nWe will now look at the basic commands for managing files and folders.\nIn Linux, a folder is called a directory. When using the command line, you are always located\nin a single directory within your computer’s file system. The directory you are located in is\ncalled your working directory. When you first log in, you are placed in your home directory.\n\n  ⇒ Type “pwd” and hit enter (this stands for “print working directory”). This will show\n    you the name of the directory you are currently located in—your working directory!\n    It should look like /h/USERNAME, where USERNAME is replaced by your CS login name.\n    This directory is also your home directory, and it is the personal space where you will\n    start every time you log in.\n  ⇒ Type “ls”. This will list all the folders and files in the directory that you are in. If you\n    have never logged in to the department servers before, you probably don’t see anything\n    when you type ls.\n  ⇒ Let’s make a new directory. Type “mkdir folder1” and hit enter. This will—you\n    guessed it—make a new directory called folder1. Now try typing “ls”. You should\n    see the new directory.\n  ⇒ Let’s move into our new folder. Type “cd folder1”. The cd command changes into\n    the directory that you give it. Type “pwd”. Your working directory should now be\n    /h/USERNAME/folder1. Changing directories is analogous to double clicking on a folder\n    on your Mac or Windows computer.\n  ⇒ Now type “cd ..” and hit enter. The .. moves you up a directory. Now when you\n    type pwd you should be back in your home directory.\n  ⇒ Type “mv folder1 folder2” and hit enter. Now type ls; you should see folder2. The\n    mv command moves the first file/directory that you give it to the second file/directory.\n    In this case, we have just renamed folder1 to folder2.\n  ⇒ Now let’s delete the directory we made. Type rm -r folder2. The rm command\n    removes a directory or file. The -r, which is known as a “flag”, tells rm that we are\n    removing a directory. Type ls; the directory should now be gone. WARNING: The\n    rm command permanently removes a file. There is no temporary trash bin! Use it\n    carefully.\nImportant:\nYou will be navigating the command line all semester long, so it is important to\nknow these commands. You can use this as a reference:\n\npwd stands for print working directory, and it will always tell you where you are.\n\ncd dirname will take you to the directory named dirname (if it exists and is\naccessible to you).\n\ncd .. takes you one directory level up, e.g., if you are in /h/milod/folder1/ it\nwill take you to /h/milod/.\n\ncd, when called with no arguments, will take you to your home directory, so you\ncan use it if you get lost.\n\ncd ~ will also take you to your home directory, because ~ is a shorthand for ”my\nhome directory.”\n\nls will list all the files and folders in your current directory.\n\nmv name1 name2 moves the file/directory called name1 to name2.\n\nrm [-r] name will permanently remove the file/directory called name. When\nname is a directory, the -r flag is required.\n\n\n0.4    Compiling and Running Programs\nNow that you know your way around the command line, you are ready to compile and run\nyour first program. We will provide you with this first program.\nMake sure you are in your home directory (type cd). Make a directory here called “cs15”\n(mkdir cs15), and cd into it (cd cs15). You should put all of your work for this course\ninside this directory. Now, make a directory called “lab0” and cd into it. Use pwd to make\nsure you are in the right place—you should be in /h/USERNAME/cs15/lab0.\n\nNow, copy the first program we have provided for you by typing\ncp /comp/15/files/lab intro/welcome.cpp . and hitting enter. Note that you must also\ntype the dot at the end ! The cp command copies files and we have given it the path to the\nprogram file that we want to copy, as well as the dot symbol ., which tells cp to copy the file\nto the current working directory. You can use ls to make sure you have successfully copied\nthe file.\nThe filename ends with .cpp, indicating that it is a C++ program. In a moment, we’ll learn\nhow to view and edit this program. For now, let’s just compile and run it. Compile the\nprogram by typing the following command:\nclang++ -Wall -Wextra welcome.cpp\n\nThis will compile your source code and generate an executable program called a.out. You\nshould be able to see a.out when you type ls.\n\nRun your program by typing “./a.out” and hitting enter. It should print a message wel-\ncoming you to CS 15. Did it work? If so, celebrate. If not, try to figure out what happened.\nWe’ll help!\n\n\n0.5    Writing Programs with VS Code\nThere are many popular editors for writing/editing programs: emacs, vim, Sublime, VS\nCode.... If you already have an editor that you’re comfortable with, then you’re good to go!\nMake sure that you can use your editor to remotely access the files on the CS department’s\nservers.\nWe recommend using Visual Studio Code in CS15. You will download and install VS Code\non your personal computer, and use it to remotely write and edit programs that are on the\ndepartment servers in Halligan Hall.\nYou can find instructions for setting up VS Code on our course website: https://www.cs.\ntufts.edu/comp/15/reference/system_setup/vscode_setup.pdf\nThese instructions also detail how to install the SFTP extension for VS Code and use it to\nremotely sync with your cs15 folder.\nOnce you have setup VS Code and SFTP, you should see all of your directories from the CS\nserver listed on the left hand side of VS Code (at a minimum, you should see your cs15 folder\ncontaining welcome.cpp). If you do not, try to re-follow the VS Code setup instructions. If\nyou’re still having trouble, ask us for help. It’s crucial that you are properly synced!\nNow, from VS Code, open and edit the welcome.cpp program. Change the comment at\nthe top of the file so that it includes your name. Then, below the line where the welcome\nmessage is printed, add a second line that prints the text “NAME’s first program.”, replacing\n“NAME” with your name, of course. Save your changes.\nNow, switch back to terminal. You will always use VS Code to write/edit programs, then\nactually run those programs from the command line. Make sure you are still logged into the\ndepartment servers—you can do this by typing hostname and checking that you get the same\noutput as before. Use ls to make sure you are in the same directory as your welcome.cpp\nprogram. If not, navigate to it. If you are, recompile the program:\nclang++ -Wall -Wextra welcome.cpp\nEvery time you edit a program, you have to recompile it before running it again. Finally,\nrun the program by typing “./a.out” and hitting enter. You should see an output that looks\nas follows:\nWelome to CS 15!\nNAME’s first program.\n\nDoes the new text with your name appear in the output? If so, congratulations! You have\ncompleted your first program. If not, see if you can figure out what went wrong. If you\nare getting an error message, try to figure out what it is telling you. If you are still having\ntrouble, ask us for help.\n\n\n0.6    Submitting your work\nIn CS 15, all labs and HW assignments will be turned in on Gradescope, via your browser.\nWhenever you submit, do not submit a folder. Just submit the files inside the folder you\nwish to submit. Make sure that your local versions of your files match what is on Halligan.\nPay close attention to the submission section of each assignment to know which files you will\nneed to submit.\nYou will need to submit the following files:\n        welcome . cpp\n\nYou must submit them using Gradescope to the assignment lab intro. Submit these files\ndirectly, do not try to submit them in a folder.\nCongratulations, you’re a C++ programmer now!\n\n\n\n\n                                                                                             6\n\f",
    "CS 15: make and diff Lab\n\nPart I: make\nIntroduction\nProfessor Evil is hijacking a class and wants your help to fail all the students!\nThat way, their class will look much better in comparison. They are so\nenthusiastic that they have done all the coding already. You only need to\nmake a Makefile for the evil plan to succeed!\n\n\nReview: Phases of Program Translation\nYou learned in CS 11 that C++ programs cannot run in their text form. You\nneed to translate the C++ source code, written in plain text, into the binary\nrepresentation of the particular computer’s instructions.\n    This translation takes place in a series of stages. Once you start to\nwrite programs that have multiple modules (components/classes, stored in\ndifferent files in C++) you must be aware of two phases: compilation and\nlinking.\n\nCompilation\nCompilation translates a single source module/file into a binary form, called\na relocatable object code file. These are stored in .o (object) files. Object\nfiles contain:\n\nexports\nexports are things that other modules can use. This might be a function\nlike CharLinkedList::first.\n\nimports\nimports are things that are used by a module, but not defined in that mod-\nule’s .o, and must be supplied by some other module. If your module calls\nthe exit function, for instance, then it would need to import a definition\nfor it.\n    Compilation always happens on a single file. If you type\nclang++ -Wall -Wextra file1.cpp file2.cpp\n\nclang++ will compile each file separately into a .o file and then proceed to\nthe next step (linking). In this case, it stores the .o files in a temporary\ndirectory somewhere else, but just know they are created.\n    You can tell clang++ to stop after the compilation phase by using the\n-c command line argument:\nclang++ -c -Wall -Wextra file1.cpp file2.cpp\n\n\n\nLinking\nLinking combines a collection of object code (.o) files and the system li-\nbraries (which define things like the << operator and various pre-defined\nfunctions like exit and sqrt) to form an executable binary program. In\norder to do this:\n\n   • All the imports of all the .o files have to be supplied a definition either\n     from one of the .o files or from the system libraries.\n\n   • There must be exactly one main function.\n\n   • There cannot be more than one definition for any function (with the\n     same number and type of parameters).\n\nCompilation Errors and Linking Errors\nWhy does this matter? Because you will get error messages, and if you\ndon’t understand what translation phase they come from, you can waste\nmany hours of your time looking for the solution in the wrong place!\nYou probably already have done this!\n\nCompilation Errors\nCompilation errors include:\n\n   • syntax errors\n\n   • missing .h files (actually that happens before compilation, but good\n     enough for now)\n\n   • type errors (e. g., you’re calling a function with certain parameters,\n     but they are not the types listed in the function header)\n\n   • undefined variables\n\n   • “control reaches end of non-void function”\n\n   • (and many more!)\n\n   .h files in CS 15 usually do not contain the function definitions, only the\nheaders. This is enough for compilation to proceed, because it can check\nthe types and then just list the function as an import in the .o file.\n\nLinking Errors\nThere are far fewer linking errors:\n\n   • Undefined reference to a function means that a function is used some-\n     where (imported), but no .o file defines it. Either you’ve left off the\n     relevant object code file or you omitted the function from the .o file\n     it belongs in, or the definition differs from the promised type that the\n     other files were compiled against.\n\n   • A special case of the above: missing main. You need a main function\n     in any program. One common reason for this error is that you were\n     trying to compile your code, but neglected to include the -c parameter\n     to clang++. If you were trying to link your code, you may have omitted\n     the .o file containing main (or you defined a different main function\n     with non-standard parameters).\n\n   • Multiple definitions of the same function. One reason students some-\n     times run into this is that they #included a .cpp file, which has the\n     effect of pasting all that code into every file that includes it and thus\n     putting the definitions in every corresponding .o file. Therefore, if you\n     have multiple functions named the same thing, the linker can’t decide\n     which definition to use.\n\f                                                                          4\n\n\nSeparate Compilation and Linking\nIn our Makefiles, we explicitly separate these two phases. A make target\nfor a program should do compilation or linking, but not both in one step.\nThis allows us to, for example, provide different command line arguments\nfor the compilation and linking steps. As you write larger programs, this\nwill become necessary. It also allows us to take advantage of more sophisti-\ncated make techniques (that you don’t have to know for today): default and\npattern rules.\n\nExample\nThe following commands:\nclang++ -Wall -Wextra -c main.cpp\nclang++ -Wall -Wextra -c ArrayList.cpp\nclang++ -g3 -o testArrayList main.o ArrayList.o\n\ncan be separated in the Makefile as follows:\nCXX = clang++\nCXXFLAGS = -Wall -Wextra\nLDFLAGS = -g3\n\ntestArrayList: main.o ArrayList.o\n    ${CXX} ${LDFLAGS} -o testArrayList main.o ArrayList.o\n\nmain.o: main.cpp ArrayList.h\n    ${CXX} ${CXXFLAGS} -c main.cpp\n\nArrayList.o: ArrayList.cpp ArrayList.h\n    ${CXX} ${CXXFLAGS} -c ArrayList.cpp\n\nSee the provided Makefile for details on the specifics.\n\n\nAssignment\nYour assignment is to make a Makefile that can compile and link the evil\nprogram given in the starter code. Copy the files from /comp/15/files/lab_make/\nto a lab3 folder in your CS15 directory. The program driver code is in\nevil.cpp. If you take a quick look at the code you will see that it uses\nan object of class Roster, whose interface is in Roster.h and whose im-\nplementation is in Roster.cpp. The class contains a simple ArrayList of\nStudents (a struct defined in Student.h). Thus, in terms of dependencies,\n\nevil depends on Roster which itself depends on Student. How would this\nlook in the Makefile?\n    We provided a Makefile that does not work but has lots of documen-\ntation. In fact, it contains a whole tutorial on Makefiles! Working with it,\nfollow these steps:\n\n  1. Based on your review of this document and the Makefile, fill in the\n     blanks. When properly set, you should be able to build the evil pro-\n     gram using the make command in your terminal. Execute it once on\n     the file gradebook.txt.\n\n  2. Type make a second time. Why is it not compiling anything?\n\n  3. Type ls -l and note the time on evil.cpp\n\n  4. Type touch evil.cpp in the console. This changes the modify time\n     as if you had edited evil.cpp. Try ls -l again and see.\n\n  5. What will happen if we type make now? Will nothing happen again?\n     Something else? Think in advance and discuss with your neighbor.\n\n  6. Try make. Were you right? Discuss what happened and why with your\n     neighbor.\n\n  7. What would happen if we touch Student.h instead? Again, verify your\n     answer.\n\n\nPart II: diff\n     Professor Evil has found an old working executable of the evil program.\nThey provided this executable program with your starter files—it is named\nevil_reference. Professor Evil has requested that you make your version\nof the program identical to the old version. Specifically, they want to make\nsure that all printed outputs from your version match the outputs from the\nold version exactly.\n     You can do this using diff, a command-line tool that allows you to\ncompare the contents of two different files. All differences between the two\nfiles will be reported to you by diff—if there are no differences, then nothing\ngets reported.\n\f\nRedirecting Output\nBecause diff compares files, if you want to compare your program’s termi-\nnal output with that of the reference, you first must save each program’s\nterminal output in its own file. We call this redirecting the output to a file.\n    To do this, you’ll first want to switch from using tcsh to bash in terminal.\nBoth tcsh and bash are essentially programming languages—they are the\nlanguages of commands that you enter in terminal. By default, the Tufts\nhomework server uses tcsh. While it is possible to redirect output using\ntcsh, it is a bit more complicated. Instead, you can use bash by simply\ntyping “bash” on the command line and hitting enter. This will change the\nprompt you see on the command line, like this:\nvm-hw03{milod}101: bash\nbash-4.2$\n\n   Later, if you want to stop using bash, you can simply type “exit”.\n   Now, if you want to redirect all terminal output (both standard output\nand error messages) to a file, you can do so by running your program the nor-\nmal way, along with the &> redirection operator. For example, try running\nyour program and redirecting the output to a file named my.output:\n./evil gradebook.txt &> my.output\n\n     You’ll notice that nothing prints to terminal this time. Instead, a file\nnamed my.output should have been created. Open up this file—it should\nlook identical to the terminal output you saw before. Now, create a similar\nfile from the reference implementation:\n./evil_reference gradebook.txt &> ref.output\n\nYou should now have two separate files, my.output and ref.output, which\nrespectively contain the output from your program and the reference imple-\nmentation.\n\n\nRunning diff\nLet’s use diff to compare these two files. On the command line, run:\ndiff my.output ref.output\n\n    If the outputs were identical (which is our goal), then diff wouldn’t\nprint anything, because there are no differences. However, in this case you\nshould receive a diff output that looks as follows:\n\n1c1\n< Here is a log of failed students!\n---\n> Here is a log of failed students:\n     Let’s break this down. First, we see 1c1. The two numbers are line\nnumbers. The first number is a line number from the first file given to diff\n(in this case, my.output), and the second number is a line number from\nthe second file (ref.output). The “c” in the middle means that we must\n“change” line 1 from the first file to make it match line 1 from the second\nfile (other options are “a” for add, and “d” for delete).\n     Next, we see the actual lines themselves. First, we see the line from the\nfirst file:\n\n    < Here is a log of failed students!\n\nfollowed by a ---, and finally followed by the line from the second file:\n\n    > Here is a log of failed students:\n\n    Can you spot the difference between the two lines? Once you see it, go\nin and edit your program so that it matches the reference, then re-compile\nit. Once again run your program and redirect its output to a file, and use\ndiff to compare that file to ref.output. Does diff have any output? If\nnot, congratulations! You have successfully matched the reference program’s\noutput. If there is a diff output, keep on debugging until there is no longer\na difference between programs.\n    Using diff is a crucial skill in CS15. It’s exactly how our autograder\nfor every assignment works: we use diff to compare both your terminal\noutput and any file outputs to those from a reference implementation. If\nyou want to get a good autograder score, it is necessary that you use diff\nto test your program against the reference implementation we provide you.\n\n\n\f",
    "CS 15: Recursion Lab\n                                                               2\n\n\nDepth First Search\nThere are numerous algorithms for solving mazes; today, we will explore\ndepth-first search (DFS), one of the canonical search algorithms. With\nDFS, we follow a path as far as we can. Along the way, when we reach a fork\nin the road, we pick one way arbitrarily.We might choose to always go left,\nor to always go right, or even to choose randomly. Regardless, we continue\nuntil we either hit a dead-end or we reach the goal. If we’re at a dead end,\nthen we backtrack to the last fork and follow a new (unexplored) route to\nits conclusion.\n\n\nHuman-Facing Maze Representation\nThe mazes that the starter code creates look like the diagram below on the\nleft, and solved mazes will look like the diagram on the right; the S is where\nthe maze starts, and the F is where the maze finishes. Walls are marked\nwith Xs, and available paths are marked by blank areas. When solving a\nmaze, . characters trace the solved path through the maze, and lowercase\nb characters show where the solving algorithm had to backtrack during the\nsolving phase (it is actually easier to see the results on a computer screen).\nLook at the figure below and trace the periods to check the solution.\nauto - generated maze                            result of exploration\n-------------------                              ---------------------\n\n XXXXXXXXXXXXXXXXX                                 XXXXXXXXXXXXXXXXX\n XSX   X         X                                 X S X ... XbbbbbbbbbX\n X X X XXXXXXX X X                                 X . X . X . XXXXXXXbXbX\n X   X X     X X X                                 X ... X . X ..... XbXbX\n XXXXX X XXX XXX X                                 XXXXX . X . XXX . XXXbX\n X   X   X X   X X                                 X       X ... XbX ... XbX\n X XXXXXXX XXX X X                                 X XXXXXXXbXXX . XbX\n X X   X     X   X                                 X X ... X ..... X ... X\n X X X X XXX XXX X                                 X X . X . X . XXX . XXX . X\n X X X X X X     X                                 X X . X . X . X X ..... X\n X X X X X XXXXXXX                                 X X . X . X . X XXXXXXX\n X X X   X X     X                                 X X . X ... X X           X\n X X XXXXX X X XXX                                 X X . XXXXX X X XXX\n X X   X     X   X                                 X X ... X           X     X\n X XXX XXXXXXXXX X                                 X XXX . XXXXXXXXX X\n X              FX                                 X         .......... F X\n XXXXXXXXXXXXXXXXX                                 XXXXXXXXXXXXXXXXX\n\f                                                                                      3\n\n\nMachine-Facing Maze Representation\nIn memory, the maze is represented by a 2-dimensional array of characters\nlaid out in rows and columns, where maze[row][col] denotes the character\nrow lines down and col positions over from the left. maze[0][0] is the top\nleft corner. (As with all arrays in C++, indices are zero-based). Our mazes\nwill all be square (equal number of columns and rows). For the mazes\nshown above, the start (S) is at position maze[1][1], and the finish (F) is\nat position maze[maze_size - 2][maze_size - 2]. If you’re interested in\nhow the mazes are implemented and generated, see Maze.h and Maze.cpp.\n\n\nThe Recursive Algorithm\nThe general recursive algorithm for solving the maze is straightforward: we\nneed to “solve the maze” in terms of ‘solving the maze’. We will, therefore,\ntry to solve the maze by going in all four possible directions from the start\nposition. In case of multiple possible directions, the reference implementa-\ntion follows the order: North, then East, then South, then West. Although\nthis choice is technically arbitrary, you must try the directions in the\nsame order to match our solution: N, E, S, W. Thus, at every point we\nwill return the result of continuing North, East, South, then West. And, if\nwe find ourselves at the finish line, then we have solved the maze! It might\nseem counter-intuitive, but that’s really all there is to it.\n\n\nExample Traversal\nHere is an example maze.       1   Let’s traverse it!\n    012345678\n  0 XXXXXXXXX\n  1XS X     X\n  2 XXX X X X\n  3X X X X X\n  4 X X XXX X\n  5X X      X\n  6 X XXXXX X\n  7X       FX\n  8 XXXXXXXXX\n\n   1\n     Note: to aid the discussion, we have attached row and column indices in the figures\nhere. These are not part of the array that holds the maze.\n\f                                                                            4\n\n\nA journey of 1000 miles begins with a single step. So which way to go?\nRemember, we always go in order of North, East, South, West. In our\ncase, North is blocked by a wall (X). East is free, so we go that way! As we\ncontinue forward, we mark where we came from with a breadcrumb (.) so\nwe can find our way back.\n    012345678\n  0 XXXXXXXXX\n  1XS. X    X\n  2 XXX X X X\n  3X X X X X\n  4 X X XXX X\n  5X X      X\n  6 X XXXXX X\n  7X       FX\n  8 XXXXXXXXX\n\nKeep in mind that DFS is not ‘smart’ ! It will eventually finish the maze, but\nit might take a big detour even when it is close to the finish. For instance,\nafter continuing with our DFS traversal, we will eventually wind up here.\n    012345678\n  0 XXXXXXXXX\n  1 X S .. X  X\n  2 XXX . X X X\n  3X X.X X X\n  4 X X . XXX X\n  5 X X ..... X\n  6 X XXXXX X\n  7X         FX\n  8 XXXXXXXXX\n\nAt this position, we humans can clearly see that South is the correct way\nto go, but based on our chosen strategy, the algorithm will first pursue the\nNorthern way. Thus, it will continue, until reaching:\n    012345678\n  0 XXXXXXXXX\n  1 X S .. X ... X\n  2 XXX . X . X . X\n  3X X.X.X.X\n  4 X X . XXX . X\n  5 X X ..... X\n  6 X XXXXX X\n  7X            FX\n  8 XXXXXXXXX\n\f                                                                                       5\n\n\nNote that the path went up, left, and down. At this point, we find walls\non all sides (except where we came from), so we backtrack, and leave a\n(b) symbol to indicate that we backtracked from this position. When the\nalgorithm backtracks, it continues from the last fork; if it tried going North\nbut had to backtrack, the next move will be to go East. If it tried North\nand East without success, then it will try South. In our example, eventually\nwe wind up back at this position.\n    012345678\n  0 XXXXXXXXX\n  1 X S .. XbbbX\n  2 XXX . XbXbX\n  3 X X . XbXbX\n  4 X X . XXXbX\n  5 X X ..... X\n  6 X XXXXX X\n  7X          FX\n  8 XXXXXXXXX\n\nNow we can go South!\n    012345678\n  0 XXXXXXXXX\n  1 X S .. XbbbX\n  2 XXX . XbXbX\n  3 X X . XbXbX\n  4 X X . XXXbX\n  5 X X ..... X\n  6 X XXXXX . X\n  7X          FX\n  8 XXXXXXXXX\n\nBelow is a log of all of the steps that were produced by the solution (line\nnumbers added by us). You may find similar debug output to be very useful!\nNote that it takes 71 steps to solve this tiny maze! See if you can follow at\nleast some of the steps.\n1:    row 1 and col 1 , Marking with period (.)\n2:    Trying north , row 0 and col 1 , Hit wall , Back at row 1 and col 1\n3:    Trying east , row 1 and col 2 , Marking with period (.)\n4:    Trying north , row 0 and col 2 , Hit wall , Back at row 1 and col 2 ,\n5:    Trying east , row 1 and col 3 , Marking with period (.)\n6:    Trying north , row 0 and col 3 , Hit wall , Back at row 1 and col 3 ,\n7:    Trying east , row 1 and col 4 , Hit wall , Back at row 1 and col 3 ,\n8:    Trying south , row 2 and col 3 , Marking with period (.)\n9:    Trying north , row 1 and col 3 , We came from here , Back at row 2 and col 3 ,\n10:   Trying east , row 2 and col 4 , Hit wall , Back at row 2 and col 3 ,\n11:   Trying south , row 3 and col 3 , Marking with period (.)\n12:   Trying north , row 2 and col 3 , We came from here , Back at row 3 and col 3 ,\n13:   Trying east , row 3 and col 4 , Hit wall , Back at row 3 and col 3 ,\n14:   Trying south , row 4 and col 3 , Marking with period (.)\n15:   Trying north , row 3 and col 3 , We came from here , Back at row 4 and col 3 ,\n16:   Trying east , row 4 and col 4 , Hit wall , Back at row 4 and col 3 ,\n17:   Trying south , row 5 and col 3 , Marking with period (.)\n18:   Trying north , row 4 and col 3 , We came from here , Back at row 5 and col 3 ,\n19:   Trying east , row 5 and col 4 , Marking with period (.)\n20:   Trying north , row 4 and col 4 , Hit wall , Back at row 5 and col 4 ,\n21:   Trying east , row 5 and col 5 , Marking with period (.)\n22:   Trying north , row 4 and col 5 , Hit wall , Back at row 5 and col 5 ,\n23:   Trying east , row 5 and col 6 , Marking with period (.)\n24:   Trying north , row 4 and col 6 , Hit wall , Back at row 5 and col 6 ,\n25:   Trying east , row 5 and col 7 , Marking with period (.)\n26:   Trying north , row 4 and col 7 , Marking with period (.)\n27:   Trying north , row 3 and col 7 , Marking with period (.)\n28:   Trying north , row 2 and col 7 , Marking with period (.)\n29:   Trying north , row 1 and col 7 , Marking with period (.)\n30:   Trying north , row 0 and col 7 , Hit wall , Back at row 1 and col 7 ,\n31:   Trying east , row 1 and col 8 , Hit wall , Back at row 1 and col 7 ,\n32:   Trying south , row 2 and col 7 , We came from here , Back at row 1 and col 7 ,\n33:   Trying west , row 1 and col 6 , Marking with period (.)\n34:   Trying north , row 0 and col 6 , Hit wall , Back at row 1 and col 6 ,\n35:   Trying east , row 1 and col 7 , We came from here , Back at row 1 and col 6 ,\n36:   Trying south , row 2 and col 6 , Hit wall , Back at row 1 and col 6 ,\n37:   Trying west , row 1 and col 5 , Marking with period (.)\n38:   Trying north , row 0 and col 5 , Hit wall , Back at row 1 and col 5 ,\n39:   Trying east , row 1 and col 6 , We came from here , Back at row 1 and col 5 ,\n40:   Trying south , row 2 and col 5 , Marking with period (.)\n41:   Trying north , row 1 and col 5 , We came from here , Back at row 2 and col 5 ,\n42:   Trying east , row 2 and col 6 , Hit wall , Back at row 2 and col 5 ,\n43:   Trying south , row 3 and col 5 , Marking with period (.)\n44:   Trying north , row 2 and col 5 , We came from here , Back at row 3 and col 5 ,\n45:   Trying east , row 3 and col 6 , Hit wall , Back at row 3 and col 5 ,\n46:   Trying south , row 4 and col 5 , Hit wall , Back at row 3 and col 5 ,\n47:   Trying west , row 3 and col 4 , Hit wall , Back at row 3 and col 5 ,\n48:   Failed . Marking bad path with b . Back at row 2 and col 5 ,\n49:   Trying west , row 2 and col 4 , Hit wall , Back at row 2 and col 5 ,\n50:   Failed . Marking bad path with b . Back at row 1 and col 5 ,\n51:   Trying west , row 1 and col 4 , Hit wall , Back at row 1 and col 5 ,\n52:   Failed . Marking bad path with b . Back at row 1 and col 6 ,\n53:   Failed . Marking bad path with b . Back at row 1 and col 7 ,\n54:   Failed . Marking bad path with b . Back at row 2 and col 7 ,\n55:   Trying east , row 2 and col 8 , Hit wall , Back at row 2 and col 7 ,\n56:   Trying south , row 3 and col 7 , We came from here , Back at row 2 and col 7 ,\n57:   Trying west , row 2 and col 6 , Hit wall , Back at row 2 and col 7 ,\n58:   Failed . Marking bad path with b . Back at row 3 and col 7 ,\n59:   Trying east , row 3 and col 8 , Hit wall , Back at row 3 and col 7 ,\n60:   Trying south , row 4 and col 7 , We came from here , Back at row 3 and col 7 ,\n61:   Trying west , row 3 and col 6 , Hit wall , Back at row 3 and col 7 ,\n62:   Failed . Marking bad path with b . Back at row 4 and col 7 ,\n63:   Trying east , row 4 and col 8 , Hit wall , Back at row 4 and col 7 ,\n64:   Trying south , row 5 and col 7 , We came from here , Back at row 4 and col 7 ,\n65:   Trying west , row 4 and col 6 , Hit wall , Back at row 4 and col 7 ,\n66:   Failed . Marking bad path with b . Back at row 5 and col 7 ,\n67:   Trying east , row 5 and col 8 , Hit wall , Back at row 5 and col 7 ,\n68:   Trying south , row 6 and col 7 , Marking with period (.)\n69:   Trying north , row 5 and col 7 , We came from here , Back at row 6 and col 7 ,\n70:   Trying east , row 6 and col 8 , Hit wall , Back at row 6 and col 7 ,\n71:   Trying south , row 7 and col 7 , Found the Finish\n\f                                                                             7\n\n\nGetting Started\nCreate a directory for this lab and move into it. Copy the files from the\nusual place. Use the provided Makefile, and do not edit it. Remember:\nwrite a little, compile/link, test, repeat.\n\n\nTask 1: Finish implementing the Position class\nA Position instance encodes a row and a column in a class, and also\nhas constructors and helpful functions for getting the position to the North,\nEast, South, West of a given (row, col). For example, if p is an instance of a\nPosition, then p.north() should return a Position object with row and\ncolumn indices of the cell just to the north of p. If you look in Position.cpp,\nyou’ll notice that there are some useful functions on positions that need to\nbe implemented. Implement north(), south(), east(), and west().\n\n\nTask 2: Solving the Maze\nsolve function\nComplete the implementation of the solve function. Specifically, implement\nbool solve(Position p) in the file Solver.cpp.\n\nN, E, S, W\nRemember to solve the maze by going in all four possible directions from\neach position, starting at the start position (1, 1). That is, we’ll hunt for\nsolutions starting at (0, 1) (to the North), then at (1, 2) (to the East), then\nat (2, 1) (to the South), then at (1, 0) (to the West). Remember to use the\nsame direction order (N, E, S, W)! It will help with grading and debugging.\nThat’s really all there is to it: if any of the recursive paths we chose return\ntrue, we have solved the maze! If none work out, then there is no solution.\nSad. The functions in Maze.h and Position.h for accessing the maze and\nvisiting different directions will be helpful in this step.\n\nTips on Recursion\nAs with any recursive solution, we must go through a series of ordered steps\nwhich help us visualize any problem, no matter the complexity.\n\f                                                                             8\n\n\nBase Cases\n   • If a cell would be outside the maze (the indices are not in the bounds\n     of the matrix), then we know there can’t be a solution starting from\n     the given position. What should we return?\n\n   • If a cell is blocked, then we also know there can’t be a solution starting\n     from the given position. How could a cell be blocked?\n\n        ◦ There’s a wall (X) there.\n        ◦ We’ve been here before, i. e., we see a bread crumb (.), or a\n          previously failed path (b).\n\n   • If we have reached the goal (F). In this case, we have succeeded in\n     finding a solution!\n\nChange Something, Adjust Yourself, Recurse\nDon’t forget to change things along the way!\n\n   • Remember to mark the current location with a . before recursing\n     through the directions. This will help avoid investigating loops, and\n     because this might be a solution path.\n\n   • Remember to mark the current position with a b after recursing through\n     all the directions. This way we indicate to subsequent calls that this\n     step is not on the solution path.\n\n   • Now get moving!\n\n\nTask 3: Finding the path length\nIntroduction\nSuppose we found a path. We’re going to find the length of the path in\ntwo ways. While we could find the length by following the bread crumb (.)\ntrail, we can also notice that, if we’ve solved the maze, we could just count\nthe dots! The length of the path is the number of dots plus one (convince\nyourself that’s true!).\n\f                                                                            9\n\n\nFunctions to Implement\nFor this task, you will implement two functions in Solver.cpp:\n\n  1. int num_dots_by_rows(int row)\n\n  2. int num_dots_in_row(int row, int col)\n\nFor finding the length of the path, we want you to focus on understanding\nwhat is happening on each recursive call and practice doing calculations with\nrecursion. If you have a 2-dimensional array, and you want to traverse it re-\ncursively, probably the easiest way is to write a function num_dots_by_rows\nthat recurses over the rows (or just the row index if the array is a data mem-\nber). This function adds up the number of dots in all the rows, but calls\nanother function to get the number of dots in a particular row. This second\nfunction num_dots_in_row recurses over the column index and returns the\nnumber of dots in a row.\n\n\nTask 4: Solving and Measuring Together\nTasks 2 and 3 will likely take most of your time in lab. If you finish\nearly, and would like further practice, you may complete the implemen-\ntation of int solve_and_count() in Solver.cpp, which solves the maze\nand returns the number of steps it takes all at once. The function should\nreturn NOT_FOUND; if it cannot find a path from start to finish. The behav-\nior is essentially the same as for the solve function above, but rather than\nreturn a boolean value, it returns how far you are from the finish. Consider\nthese cases:\n\n   • You did not find a solution\n\n   • You are at the solution\n\n   • You are not at the solution, but you found a solution from a neigh-\n     boring cell of length L\n\n\nOther Details\nWhen you run the test program, it does the following:\n\n  1. prompts for a maze size (make sure to test with small and large num-\n     bers).\n  2. prints out an unsolved maze and then the solved maze using solve().\n\n  3. prints out the length of the path using path_length()\n\n  4. builds and prints a new maze\n\n  5. solves it using solve_and_count()\n\n  6. prints out the path length and the final solved maze from the previous\n     step\n\nWe strongly encourage you to solve the first three tasks. The fourth one is\nfor extra practice and understanding of recursion. And recursion, as many\nexperienced engineers believe, is the future.\n\n\nProviding\nYou will need to submit the following files:\n      main . cpp\n      Makefile\n      Maze . cpp\n      Maze . h\n      Position . cpp\n      Position . h\n      README\n      Solver . cpp\n      Solver . h\n   You must submit them using Gradescope to the assignment lab_recursion.\nSubmit these files directly, do not try to submit them in a folder.\n\n\f",
    "CS 15 Lab 13: Sorting\n\nIntroduction\nDoes an in-place sorting algorithm run faster than one that uses an auxil-\niary array? Does Quicksort, despite having an O(n2) worst-case run-time\ncomplexity, actually perform better than the O(n log n) mergesort? It is\nthe goal of this lab for you to see for yourself!\n\n\nGetting Started\n  1. Copy over the starter materials from the usual place.\n\n  2. Look at the table in the RESULTS file. You will fill this out as you\n     work.\n\n  3. To get started, run, observe, and learn:\n\n        • make\n        • ./sort\n        • ./sort -h\n        • ./sort -r 10 selectionPlace -debug\n        • ./sort -r 10 selectionPlace\n        • ./ntimes 2 5\n        • ./count 2 10\n        • ./count 10 2\n        • ./count 10 0 | ./sort -f - selectionPlace -debug\n        • ./sort -r 1000 selectionPlace\n        • ./sort -r 10000 selectionPlace\n        • Pause. Explain the last two runs.\n\n                                        1\n\f                                                                            2\n\n\n        • Predict the result of sorting 100,000 random elements using in-\n          place selection sort. Write down your estimate.\n        • ./sort -r 100000 selectionPlace\n        • How close was your estimate?\n        • ./sort2 -r 100000 selectionPlace\n        • sort2 is an optimized executable based on our solution (equivalent\n          of make faster)\n\n  4. Read the file comments at the top of sorting.cpp.\n\n\nThe Assignment\nYou will have a few sorting algorithms to implement, and you will be tasked\nwith filling in a table (see the RESULTS file) as you go. You’ll need to write\ncode for:\n  1. In-place insertion sort\n\n  2. Quicksort, both the function and the partition function\nIf you have time, you may also write:\n  1. Insertion sort with an auxiliary array.\n\n  2. The merge function for mergesort.\nBe sure your sorts work on 0-element and 1-element lists as well as already\nsorted, reverse sorted, and random lists. Also, as you saw at the beginning,\n./sort can run and time different algorithms from different input sources:\nrandomly generated lists of a given size, input from a file, or input from\nstandard input. You can use this capability to debug your code.\n\n\nEvaluating Sorting Algorithms\nOnce you have correctly implemented the sorting algorithms above, you can\ncompare and contrast their runtimes! Fill in and extend the table in your\nRESULTS file. The column headers should be input size/type. For example,\n1000/ran means 1,000 randomly generated numbers; 1000/inc means 1,000\nnumbers increasing (already sorted); 1000/dec means 1,000 decreasing (re-\nverse sorted) numbers; 1000/dup means 1,000 copies of the same element\n(duplicates).\n\f                                                                           3\n\n\n   • Feel free to make up other test cases. If you do, describe them in your\n     RESULTS file. You might also see that some input sizes, although we\n     have enough memory, cannot be sorted in a reasonable amount of time\n     by the O(n2) sorts.\n\n   • As you go, make predictions. Given how long quick sort or merge sort\n     run on 1,000 elements, how long with they run on 10,000 or 100,000\n     elements? Similarly for insertion sort.\n\n   • Try to get quick sort to be slow. What inputs could you pick that\n     would evoke slower times? Compare to merge sort.\n\n   • Talk to each other and the TAs about what you’re seeing.\n\n   • If you want to go further, you can explore the role of compiler opti-\n     mizations on performance. These optimizations can make a significant\n     difference, but they will not affect the relative performance of differ-\n     ent data sets; i. e., Big-O still applies. make fast, make faster, and\n     make fastest will compile the program with increasingly aggressive\n     optimizations applied. Not required, but if you are interested and have\n     time, you may explore the effects on your program.\n\n\nSubmitting Your Lab\nYou will need to submit the following files:\n      sorting.cpp\n      RESULTS\n   You must submit them using Gradescope to the assignment lab_sorting.\nSubmit these files directly, do not try to submit them in a folder.\n\f",
    "CS 15 Stacks, Queues, and\nCircular Buffers Lab\n\n\n\n\nIntroduction\nThis week, we are working with Stacks, Queues, and Cicular buffers. In\nparticular, you will have to implement a few functions for all three! You will\nalso implement tests along the way.\n\n\nGetting Started\nThe files for the lab are located at /comp/15/files/lab_stacks_queues_circular_buffers/.\nAt this point in the semester, you should be familiar with the process of set-\n\n\n                                      1\n\f                                                                             2\n\n\nting up for the lab. If not, refer to any of the previous labs for tips.\n\n\nKey Data Structures\nFor this lab, we will be implementing both a stack and a queue class. For\nboth classes, we will implement a single underlying data structure - a circular\nbuffer! Circular buffers are commonly used in things like network hardware\nas well as in video and audio systems - details are below.\n\nStacks and Queues\nRemember, a stack is a data structure with a Last-In/First-Out (LIFO)\nproperty. Imagine stacking a pile of dirty dishes: you add the new plate to\nthe top of the pile, and when you remove a dish to clean it, you will always\nremove the top plate first.\n    Conversely, a queue is a data structure with a First-In/First-Out (FIFO)\nproperty. Imagine standing in a line (or a queue) at a grocery store. The\nperson who gets in line first is first to be helped.\n\nCircular Buffers\nWhat is a circular buffer? A buffer is a place to store data temporarily.\nWe’re typically going to want to keep items in order, so an ArrayList like\nthe ones you’ve built sp far is a logical choice to implement a buffer.\n    Remember, though, that adding and removing items at one end of an\nArrayList is very slow, because you have to copy the contents back and\nforth to make room or to squeeze items together. Circular buffers don’t\nhave this problem!\n    With circular buffer, all the data will still be ‘together’, but, to avoid\nthe unnecessary copying our data, we’ll keep track of the used and unused\nslots in the array. If someone removes an item from the front or the back,\nwe’ll note that the slot in the array for the removed item is available for\nreuse. For example, consider a buffer with capacity 6 that has already had\n4 characters inserted into it:\n                            a   b    c   d\n                            ↑                ↑\n                            f                b\nHere, f tracks the ‘front’ of the list - the first data item, and b tracks the\n‘back’ of the list - the first available space in the array. In the lab, front\n\f                                                                                    3\n\n\nand back are actually the integer indices in the array of the first used slot\nand first free slot, respectively. 1\n\nOkay! What if we remove ‘a’ ?\n                                     b   c    d\n                                     ↑            ↑\n                                     f            b\nKa-ching! All we had to do was increment f ! What if we remove ‘b’ ?\n                                         c   d\n                                         ↑        ↑\n                                         f        b\nIs this too easy? What if we want to add ‘e’ to the back?\n                                         c   d    e\n                                         ↑            ↑\n                                         f            b\nWe put ‘e’ in the first available slot, indexed by b, and then incremented b.\nWhat if we want to add ‘f’ to the back?\n                                         c   d    e   f\n                                         ↑            ↑\n                                         f            b\nProblem! What is b now? It can’t point past the end of the array. Let’s\nthink circular buffers! How about we point b to the front?\n\n                                         c   d    e   f\n                                 ↑       ↑\n                                 b       f\n\nNow, what happens when we insert ‘g’ at array[back], then update back?\n\n                                 g       c   d    e   f\n                                     ↑   ↑\n                                     b   f\n\nLet’s remove the element at array[front], then update front\n1\n    Note: f and b are terrible names for data members. We’re using short names to make\n    our diagrams easy to read. front and back would be much better in a program!\n\f                                                                         4\n\n\n                           g          d   e   f\n                               ↑      ↑\n                               b      f\nNotice that we still need to expand the array if we need to store more\nelements than we have capacity. Therefore, you must still track the current\nsize and capacity. Otherwise, you’ll risk adding elements and having them\noverwrite existing data. Also, expansion requires a little care.\n\n\nThe Lab\nThere are bunch of functions for you to write! Work through as many as\nyou can in lab. You might want to skip CircularBuffer::expand() at first\n- we suggest getting either the stack or queue working, and then come back\nto expand.\n    Also, it would to your advantage to write tests as you’re writing your\nfunctions! Lab is a good opportunity to begin developing this habit!\n    See the testing section for details.\n\nTasks for Cicular Buffer\n  1. Write the int CircularBuffer::nextIndex helper function that,\n     given an index in the buffer, returns the next index. Remember to\n     wrap around to the start of the array when you get to the end! (Why\n     do we have this function?) Hint: You may find it useful to implement a\n     similar private helper function that returns the previous index. Think\n     about which functions below might benefit from a prevIndex function.\n\n  2. Write the void CircularBuffer::expand() method and test it. This\n     should correctly expand the circular array. Pay special attention to\n     wrapping. This function will be different than other expands you have\n     written!\n\n  3. Write the void CircularBuffer::addAtFront(ElementType elem)\n     method and test it. This should add the given elem to the “front” of\n     the sequence. Note: This should not shift elements!\n\n  4. Write the\n     ElementType CircularBuffer::removeFromBack() method and test\n     it. This should remove the last element in the sequence.\n\f                                                                         5\n\n\n  5. Write ElementType CircularBuffer::removeFromFront() method\n     and test it. This should remove the first element in the sequence.\n\n   You are welcome to add additional private methods to the\nCircularBuffer class, if you wish.\n\nNote!\nA function to add an element to the back of the array has already been\ngiven to you. Be sure you understand it. You may use this function as\na template for the other functions you need to write.\n\nTasks for Stack and Queue\nOnce you have written the circular buffer methods, it should be easy to\nimplement the following methods in the Stack and Queue classes.\n\n  1. Write the\n     void Stack::push(ElementType element) method and test it.\n\n  2. Write the ElementType Stack::pop() method and test it.\n\n  3. Write the\n     void Queue::enqueue(ElementType element) method and test it.\n\n  4. Write the ElementType Queue::dequeue() method and test it.\n\nTips\n   • front and back are integers. They are keeping track of the indices of\n     the front and back of the list within the current array.\n\n   • Keep careful track of where front and back are in the array. If front\n     is 0, and then you add an element to the front of the circular array,\n     what should front be next?\n\n   • Make sure you test each function right after you write it!\n\nYou are encouraged to discuss test strategies with other students and with\nthe course staff. Recall the previous lab in which we went over incremental\ndevelopment and debugging output, and use these strategies as you write\nyour functions.\n\f                                                                        6\n\n\nTesting your code\nTo test your work, you have two options - either way you’d like to test is\nfine! Whichever way you go, please add more tests to the respective file!\n\n  1. You may use the provided main.cpp driver file, or\n\n  2. You may use the provided unit_tests.h testing file.\n\n   Both files have the same kinds of tests!\n\nDriver file testing\nTo test with the driver file: run the command make, then run the com-\nmand ./partyPlaylist. Does the output make sense? Don’t forget to run\nvalgrind ./partyPlaylist to check for memory leaks/errors!\n\nunit test testing\nTo test with the unit testing framework, run the command unit_test (or,\nuse the VSCode extension as discussed in lab1.)\n\n\nProviding your code\nWhen you are confident that your program is correct, turn it in.\n  You will need to submit the following files:\n    unit_tests.h\n    CircularBuffer.cpp\n    CircularBuffer.h\n    Queue.cpp\n    Queue.h\n    Stack.cpp\n    Stack.h\n    Makefile\n    ElementType.h\n    README\n    main.cpp\n   You must submit them using Gradescope to the assignment lab_stacks_queues_circular_buffers\nSubmit these files directly, do not try to submit them in a folder.\n\f                                                                      7\n\n\nWrap-up Questions\n  • In your opinion, which data structure is better for a DJ table?\n\n  • Which one is better for a Top 10 Countdown on the Radio?\n\n  • How do stacks and queues interact with each other?\n\n  • What happens when you dequeue into a stack and then pop everything\n    off?\n\f",
    "CS 15 Tree Traversals Lab\n\nIntroduction\nIn this lab, you will practice traversing binary trees. Specifically, you’ll gain\npractice with:\n\n   • Three traversal orders:\n\n         ◦ in-order\n         ◦ pre-order\n         ◦ level-order\n\n   • Two implementation strategies:\n\n         ◦ Recursive, using the function call stack\n         ◦ Iterative\n              - For pre order traversal, using an std::stack\n              - For level order traversal, using an std::queue\n\n   • The C++ Standard Template Library (STL).\n\n   • Universal Polymorphism, because we’re using the STL. The STL im-\n     plements a variety of standard containers which are templated - thus,\n     you can use them for any type of data!\n\n\nTraversal Algorithms Review\nWe will have talked about traversals in class, but here is a review (in case\nwe don’t get to all of them).\n\n\n\n\n                                       1\n\f                                                                           2\n\n\nIn-Order Algorithm\nThis algorithm is naturally recursive, and we’ll do a recursive implementa-\ntion in this lab.\n  1. Traverse left\n  2. Process current Node (whatever that means for the application)\n  3. Traverse right\n  4. Don’t forget to combine and return results if necessary!\n\nPre-Order Algorithm\nThis algorithm is also naturally recursive, but we won’t do it recursively\nin this lab:\n  1. Process current Node (whatever that means for the application)\n  2. Traverse left\n  3. Traverse right\n  4. Don’t forget to combine and return results if necessary!\nHow can we do it non-recursively? We will mimic the storage behavior the\nfunction call stack gives us with an std::stack data structure: that is,\nrather than make a recursive call, you’ll push the object (actually a pointer\nto it) onto a std::stack.\n  1. Push root on the stack if the tree isn’t empty\n  2. As long as there is anything in the stack:\n      (a) Pop an object off the stack\n      (b) Process that node (whatever that means for the application)\n      (c) If there’s a right child, push it on the stack\n      (d) If there is a left child, push it on the stack\n      (e) Don’t forget to combine and return results if necessary!\n     You must be careful to push the right child onto the stack first so that\nthe left subtree is handled first (because of the LIFO nature of the stack).\nBe sure you understand this: Draw out an example for yourself (not to turn\nin).\n     Observe how much easier the recursive version is!\n\f                                                                              3\n\n\nLevel-Order Algorithm\nIn a level-order traversal, we process nodes in “level order”. That is, we\nprocess the root, then the root’s children, then the root’s children’s children,\netc. If you draw the tree, you process all the nodes on one line (at one level)\nbefore proceeding the the next level.\n    This traversal cannot be done easily with recursion. You cannot use a\nstack, because nodes are not processed in a LIFO order.\n    Instead, we’ll use a queue - in particular, we will use an instance of\nstd::queue. The algorithm is essentially the same as for the non-recursive,\nstack-based pre-order algorithm above, except it uses a queue to process\nnodes in a FIFO order.\n\n\nThe Standard Template Library (STL)\nThe Standard Template Library (STL) is a set of C++ libraries that pro-\nvide containers and other functionality that can be used with most objects\n(e.g., to contain Node pointers). You’ve already seen std::vector and\nstd::list. In this lab, we will be using std::stack and std::queue.\n\n\n\n    • The STL demonstrates modularity:\n      Since all queues look the same, why re-implement one for every applica-\n      tion? There is one, ready-to-use, well-debugged queue implementation\n      that we can all share!\n\n    • The STL demonstrates universal polymorphism:\n      Since a queue of integers and a queue of patrons of the Olympic gym-\n      nastics finals are exactly the same except for the type of the data, why\n      re-implement a queue for each data type? If we did that, we couldn’t\n      satisfy our desire for modularity either except for certain very simple\n      cases. So, there is one ready-to-use, welll-debugged queue implemen-\n      tation that we can use for any type of data!\n\n\n    To create a std::stack or std::queue object, you need to tell the com-\npiler what type of object or fundamental data type you will be putting into\nthe container. To do this, you use angle brackets, as follows:\n\f                                                                               4\n\n\n 1   #include <stack>\n 2   #include <queue>\n 3   #include <string>\n 4\n 5   int main() {\n 6       std::stack<int> my_stack_of_ints;\n 7       std::queue<std::string> my_queue_of_strs;\n 8       return 0;\n 9   }\n\n     Like all data abstractions, the STL containers have interfaces: They come\n     with a set of functions that define the abstract type. You’ll find lists of\n     functions for STL stacks and queues below for your reference.\n\n     STL Stack Interface\n         Function                        Description\n         void pop()                      Removes element from the top of the stack\n         bool empty() const;             Returns true if stack is empty\n         TYPE& top();                    Returns a reference to the top element of stack\n         void push(const TYPE &val);     Puts val on top of stack\n         size_type size() const;         Return number of elements on the stack\n\n     Code Example\n\n 1   #include <stack> // load declarations from STL\n 2\n 3   int main() {\n 4       std::stack<int> s; // make stack of integers\n 5       s.push(14); // push on two items\n 6       s.push(12);\n 7\n 8        int n = s.top(); // get copy of top item\n 9        s.pop(); // remove top item\n10        return 0;\n11   }\n\f                                                                                           5\n\n\n     STL Queue Interface\n         Function                                  Description\n         void pop()                                Removes element from front of queue\n         bool empty() const;                       Return true if queue is empty\n         TYPE& front();                            Returns a reference to the front element of queue\n         void push(const TYPE &val);               Puts val on back of queue\n         size_type size() const;                   Return number of elements on the queue\n\n     Code Example\n\n 1   #include <queue> // load declarations from STL\n 2\n 3   int main() {\n 4       std::queue<int> q; // make queue of integers\n 5       q.push(14); // push on two items\n 6       q.push(12);\n 7\n 8            int n = q.front(); // get copy of front item\n 9            q.pop(); // remove top item\n10            return 0;\n11   }\n\n\n\n     Implementation Specifics\n     Getting Started\n     Get the files from /comp/15/files/lab_tree_traversals as always. The\n     items you have to complete have TODO comments. You will write the\n     traversal functions as specified above for a BST class1\n\n     Node struct\n     The Node structure for the BST class is as follows:\n 1   struct BSTNode {\n 2          int value;\n 3          BSTNode *left;\n 4          BSTNode *right;\n 5   };\n\n          1\n              Note that these traversals can be generalized to work on any type of tree!\n\f                                                                           6\n\n\nFunctions to Implement\nYou will write three functions, each implementing one of the traversals.\n\n  1. void BST::inOrder(BSTNode *root)\n     You must use recursion for this function, following the rules for print-\n     ing the nodes in the In-Order Algorithm section of this document.\n     (Make sure you use spaces appropriately when you print — you want\n     your solution to be the same as the solution that we provide).\n\n  2. void BST::preOrder(BSTNode *root)\n     Do a preorder traversal of the tree using an std::stack, following the\n     rules for printing the nodes in the Pre-Order Algorithm section of\n     this document, using the std::stack interface above.\n\n  3. void BST::levelOrder(BSTNode *root)\n     Do a level-order traversal of the tree using an std::queue, follow-\n     ing the rules for printing the nodes in the Level-Order Algorithm\n     section of this document, using the std::queue interface above.\n\n  4. Just For Fun Exercise (JFFE): void BST::postOrderDelete(BSTNode *root)\n     Called by the destructor and should delete all nodes in a postorder\n     fashion. Exam-type question: Can we delete in another order, say by\n     doing a pre-order traversal?\n\nThings to Notice\nThere are a few unusual things worth noticing in the code.\n\n   • Although the three functions above are private, there are also three\n     public functions that are defined as:\n\n        ◦ void BST::inOrder();\n        ◦ void BST::preOrder();\n        ◦ void BST::levelOrder();\n        ◦ void BST::postOrderDelete();\n\n     These functions are the ones called in main(). They will then call their\n     corresponding private version. These are called wrapper functions.\n     Outside the BST class, e. g., in main(), we do not have access to the\n     private data member root (nor should we!).\n\f                                                                          7\n\n\n   • Also notice that the private functions you’re going to write take in\n     a BSTNode * (pointer to a BSTNode) as a parameter. You’ll need to\n     consider how your std::stack and std::queue objects will need to\n     be declared to work with pointers!\n\nTips\n   • Test as you go!\n       Don’t do everything at once! Pick a function, and do that one first.\n       You may not even write the whole function. For example, if you’re not\n       used to using the STL types, you might write a draft of the function\n       that just pushes and pops one item on the std::stack or std::queue.\n       Test that. Slowly build up your function out of pieces that you com-\n       pletely understand and that work.\n\n   • Talk!\n       You can’t share code with your classmates, but you can share ideas.\n       Draw pictures, discuss.\n\nSubmitting Your Work\nYou will need to submit the following files:\n    main.cpp\n    BSTree.cpp\n    BSTree.h\n    Makefile\n    README\n   You must submit them using Gradescope to the assignment lab_tree_traversals.\nSubmit these files directly, do not try to submit them in a folder.\n\f",
    "PROJECT METROSIM\n\n\n\n\nGetting Started\n\n   You can get the starter files by running the following command:\n/comp/15/files/proj_metrosim/setup\n\nNote that you should not manually run cp, but rather run the above program. The files will be copied\nfor you.\nThe Reference Implementation\nAfter running the above command, you will have access to a reference implementation of the program\nnamed the_MetroSim. We strongly encourage you to play around with it both to learn what is\nexpected of your program and to test your your program. We will be comparing your program’s\noutput to the reference, so be sure that you are adhering to the output format. If the diff command\nreports any differences between the output of your implementation and the reference implementation,\nthen you will lose points on the functional correctness portion of your implementation assessment.\nRefer to the Testing section in this document for more information.\n   The setup script makes a link to the reference implementation rather than your own copy. You\nuse it exactly the same as you would use any other program, but this will guarantee you always use\n\n\n\n\n                                                  10\n\fthe most recent version.\n\n\n\n\nDesign Checkoff (Required)\n\n    First, complete the required design checkoff questions given in the starter file metro design checkoff.txt,\nand submit your answers on Gradescope under the assignment “MetroSim Design Checkoff.”\n    You must submit this file prior to meeting with a TA.\n    Then, go to office hours and talk to a TA about your plan. You should be prepared to discuss the\nanswers you submitted. You are welcome to bring other materials as well, though you are not required\nto: drawings, pseudocode, etc.\n    The design checkoff helps twofold: you plan out your project and get your brain working on it in the\nbackground, and you also get design feedback before it’s too late. TAs will check off your design, but\nreserve the right to not check off your design if they believe your design was not thoroughly mapped\nout enough.\n    Please sign up for a design check off on the form linked here.\n    Note: it is completely okay to deviate from this initial plan. In fact, we encourage you to continue\nto evaluate the structure of your solution and fine-tune it as you go – that’s what programmers do in\nthe real world, anyway. The purpose of this check-off is more to help you establish a game plan, as\nwell as clear up any misconceptions you may have.\n\n\n\n\nPhase One (Required)\n\n   For phase one of this project, you must complete the implementations of Passenger and PassengerQueue,\nand you must thoroughly test these classes. See the course calendar for the due date.\n\n\n\n\nTesting\n\n    Test thoroughly and incrementally. You should be sure that your PassengerQueue behaves as\nintended before you start implementing your MetroSim. Your program will have many components—\nit will be significantly easier to debug issues if you test components as you implement them, rather\nthan implementing everything then testing at the end.\n\n\n                                                  11\n\fCONTENTS                                                                                             12\n\n\n    Use the unit testing skills that you have developed in the first assignment. You can place all tests\nin the file unit_tests.h, which we provide for you. Just make sure to #include any corresponding\n.h files needed for the tests, and to update the dependencies for the unit_test rule in the Makefile\n(see Makefile section, below).\n    We also note that you are not required to use our unit_test framework. Alternatively, you can\ncreate your own testing file, with its own main() function that calls out to testing functions. Then,\nyou’ll have to compile your code with the testing main function instead of the simulator main. The\nchoice of how to test your program is up to you—but either way, you must test your program!\n    Note that many functions within your MetroSim implementation will likely be private; this means\nthat you cannot test them directly from a testing function in another file. You have two options:\n   1. Test private functions indirectly via public functions.\n\n  2. Temporarily make the private functions public to test them, and then make them private once\n     you have tested them (make sure you don’t forget to make them private again!).\n\n    After you have written and debugged the PassengerQueue class and other classes, and you have an\nimplementation of MetroSim that you think works as expected, the best way to test your results will be\nto compare the output from your implementation with the output from the reference implementation.\nYour output and the reference implementation’s output must match exactly. Here are some tips to\nhelp you compare your implementation to the reference:\n\n   • Redirecting the standard output stream (std::cout) to a file using the > symbol on the command\n     line.\n     In the following example, we run MetroSim with stations.txt as the stations file, output.txt\n     as the output file, and commands.txt as the commands file. Any output that MetroSim sends\n     to std::cout will be saved in stdout.txt.\n     ./MetroSim stations.txt output.txt commands.txt > stdout.txt\n\n\n   • Redirecting the contents of a file into the standard input stream (std::cin) using the < symbol\n     on the command line.\n     In the following example, we run MetroSim with stations.txt as the stations file, output.txt\n     as the output file. We are not passing commands.txt as a command-line parameter; rather, we\n     are sending the contents of the commands.txt file to std::cin of the MetroSim program.\n     ./MetroSim stations.txt output.txt < commands.txt\n\n\n   • Redirecting both the standard output (std::cout) and standard input (std::cin) streams.\n     ./MetroSim stations.txt output.txt < commands.txt > stdout.txt\n\n\n     With the above example, any time that MetroSim tries to read from std::cin, it is actually read-\n     ing from commands.txt. Any output that MetroSim sends to std::cout is saved in stdout.txt.\n\n   • Using diff command to compare the contents of two files.\n     It is highly recommended that you compare your output files with that of the demo using\n     diff. So, for instance, if, given the same inputs, the reference implementation produced\n     stdout_demo.txt and your implementation produced stdout_personal.txt, you could com-\n     pare them with the following command:\n     diff stdout_demo.txt stdout_personal.txt\n\f     It can be difficult sometimes to understand the output of diff. Here is one reference that may\n     help:\n     https://linuxize.com/post/diff-command-in-linux/.\n\n\n\n\nMakefile\n\n     Since you are in charge of the structure of your implementation, we cannot know exactly what\nfiles you will have. This means you will need to update the given Makefile to build your program\ncorrectly.\n     The Makefile we provide you with already includes:\n     • A MetroSim rule, with some listed dependencies, and no recipe (yet!)\n   • A rule for building PassengerQueue.o\n   • A unit_test rule, with some dependencies already added, which will be used by the unit_test\n     program\n   • A clean rule which removes object code, temporary files, and an executable named a.out (if\n     one exists)\n   You will need to update the Makefile with the following:\n\n   • Every .cpp file will need a corresponding .o rule in the Makefile. This includes MetroSim.cpp,\n     main.cpp, Passenger.cpp, and any new .cpp files that you write. You can use the given\n     PassengerQueue.o rule as guidance.\n   • The dependencies for the MetroSim and unit_test rules must be updated with the new .o files\n     as needed.\n   • You need to write the recipe for the MetroSim rule, which links all of the necessary .o files\n     together\n\n   We have added TODO comments throughout your Makefile, corresponding to the updates listed\nabove. You must make these updates!\n\n\n\n\nREADME\n\n    With your code files you will also submit a README file. You can format your README however you\nlike. However it should have the following sections:\n   A The title of the homework and the author’s name (you)\n\n                                                13\n\f  B The purpose of the program\n\n  C Acknowledgements for any help you received\n\n  D The files that you provided and a short description of what each file is and its purpose\n\n  E How to compile and run your program\n\n   F An “architectural overview” i.e., a description of how your various program modules relate. For\n     example, how you represent various structures in your implementation (e.g stations, trains).\n\n  G An outline of the data structures and algorithms that you used. Given that this is a data struc-\n    tures class, you need to always discuss the ADT that you used and the data structure that\n    you used to implement it and justify why you used it. Please discuss the features of the data\n    structure and also include (with some justification/explanation) two other situations/circum-\n    stances/problems where you could utilize it. The algorithm overview is always relevant. Please\n    pick a couple interesting/complex algorithms to discuss in the README.\n\n  H Details and an explanation of how you tested the various parts of assignment and the program\n    as a whole. You may reference the testing files that you submitted to aid in your explanation.\n\n   I Tell us how much time you spent, in total, on this assignment in hours.\n\nEach of the sections should be clearly delineated and begin with a section heading describing the\ncontent of the section. You should not only have the section letter used in the outline above.\n\n\n\n\nSubmitting\n\n    Be sure your files have header comments, and that those header comments include your name, the\nassignment, the date, and acknowledgements for any help you received (if not already credited in the\nREADME file).\n    For phase 0, submit your complete metro design checkoff.txt file to the assignment “MetroSim\nDesign Checkoff” on Gradescope.\n    For phase 1, you will need to submit the following files:\n      Passenger.h, Passenger.cpp\n      PassengerQueue.h, PassengerQueue.cpp\n      unit_tests.h\n      README\n    You should only include other C++ files if your solution to PassengerQueue depends on them. Do\nnot submit MetroSim.cpp for example. You must submit them using Gradescope to the assignment\nproj_metrosim_phase1. Submit these files directly, do not try to submit them in a folder. The\nREADME doesn’t have to be the final README. Just document anything that you feel we should know\nabout your Passenger, PassengerQueue, or the submission in general.\n    For the final submission, we don’t know exactly what files your final program will comprise. You\nwill need to submit at least the following files:\n\n                                                14\n\fCONTENTS                                                                                               15\n\n\n      PassengerQueue.h, PassengerQueue.cpp\n      Passenger.h, Passenger.cpp\n      MetroSim.h, MetroSim.cpp\n      main.cpp\n      (... any other C++ source files)\n      (... any testing files)\n      unit_tests.h\n      Makefile\n      README\n   You must also submit:\n\n   • Any unit tests you write for your program. This may be done in a file called unit_tests.h,\n     using the unit_test framework that we have used on past assignments. Alternatively, you can\n     create your own testing main functions, e.g., submit a file called MetroSim_tests.cpp with a\n     main function that calls out to tests. Whatever testing files you use, you must submit them!\n\n   • Any command files (excluding the command file provided).\n\n    You must submit them using Gradescope to the assignment proj_metrosim. Note, you only need\nto include testing input files. For example, input stations or commands files you used. You do not need\nto include output files of any kind (stdout, stderr, or the output files you log passenger departures to).\n\n    Before submitting your work, please make sure your code and documentation (including sections\nof the README) conform to the course style guide.\n\n    Be sure your program builds correctly using the commands make and\n    make MetroSim, because we will use those commands to build your pro-\n    gram in testing. Be sure to include every file required to compile your\n    code, along with any tests, and your Makefile and README. You don’t\n    have to give us the reference implementation. A useful test is to make a\n    submission directory, copy all your files in there, then run make and see\n    if the program builds. Test it, then submit everything.\n\f",
    "question: I took cs11 last semester, and I am not completely sure if I synced entire account's contents or only the cs11 folder.Would it be appropriate to complete the vscode_setup guide anyway?\nanswer:\nI personally like to setup an SFTP for each class, that way I just need to have that class's folder open in VSCode rather than every single class in order to have access to the SFTP syncing. So yes, you can proceed with setting up the SFTP syncing like the instructions say, just make sure you're doing it while in your cs15 folder in VSCode. Follow up if you have any other question about getting it set up!You can also open up your old cs11 folder in VSCode and take a look at what you did for SFTP if you're curious.\n\nquestion: In the hw1 spec, can i use the std::stringstream to implement to string. The same way that was done in the lab1?\nanswer: \nquestion: Could you please help me understand how the what() function knows what message to print? In third_attempt_access, we are calling catch() from &e, but it looks like we never created the e object. I read a geeksforgeeks article about exceptions, and they created a special struct for their exception. I am guessing that our exception is created when we use throw(), but would appreciate confirmation/disproval.\nanswer: \nIn the following code:\n\ntry {\n   int result = attempt_access(arr, size, index);\n   cout << \"Successfully accessed element!\" << endl;\n   return result;\n}\ncatch (const range_error &e) {\n   cout << \"We just got the following error message:\\n\";\n   cout << e.what();\n   return 0;\n}\n\nThe line \"catch (const range_error &e)\" is what actually initializes and binds the variable e. Exceptions are actually just objects in C++, and as a result of that line, e is bound to the range_error object that is thrown as a result of the faulty access. We can then call the \"what()\" method on e, which returns the error message that is associated with that exception.\n\nHopefully that makes sense, but please let us know if you still have question!\n\nquestion: Section (F) of the README requirements in the homework spec, which asks for an outline of the data structures and algorithms you used, says to \"Please pick a couple interesting/complex algorithms to discuss in the README\".What is this question looking for? In the context of CharArrayList, what would be interesting/complex algorithms? What should this discussion entail?\nanswer: An algorithm is a set of steps to accomplish a task or solve a problem. For example, in lecture you all saw the steps or algorithm for expanding an array: Allocate a new, larger array, copy the elements over, and recycle the old array. It's high-level (minimal implementation details), but it describes how you solved a problem. \nYou can describe a few algorithms that you implemented for this homework. Most of them are straightforward, but they will get more involved in later assignments.\n\nquestion: The spec specifies that when we call insertAt, all of the elements to the right of the indicated index should shift one spot to the right. Should removeAt do the opposite? Meaning, should all of the elements to the right of the removed char shift back one spot to the left to fill the \"hole\" that the removed char leaves? My question also applies to popFromFront. Thanks!\n\nanswer:I think the spec intro answers your question for you: \"Note that an array list cannot have “holes”: if you remove the fifth element (element 4) from a 10-element array list, then there are 9 elements left, and their positions are 0 through 8.\"\n\nquestion: How should we handle a case with an empty array list when replacing. Since 0 would technically still be in range of the index should be be able to replace?\nanswer: When the spec says the range is [0 ... SIZE), [ is an inclusive boundary and ) is an exclusive boundary. You should not be able to replace at an index equal to the size.(EDIT: replace, not insert)\n\nquestion: In part D of the read me where it states: \"The files that you provided and a short description of what each file is and its purpose\" Is this asking for all the files we are submitting, including timer_main.cpp, simple_exception.cpp, and Makefile? Or just the files we directly affected, like CharArrayList.cpp, CharArrayList.h, and unit_test.h?Thanks!\nanswer: You should list and describe any file you submit and only submit the files your program depends on. So, you don't need to submit timer_main.cpp or simple_exception.cpp\nthanks!\n\nquestion: Is it necessary to have a recursive function helper specifically for replaceAt?\nI can implement replaceAt with two other public functions and inside those functions are recursivehelpers. \nI'm asking this just to be clearer:\nreplaceAt() {\n\npublicfunc1() { recursionhelper() };\npublicfunc2() { recursionhelper() };\n} \nor does it have to be this:\nreplaceAt() {\nrecursiveHelperForReplaceAt();\n\n}\n\nanswer: The spec says to use recursion so use recursion to get the most points. Additionally, only the methods that are listed in the spec as public should be public.\n\nquestion: Hello! I am passing all of my unit tests. However, I got 15 points off on the autograder. I was wondering if you could give me any tips on where to start looking. Thank you!\nanswer: Hi - there could be many places where points are being lost. First take a look at the autograder score - are you passing all the available tests, and the style check? If you are passing all, then you are likely failing some hidden tests. I would then check the spec. We are highly specific with things like our error messages, so double check not only that you are throwing the right messages and constructing the right strings, but also that you are asserting them correctly. The spec will also mention specific cases that we will test, like self-concatenation.\nIf all that fails, you likely need more unit tests. Make sure you are testing all functions for all cases (including throwing errors). We highly recommend you follow the form for the insertAt tests provided for you.I am making this public in case other students have similar questions/issues. If you have particular questions about code, please make a private post.\n\nquestion: I'm a little confused on what Q3 of the README is asking. Are we assuming the client knows what goes under the hood behind all the functions?\nanswer: A client will never know what goes on under the hood, that's the purpose of abstraction. Q3 is saying to suppose a client is using CharArrayList, what changes would they need to make to instead use CharLinkedList? For example, unit_test was a client of CharArrayList in HW1. Think about the changes you had to make to your HW1 tests to transform them into a client of CharLinkedList for HW2. I hope that example puts the question into more concrete terms, but follow up if you'd like more clarification!\n\nquestion: The project spec seems to imply that we are required to use std::vector or std:: list when \"representing 'lists' of various data types\" (as opposed to writing our own implementations). Is there any reason why we cannot use an array of PassengerQueues to represent the train? After all, the number of stations is fixed for a given run of the program. (This wouldn't be representing a \"list\" of a data type so I wouldn't think it would mean the std::vector or std::list requirement applies, but the note about using std::vector or std::list is put right after the part of the spec describing the train, so I'm unsure if it's referencing that specifically.)\nanswer: Yes, you can just use an array instead of a list or vector. That being said, there are some advantages to using a list of vector in place of an array. The main one is that you can just continually add to the back of either of those std libraries, whereas for an array you need to know exactly how many stations there are. The way our stations file is oriented, you may have to read the stations file twice: first, to get the appropriate size for the array you wish to construct, and a second time to actually populate it. I suppose you could also try to allocate something on the heap with a capacity and double it, but at that point it's almost certainly easier to use a vector or a list. Given this does not contain any code or any of your submission-specific questions, I will make this post public in case other students have similar questions.\n\nquestion: How should we test the print functions given that they take the parameter \"std::ostream &output\"? Is there a way to use try/catch and retrieve the output, similar to what we did for errors in the Array and Linked List homework?\nanswer: I declared an std::stringstream, like some of the pre-provided unit_tests did in HW1, and then passed that std::stringstream to the print function. Then [stringstream name].str() returns it as a string, which you can compare to something else in assert( )\n\nquestion: This may be a silly question but for the PassengerQueue class the spec lists the required functions and then states, \"You may not add any other public functions\" without listing a constructor and a destructor for the class. Is it correct to assume that we should still write a constructor and a destructor for this class?\nanswer: Since they recommend using std::vector or std::list both of these imports contain the big three, so constructors and deconstructs are already covered and implemented.\n\nquestion: I was reading through some of the member types and functions included in the vector library on cplusplus and saw that size_t is a member type used to represent any non-negative integer. I wondered if using size_t rather than ints when making for loops would be better. Are there any other differences between int and size_t? Or could I use size_t instead of int?\nanswer: Good question! Just like you said, size_t is simply a non-negative integer. It's important to note though that occasionally this can pose some issues related to casting. For example, if I have some variable \"int x\" that I think is positive but somehow became negative, and I return x from a function with return type size_t (or some other casting scenario), I am now actually returning a number that I probably don't want. Because when my code tries to turn a negative integer into a non-negative size_t, it'll do some conversions that can cause unexpected behavior. That said, you probably won't be using size_t a ton in this class aside from seeing it as the return type of some standard library functions. In which case, keep my casting note above in mind when you call and save the results of these functions. I guess it's up to you then whether you use size_t instead of int as your iterator for for loops. You do have complete control over what your \"int i\" is for the entirety of your for loop, so it's not like there's a chance it might randomly become negative and you want some built in check to always keep it positive.\n\nquestion: Are we solely being graded on functionality via the auto-grader, or are we also being graded on questions in our README, header and in-line comments, the 80 character limit, and other style guidelines?\nanswer: Phase 1 is just autograder results. The autograder might implicitly count some style stuff like the use of &&, ||, 80 character limit, etc. We won't be reading the README or checking for inline comments per se. That being said, it's probably in your best interest to write inline comments as you go, and to do your best to keep the phase 1 submission to the 15 style guide since you'll be using this code in your final project as well (and we will check it for style then).\n\nquestion: Do we have to check if the station numbers are correct when we construct a passenger object? For example, if I made my starting station 3000, what error should I throw?\nanswer: The Passenger objects are independent of the stations. The station is a client of Passenger (it uses instances of the Passenger or PassengerQueue class, not the other way around). So there would be no way for you to check within Passenger.cpp whether the given arrival and departure stations are in fact valid stations since the passenger has no clue what a valid station even means! If someone were to misuse an instance of Passenger by giving it a station that doesn't exist, then that's their problem, not Passenger's.\n\nquestion: Are we allowed to use the getline() function to read from input files?\nanswer: yes\n\nquestion: I would appreciate if you could advise me on writing a proper header for main.cpp. Would it be appropriate to write \"This file contains functions that allow the client to build and use MetroSim through the command line.\"\nanswer: The style guide mentions what we expect. Take a look at the \"internal documentation\" for more info. Making this public in case someone else has a similar question\n\nquestion: Just to clarify, we can use the FStream library we just can't use any actual fstream types but rather if stream or ofstream?\nanswer: That's right.\n\nquestion: Is it ok if my Makefile has lines that are over 80 chars?\nanswer: There's a way to allow dependencies to go on for multiple lines. Add a  \\ at the end of the first line. See https://stackoverflow.com/questions/38086542/break-long-dependencies-in-makefile-into-several-lines if this explanation isn't clear enough.\n\nquestion: Could you please help me understand if it's possible to #include only <ios> to use all the stream types? For example, can I include only <ios> to use ofstream, istream, and cin/cout in one file? Additionally, I have included <ios> into my Passenger.h, PassengerQueue.h, and MetroSim.h. Can I include <ios> only into Passenger.h if my PassengerQueue.h is using Passenger.h, and my MetroSim.h is using PassengerQueue.h\nanswer: The \"ios\" library does not include the streams that you typically need (cin, cout, cerr, file stream, ...). Including ios alone will not be sufficient for most purposes. Rather, ios is a base class that the other stream classes build on top of. To address your second question: typically, if your file uses some library, that file should directly include that library. You should do so even if some other code that you include already includes that library. The redundancy is fine—even if you could technically get away without it, it is could practice to directly include all libraries that your code needs. That way you are not dependent on some other code you are including being configured in a specific way. For example, if Passenger.h were to change and no longer need some specific library, we wouldn't want removing that library to indirectly break PassengerQueue.h and MetroSim.h. Include the code you need, and you will avoid such errors.\n\nquestion: Is it ok if my Makefile has lines that are over 80 chars\nanswer: Yes, it's good to keep the Makefile under that limit. You can use a backslash (\\) to split the lines up:\ntarget: dependencies1 dependencies2 \\\n        dependencies3 dependencies4 ...\n        recipe ",
    "\n\n    Handling Errors in RPNCalc::run\n    Unrecognized Input\n    For any other input that is not a recognized command, print the offending input and print “:\n    unimplemented” to std::cerr followed by a newline (e.g. “x: unimplemented\\n”). It should not\n    throw an exception. After printing, it should continue accepting input.\n\n    Exception Handling\n    Your RPNCalc class should catch any exceptions that may be thrown from the DatumStack class. If\n    the DatumStack class throws an exception the RPNCalc should print the string associated with the\n    exception to std::cerr. For example if the stack threw an std::runtime_error exception with\n    the message “empty_stack”, the RPNCalc should print “Error: empty_stack\\n” to std::cerr,\n    then continue to accept input.\n        Note: the exception message from the DatumStack class does not include “Error: ”, but RPNCalc\n    should print the error message given when the exeception is (or would be) thrown.\n        Your run() function should also catch all other exceptions thrown during evaluation. For\n    example, since the Datum class can throw std::runtime_errors, you should catch those and print\n    them appropriately to std::cerr:\n       • “Error: datum_not_int\\n”\n\n       • “Error: datum_not_bool\\n”\n\n       • “Error: datum_not_rstring\\n”\n    You can review the lecture on Exceptions for a reminder of how to catch exceptions and print the\n    corresponding exception message.\n\f    We expect your program to never crash. This means you must test for\n    possible edge cases. If you come up with an edge case, you MUST use\n    the reference implementation to determine what the behavior of your\n    program should be for that case, as we will be using the reference,\n    and the exact error messages for grading your assignment.\n\nErrors while getting command parameters from the stack\nWhen running a command that must pop off parameters from the stack, RPNCalc’s run should\nfirst pop both elements off of the stack, and then display the first error enountered, then continue\nprocessing input from the input source. That means that all parameters that had been popped off\nby the error producing command will be discarded.\n\nExample: Datum of wrong type when running the + command\nThe + command expects that the first two elements on the stack are ints. If the + command was\nrun on a stack that had a Datum that wasn’t an int at the top, e.g.:\n\ntop:       | rstring |\n           | int     |\nbottom:    | boolean |\n           -----------\n\nThen the approriate error message should be output and the run function should continue processing\ninput. All Datum that had popped off by + leading up to the error would have been discarded, i.e\nthe stack would look like:\n\ntop:          | boolean |\nbottom:       |         |\n              -----------\n\nError output prints to std::cerr\nAs mentioned above, all error output (and the final program termination message) is sent to\nstd::cerr. The only program output that goes to std::cout is generated when print command\nis sent to RPNCalc.\n\n\n\n\nparseRString Specification\n\nIntroduction and Function Signature\nImplementing the parseRString function will be required as part of your deliverables for Week 1.\nSpecifically, you will submit two files called parser.h and parser.cpp. They should respectively\n\n    contain the declaration and definition of one function called parseRString which takes a reference\n    to an istream as a parameter to continue reading input from. The function signature will be as\n    follows\n1   std::string parseRString(std::istream &input);\n\n\n\n    parseRString Implementation\n    Assume this function is called after an initial “{” has been read from the input stream passed as\n    a parameter. parseRString continues reading input from the stream until all curly braces are\n    matched or until it reaches the end of the input. It returns an rstring (i.e, an std::string), with\n    the preceding rstring specifications.\n\n    Examples\n\n    Example 1 (Again, note the spacing between commands): { 1 2 + }\n    Call parseRString after you see the first {\n    That is, pass \" 1 2 + }\" or \"1 2 + }\" to parseRString\n    It should return the string \"{ 1 2 + }\"\n\n\n    Example 2: { 1 { 4 2 / } / }\"\n    Call parseRString after you see the first {\n    That is, pass \" 1 { 4 2 / } / }\" or \"1 { 4 2 / } / }\"\n    It should return the string: \"{ 1 { 4 2 / } / }\"\n\n    Note: parseRString assumes, therefore, that the first “{” has already been processed, and returns\n    a complete rstring based on the information after that. If you just call parseRString immediately\n    before the first “{”, it will print two “{” characters. This is expected behavior. Later, you will\n    find this function useful when reading in an rstring as input—it allows you to read in a complete\n    rstring, with balanced braces, thereby enabling RPNCalc to handle nested rstrings.\n        If parseRString gets to the end of the input stream without finding the final matching \"}\",then\n    you can choose what to do. Throwing an exception would be reasonable. We will not test you on\n    this case.\n        Lastly, parseRString should collapse any contiguous sequences of whitespace into a single\n    space. For example, suppose you are given an istream containing:\n    1\n\n    2\n    + }\n\n    The two consecutive newlines between 1 and 2 should be replaced by a space as well as the single\n    new line between 2 and +. The correct output string would be:\n    { 1 2 + }\n\n\n\n    Integrating parseRString in Your Code\n        Note that we’ve given you the declaration for parseRString, but it’s up to you as to how you\n    integrate it into your code for part ii. You have a few options, but we recommend:\n\f   • Keep the function in a file named parser.cpp (remove main.cpp from this file if it’s there\n     from part i)\n\n   • Include parser.h to the top of whichever file that uses the parseRString function.\n\n   • Add a rule to compile your parser.cpp to parser.o\n\n   • Make sure to add parser.o to the linking step in your Makefile.\n\n\n\n\ncylc and cyl files\n\n   RPNCalc runs on files with extension .cylc. For example, if you have a sequence of commands\nsaved in my_example.cylc, you can execute them by either:\n   • Sending the file to program’s standard input (cin) using <\n     (e.g. ./CalcYouLater < my_example.cylc)\n\n   • Pushing the rstring “{ my_example.cylc }” on to the stack, then using the file command.\n\n.cylc files can be tricky to read and understand. Thus, you can also use .cyl files, which allow\nyou to add comments. In .cyl files, comments begin with the character %. Because RPNCalc does\nnot support comments, you must then convert the .cyl file to a .cylc file. We have given you a\nprogram called cylc that does this for you (it stands for “CalcYouLaterCompiler”).\n    As examples, we have provided you with four .cyl files in the starter code: add.cyl carries\nout some simple additions, fact.cyl implements the factorial function using RPNCalc commands,\nfib.cyl implements the Fibonacci function, and fib_debug.cyl uses Fibonacci to demonstrate a\nway to debug RPNCalc programs. Take a look at these files and the comments within them! They\nwill be a useful reference when it comes time to test your program.\n    In order to convert the above files to .cylc files that can actually be run, use the cylc program\nwe have provided you. For example, you can run ./cylc fact.cyl. This will create a new file\ncalled fact.cylc, which contains no comments or blank lines, and which can therefore be run by\nCalcYouLater.\n    You can see a video showing how to use the cylc program and make here: https://asciinema.\norg/a/zJ6yilB6daCFaaJqUzBpkdVBV\n\n\n\n\nImplementation Notes and Advice\n\n   You will write both the DatumStack and RPNCalc classes from scratch. They will each have two\nfiles associated with them - a .h file and a .cpp file. In addition to the public interfaces for the\nclass defined above, you are free to add any private member functions / variables that you wish.\n\n       • The names of your functions / methods as well as the order\n         and types of parameters and return types of the interface of\n         the DatumStack and RPNCalc classes and the parseRString\n         functions defined above must be exactly as specified. This is\n         important because we will be compiling and linking the code\n         you wrote with our own client code!\n\n       • Any print statements or exception messages should likewise\n         print exactly as specified and use the given error type.\n\n       • For the two classes, you may not have any other public func-\n         tions.\n\n       • All data members must be private.\n\n       • You may not use std::stack or any other built-in facility that\n         would render the assignment trivial.\n\n\nNotes Regarding the Starter Code\nTo get the starter materials, run the following command, which will give you copies of a few files\nplus links to Datum.h, Datum.o, and theCalcYouLater reference implementation.\n/comp/15/files/proj_calcyoulater/setup\n\nNote - do not manually copy the files, just run the command.\n\n   • The file cyl design checkoff.txt contains some questions that you must answer and submit\n     prior to your design checkoff.\n\n   • The file Datum+vector_example.cpp in the starter code demonstrates the basic usage of the\n     Datum class.\n\n   • The files RPNCalc.h and RPNCalc.cpp. You will need to implement your program via an\n     RPNCalc class as described above. RPNCalc.h is empty. RPNCalc.cpp contains a function\n     got_int that can test whether a string can be interpreted as an integer, and, if so, what\n     the value of the integer is. You may use this function as-is. You should understand how\n     the parameter works, but you do not need to know the details of the implementation. You\n     must use this function to check and convert a string to an integer - do NOT write your own\n     function to implement this conversion.\n\n   • The binary file theCalcYouLater is a reference implementation that you may refer to to help\n     you understand what you are supposed to do, and to help you test your own implementation.\n     To familarize yourself with the reference, start by running:\n             ./theCalcYouLater\n             4 5 + print\n\n  • The other files are described further in other sections\n\n    Sometimes strange things happen with Datum.o. For example, students may accidentally try to\nre-compile the file or add an incorrect (and unnecessary) Makefile rule for it. If you see something\nweird going on with Datum.o, copy the original file back into your directory with:\ncp /comp/15/files/proj_calcyoulater/*.o .\n\nThis is generally the first thing a TA would try.\n\n\nFiles to Submit\nThe following files for this assignment will be written from scratch:\nDatumStack.h\nDatumStack.cpp\nRPNCalc.h\nRPNCalc.cpp\nmain.cpp\nREADME\nMakefile\n\nYou must also submit:\n\n   • Any unit tests you write for your program. This may be done in a file called unit_tests.h,\n     using the unit_test framework that we have used on past assignments. Alternatively, you\n     can create your own testing main functions, e.g., submit a file called DatumStack_tests.cpp\n     with a main function that calls out to tests. Whatever testing files you use, you must submit\n     them!\n\n   • Any command files (.cyl files that you used for testing, i.e., files that you ran with RPNCalc\n     using the file command). You should have some command files!\n\nThe files DatumStack.h and RPNCalc.h will contain your class definitions only. The files DatumStack.cpp\nand RPNCalc.cpp will contain your implementations. main.cpp will contain your main calculator\nprogram. The Makefile will contain the instructions for make to compile your program. README\nwill have the sections described in README Outline section below.\n\n\nDatumStack Implementation\nImplement DatumStack however you like. We suggest using a LinkedList or an ArrayList as\ndiscussed in class. You may use std::vector or std::list but you must NOT use std::stack.\n\n\nOther Tips\n*DO NOT IMPLEMENT EVERTHING AT ONCE!*\n*DO NOT WRITE CODE IMMEDIATELY!*\nBefore doing anything, use the the reference program to get a sense of how things work. This may\nseem like a lot, but if you break it into pieces, it’s perfectly manageable. Before writing code for\nany function, draw before and after pictures and write, in English, an algorithm for the function.\nOnly after you’ve tried this on several examples should you think about coding.\n\fCONTENTS                                                                                           17\n\n\nGetting Started\nTo get up and running,\n\n  1. create the two files for the classes DatumStack and RPNCalc\n\n  2. start filling in the .h file\n\n  3. #include the .h file in the .cpp file\n\n  4. define an empty main function in a main.cpp file (just return 0)\n\n  5. compile!\n\nIf you start with the DatumStack class (follow a similar pattern if you start with the RPNCalc class):\n\n  1. Implement just the default constructor first. Add a single variable of type DatumStack to\n     your test main function; compile, link, and run.\n\n  2. Now you have some choices. You could add the destructor next, but certainly you should add\n     a print function for debugging soon. Make it private before submitting.\n\nYou will add one function, then write code in your test file that performs one or more tests for\nthat function. Write a function, test a function, write a function, test function. . . Follow the same\ntesting approach for every class you write, and add functionality little by little.\n    For the RPNCalc class, the first version of the run() function should accept only the quit\ncommand. Then it should read any number of items, just printing them, until there’s a quit or\nuntil reaching end of file. Then start to add items bit by bit. Add numbers, and print the stack to\nmake sure they get on the stack correctly. Then add the operators one at a time, comparing your\nresults with the reference. Do the file command last.\n    You may want to refactor your program when you get to the file command; don’t duplicate\nthe command logic in two places. If you pass file streams around, you should do so using C++\nreference parameters.\n    If you need help, TAs will ask about your testing plan and ask to see what tests you have\nwritten. They will likely ask you to comment out the most recent (failing) tests and ask you to\ndemonstrate your previous tests.\n\n\nMakefile\nWe have given you a Makefile that knows how to make .cylc files from .cyl files, but you must fill\nin the rest. Your CalcYouLater program must build when we run make CalcYouLater, and must\nproduce an executable named\n“CalcYouLater” which can be run by typing ./CalcYouLater.\n\n\nREADME\nWith your code files you will also submit a README file. You can format your README however you\nlike. However it should have the following sections:\n\n  A The title of the homework and the author’s name (you)\n\fCONTENTS                                                                                       18\n\n\n  B The purpose of the program\n\n  C Acknowledgements for any help you received\n\n  D The files that you provided and a short description of what each file is and its purpose\n\n  E How to compile and run your program\n\n   F An “architectural overview” i.e., a description of how your various program modules relate.\n\n  G An outline of the data structures and algorithms that you used. Given that this is a data\n    structures class, you need to always discuss the ADT that you used and the data structure\n    that you used to implement it and justify why you used it. Please discuss the features of\n    the data structure and also include (with some justification/explanation) two other situa-\n    tions/circumstances/problems where you could utilize it. The algorithm overview is always\n    relevant. Please pick a couple interesting/complex algorithms to discuss in the README\n\n  H Details and an explanation of how you tested the various parts of assignment and the program\n    as a whole. You may reference the testing files that you submitted to aid in your explanation.\n\n   I Tell us how much time you spent, in total, on this assignment in hours.\n\nEach of the sections should be clearly delineated and begin with a section heading describing the\ncontent of the section. You should not only have the section letter used in the outline above.\n\n\nSubmitting Your Work\nBe sure your files have header comments, and that those header comments include your name, the\nassignment, the date, and acknowledgements for any help you received (if not already credited in\nthe README file).\n    For phase 0, submit your complete cyl design checkoff.txt file to the assignment “CalcY-\nouLater Design Checkoff” on Gradescope.\n    For phase 1, you will need to submit at least the following files:\n    DatumStack.h, DatumStack.cpp\n    parser.h, parser.cpp\n    README\n    unit_tests.h\n    You should only include other C++ files if your solution to DatumStack or parseRString depend\non them. Do not submit RPNCalc.cpp for example. You must submit them using Gradescope to the\nassignment proj_calcyoulater_phase1. Submit these files directly, do not try to submit them\nin a folder. Don’t forget to include your rstring parser code. The README doesn’t have to be\nthe final README. Just document anything that you feel we should know about your DatumStack,\nparser, or the project in general.\n    For the final submission, you will need to submit at least the following files:\n    DatumStack.h, DatumStack.cpp\n    RPNCalc.h, RPNCalc.cpp\n    main.cpp\n    Makefile\n    README\n    unit_tests.h\n    ...\n   You must also submit:\n\n   • Any unit tests you write for your program. This may be done in a file called unit_tests.h,\n     using the unit_test framework that we have used on past assignments. Alternatively, you can\n     create your own testing main functions, e.g., submit a file called CalcYouLater_tests.cpp\n     with a main function that calls out to tests. Whatever testing files you use, you must submit\n     them!\n\n   • Any command files (excluding the command files provided).\n\n    You must submit them using Gradescope to the assignment proj_calcyoulater. “. . . ” means\nany other files necessary to build your program as well as any test code (e. g., .cyl files) you would\nlike us to see. For example, if you have another class, you should provide the .h and .cpp files\nfor that class. You do not need to submit any provided files (Datum.h, Datum.o). You also do not\nneed to submit any output files from your testing (e.g. stdout or stderr files). Just the input\ncommand files is fine. You do not need to submit both the .cyl and .cylc variants of the same\ntest cases.\n\n    Before submitting your work, please make sure your code and documentation (including sec-\ntions of the README) conform to the course style guide.\n\nCalcYouLater!\n\f",
    "PROJECT GERP\n\nTime and Space Constraints\nWhen designing and implementing your program you should have it build its index and run queries\nas quickly as possible. You may find that there is a trade-off between the two (e.g. a program that\nbuilds an index quickly may not search as fast). It is important to document your design choices,\nyour justification of those choices, and their effects in your README.\n    To get full credit, your program will need to be able to index and run queries on the following\ndirectories within the following amounts of time:\n\n   • tinyData under 15 seconds\n\n   • smallGutenberg under 15 seconds\n\n   • mediumGutenberg under 2 minutes\n\n   • largeGutenberg under 8 minutes\n\nRoughly, this means your solution can be about 15 times as slow as the reference (which already is\nnot the best solution). Furthermore, your program can use a maximum of 6 GB of RAM. If you\ntake too much time or use too much memory on a test, you will not receive points for that test.\n   You should check the time and memory usage of your program using the following command:\ngerp_perf [DirectoryToIndex] [OutputFile]\n\nThis command will display your program’s memory usage and execution time of building the index.\nIt will also display these metrics for the reference implementation. [OutputFile] will store the\nnon-cout output of your program as usual. Note, to use this program, you will need to have added\nuse -q comp15 to your .cshrc file as you would have done to use unit_test.\n    Before submitting to Gradescope, please make sure you have run your implementation on larger\ndirectories. If Gradescope times out during a submission, it likely means your implementation is\ntoo slow so it is good to get it working decently well before submitting. If Gradescope times out,\nit will still count as a submission which we generally will not give back.\fReference Implementation and\nTesting\n\nIntroduction\nIn order to help you with your testing and to get familiar with the user interface expectations of\nthis project, we have provided you with a fully compiled reference implementation called the_gerp.\nBy the end of the project your gerp implementation should behave exactly the same as the_gerp.\nYour version of gerp should behave exactly as the reference in all circumstances.\nTherefore, you should extensively test the reference in order to figure out how it\nbehaves.\n\n\nTesting Directories\nIn order to help you test your implementation, we have provided you with some directories. The\nfolder /comp/15/files/proj-gerp-test-dirs contains all of the relevant directories, which are\n\n   • A Directory tinyData, which you can use to quickly test your work.\n\n   • Small, medium and large subsets of Project Gutenberg. These are samples from a massive\n     free online library—for more information on this, see the Project Gutenberg Website. In-\n     dexing/querying the medium/large subsets will give you a chance to test the time and space\n     efficiency of your code. For this datasets, be sure that your submission matches the expecta-\n     tions described earlier (indexing in under 10 minutes, no more than 6GB memory usage).\n\nNote: This directory contains all the testing directories, so you should not copy it. It is\nlarge and will take up your storage quota. Instead, gerp takes a directory as a command\nline argument, so you don’t need the directory locally; just run gerp specifying, e. g.,\n/comp/15/files/proj-gerp-test-dirs/mediumGutenberg and the program should work!\n\n\nRedirecting Input/Output in unix\nIn order to test your implementation against the reference, using redirects to send input files to\nand from your program and the reference will be useful. To send data to the std::cin of a unix\nprogram, do the following:\n./programname < fileforcin.txt\n\nIn our case, gerp takes multiple arguments: a directory to query, and a file to send the program’s\noutput to. So, to send a file to the reference implementation’s std::cin, you would do:\n\n                                               11\n\f./the_gerp Directory ref_output.txt < commands.txt\n\nThis command will send commands.txt to the standard input stream for the reference implemen-\ntation. You can likewise do the same with your implementation. In order to redirect a program’s\nstd::cout to a file, do the following:\n./programname > fileforcin.txt\n\nAgain, in our case,\n./the_gerp Directory ref_output.txt > ref_std_out.txt\n\nTo combine redirection of input and output, you can do the following:\n./the_gerp Directory ref_out.txt < cmds.txt > ref_std_out.txt\n\nRecall that, even though gerp sends most data to the the output file, it will send some to std::cout\n- namely, the Query? lines, which will then be redirected to, in this case, ref_std_out.txt.\n\n\nUsing Diff\nOnce you have run the same input on the reference and on your implemenation, you can test that\nyour and the reference’s outputs (the contents of ref_out.txt above) are equivalent by:\n\n  1. Sorting the output\n\n  2. Using diff to compare the sorted files\n\nSorting is necessary because, while your program must produce output for all occurances of the\nquery, the order in which multiple lines appear is not specified. Print out multiple lines in whatever\norder your data structure and algorithm choices find convenient. To sort the output, you can use\nthe unix sort command.\nsort ref_output.txt > ref_output_sorted.txt\nsort my_output.txt > my_output_sorted.txt\n\nAfter sorting, use the diff command to find any differences. For example:\ndiff ref_output_sorted.txt my_output_sorted.txt\n\ndiff will print the differences in the file, if there are any. If nothing prints out, then the files are\nidentical.\n    Keep in mind that, to compare the redirected std::cout streams of your implementation and\nthe reference, you should not sort the output files before running diff.\n\n\n\n\n                                                  12\n\fREADME\n\nYou will be required to submit a README along with your code. Your README should have the\nfollowing sections:\n\n  A The title of the homework and the author names (you and your partner)\n\n  B The purpose of the program\n\n  C Acknowledgements for any help you received, including references to outside sources you\n    consulted (though there is no need list C++ references like cplusplus.com).\n\n  D The files that you provided and a short description of what each file is and its purpose\n\n   E How to compile and run your program\n\n   F An “architectural overview,” i.e., a description of how your various program modules relate.\n     For example, the FSTree implementation keeps a pointer to the root DirNode.\n\n  G An outline of the data structures and algorithms that you used. Given that this is a data\n    structures class, you need to always discuss any data structures that you used and justify why\n    you used them. For this assignment it is imperative that you explain your data structures\n    and algorithms in detail, as it will help us understand your code since there is no single right\n    way of completing this assignment.\n\n  H Details and an explanation of how you tested the various parts of your classes and the program\n    as a whole. You may reference the testing files that you submitted to aid in your explanation.\n\n   I. Please let us know approximately how many hours you spent working on this project. This\n      should include both weeks one and two.\n\nEach of the sections should be clearly delineated and begin with a section heading which describes\nthe content of the section.\n\n\n\n\n                                                13\n\fSubmitting Your Work\n\nYou will be submitting your work in 2 parts:\n\n\nPart 1: Design, FSTree, and String Manipulation\nDesign\nAs part of your design checkoff, you must do two things:\n\n  1. Provide answers to the questions in the file gerp_design_checkoff.txt, included in the\n     starter files. When you’re done, submit your answers to the assignment titled “gerp Design\n     Checkoff” on Gradescope. You must submit this file prior to your design checkoff\n     meeting (described below).\n\n  2. Sign up for an in-person design checkoff meeting with a TA. Both you and your partner must\n     attend the meeting. You can find the design checkoff form linked here. At that meeting,\n     among other things, you will be required to address the answers that you submitted with\n     your design checkoff questions. You should also bring drawings that capture your design.\n\nFSTree and String Processing\nTo complete this part you will need to write 2 functions:\n\n  1. a directory traversal function that prints out the full paths of each file in the tree on separate\n     lines\n\n  2. a function that strips all leading and trailing non-alphanumeric characters from a given string\n\nDirectory Traversal\nYou will be implementing this in traverseDirectory in processing.h and processing.cpp. The\nfunction takes a directory as an argument and then prints the full paths of all the files accessible\nfrom that directory. Do not worry about the order that the file paths print in, just ensure that\neach one of them prints. For example, if you have a directory named Foo, with:\n\n   • files a.cpp, b.cpp, and c.cpp inside it\n\n   • a subdirectory Bar, with:\n\n         ◦ files x.cpp, y.cpp, z.cpp\n\nThen one possible output for running traverseDirectory(Foo) would be:\n\n\n                                                 14\n\fFoo/Bar/x.cpp\nFoo/Bar/y.cpp\nFoo/Bar/z.cpp\nFoo/a.cpp\nFoo/b.cpp\nFoo/c.cpp\n\nAgain, the order here does not matter. You may assume that the directory name has no trailing /.\n\nString Manipulation\nYou will be implementing this in stripNonAlphaNum in processing.h and processing.cpp. The\nfunction takes a string and removes all leading and trailing non-alphanumeric characters. For\nexample, when stripNonAlphaNum(\"@##!!#!@!#COMP-15!!!!!!!\") returns \"COMP-15\".\n\nPart I README\nYour README does not need to contain everything we normally ask for. For this phase, you can just\nwrite a very brief summary with any infromation you’d like the grader to see (e.g. if you have a\nnettlesome bug you have not yet been able to fix). Additionally, make sure to write both author’s\nnames (i.e., you and your partner).\n\nSubmitting Phase 1\nNote: Only one of you or your partner should submit your code each time you submit\n– otherwise you may receive a grade for the wrong submission. Make sure both names\nare in the submitted README. You will need to submit at least the following files:\n      processing.h\n      processing.cpp\n      README\n   You should only include other C++ files you write if your solution to stripNonAlphaNum or\ntraverseDirectory depend on them. You do not need to submit DirNode or FSTree. You must\nsubmit them using Gradescope to the assignment proj_gerp_phase1. Submit these files directly,\ndo not try to submit them in a folder. Make sure to add your partner on Gradescope each\ntime you submit.\n\n\nPart 2 - Final Submission\nFor this part you will submit all of the files required (including a Makefile) to compile your gerp\nprogram. Make sure to include any testing files. Once again, only one of you or your partner\nshould submit each time you submit. Furthermore, make sure you add your partner\nfor each submission. You will need to submit the following files:\n      Makefile\n      README\n      (... all the C++ .h, .cpp files that implement your program)\n      (... all your testing files)\n   You must also submit:\n\n\n                                                15\n\f   • Any unit tests you write for your program. This may be done in a file called unit_tests.h,\n     using the unit_test framework that we have used on past assignments. Alternatively, you\n     can create your own testing main functions, e.g., submit a file called Gerp_tests.cpp with a\n     main function that calls out to tests. Whatever testing files you use, you must submit them!\n   • Any command files (excluding the command files provided).\n   • Note, you only need to include testing input files. You do not need to include output files of\n     any kind (stdout or stderr).\n    You should submit your final implementation to the assignment proj_gerp on Gradescope.\n    Note: Make sure you submit everything we will need to run your program. Maybe copy the files\ninto another directoy, type make test the program, do a make clean and then submit everything.\nWe should be able to use make or make gerp to build your program. You do not need to submit\nany provided files (FSTree.h, FSTree.o, DirNode.h, DirNode.o).\n\n   Note, you only need to include testing input files. For example, files you are searching or files\nwith queries. You do not need to include output files of any kind (stdout, stderr, or output files\nwhere you store the file:line occurrences of words).\n\n    Before submitting your work, please make sure your code and documentation (including sec-\ntions of the README) conform to the course style guide.\n\n\n\n\nHelpful Tips\n\nTesting\nWe will test your solution on several directories, including smallGutenberg and mediumGutenberg\nand largeGutenberg. You can see some test queries and reference implementation output in\n/comp/15/files/proj-gerp-sample-execution. You should match this output exactly (except\nthat the order can be different as explained above).\n\n\nHashing and Hash Tables\nThere are example uses of the std::hash facility in the files we’ve given you. See hash_test.cpp\nand hashExample.cpp. If you use a hash table, then you MUST have it dynamically resize. You\nmust monitor the load factor and expand if the load factor is exceeded.\n\n\nRuntime\nThe runtime of your query processing must depend on the size of the output, not on the size of the\ninput (that is, the index structure should be very close to constant time to search).\n\n                                                16\n\fSpace\nFinally, space usage will be an issue. Your program will have enough memory to store all the data\nin the largeGutenberg collection once or twice, but not 5 or 6 times. If you are not cognizant of\nspace usage, then your program will work fine for the small or maybe even the medium collection,\nbut will fail on the large collection when it runs out of memory. You might find the provided\nfile exceedmem.cpp helpful regarding memory issues; it shows different examples of situations you\nmight encounter when attempting to allocate too much memory.\n     If you are stuck, then you should get something that at least works correctly on the small data\ncollections. To work on larger collections, you will need to choose a strategy that considers space.\n\n\nHints\n   • Hint: Every copy of a string requires space proportional to the length of the string. (An\n     std::string is an ArrayList of characters.)\n\n   • Hint: Do not store a pointer to an element in a vector. A good final exam question\n     would be: “Why should you not store the address of an element in a vector?” An std::vector\n     is an ArrayList, remember.\n\n   • Hint: Pay attention to how you pass variables to functions. For example, consider the follow-\n     ing two function signatures:\n     void foo_a(string word)\n     void foo_b(string &word)\n     Passing a string to foo_b, which uses a reference parameter, will be more space and time\n     efficient than passing a string to foo_a. See why? Leverage this to your advantage!\n\n\n\n\n                                                17\n\f",
    "CS 15 Project 1: A Metro Simulator                                                                           2\n\fIntroduction\n\nThe Green Line has come to Tufts! In this assignment, you will create a program that simulates action\non the Green Line. Your program will monitor a train as it travels a simplified course of the Green\nLine Extension, and will manage Passengers as they board and depart at specified stops along the\nway.\n   The primary, high-level tasks for this assignment are as follows:\n   • Create an interactive front-end simulation that works with both files and the command line\n   • Design and develop an object-oriented approach to solving the back-end logic for the simulation\n   • Seamlessly connect the front-end and back-end systems\n    A few words of caution: The training wheels are off! There are some requirements (see below)\nfor your implementation, but we have given you considerably more freedom to architect your solution\nto this problem than in previous assignments. This is a double-edged sword! To succeed, it would\nbe wise to read the following spec thoroughly and to start designing a solution as early as possible.\nThis will give you time to go to office hours to discuss your plan with the course staff before you start\ncoding. This program can be done with less code than the previous assignment if you have designed\nyour program well.\n\nDeliverables    There are multiple phases of deliverables for this assignment:\n   • Week one:\n         - Design checkoff.\n         - The code for your Passenger and PassengerQueue classes.\n   • Week two: Your final MetroSim program.\n   Continue reading to learn more about these deliverables!\n\n\n\n\nSimulation Overview\n\nData Abstraction\nYour design choices will be of chief importance in this project. It is your responsibility to plan out\nhow you will build and utilize various components of the simulation. These components include:\n   • Passengers, which must contain:\n\n        ◦ an id\n        ◦ a starting station\n        ◦ an ending station\n\n   • PassengerQueues, which contain Passengers who are waiting to board or depart from trains.\n\n   • A list of Stations.\n\n   • the Train, which carries Passengers between Stations.\n\n    While it may not be obvious at first how to model these components, we will give you some\nguidelines to help you establish the architecture of your MetroSim program. We don’t require every\nitem in the list to be its own class, so it will be up to you to decide how each component is to be\nmodeled. However, we do require that you represent the Train as a list of PassengerQueue\nobjects, where each PassengerQueue represents a train station. But more on that later.\n    Note: You may find yourself confused. This is okay! You might want to refresh your memory\nabout abstraction, classes in C++, etc. We strongly suggest that you head over to the reference page,\nwhere there is a lot of great material on these topics. Also, there is a lot of information in the\nupcoming sections which should help clarify the points above. Head back here after reading through\nthe document to begin designing your solution.\n\n\nUser Interface\nAlso critical to this project is the implementation of the user-facing (front-end) interface. That is to\nsay, the user will interface with this program through the command-line, and it is your responsibility\nto implement the logic for that interface correctly. More detail will be provided later, but here is a\nbrief overview of how the program will work:\n\n   • The user will start MetroSim, and provide (among other things), a list of stations. This list will\n     be in a file which MetroSim will process.\n\n   • Once you have initialized the simulation based on the provided material, MetroSim will process\n     a series of commands, which will be fed to the program in one of two ways:\n\n        1. By a file (provided at the program’s start along with the station list)\n        2. Through standard input, aka std::cin, which is the default if no file is provided.\n\n   • Every command will perform one of the following operations:\n\n        ◦ Add a passenger to the simulation\n        ◦ Move a train to the next stop\n        ◦ End the simulation\n\n   • After every command, MetroSim will (1) print an updated view of the train and Stations to\n     std::cout, and (2) print a list of passengers that have left the train to a file specified by the\n     user at the start of the program.\n\n   • When either no more input can be read from a file, or the user inputs the m f command, the\n     simulation terminates successfully (and with no memory leaks!!).\n\nProgram Details\n\nProgram Design\nNote: you should carefully consider your design and implementation plan before writing any code.\nIn fact, we require you to come to office hours to review your design and implementation plan before\nwriting any code (continue reading for details).\n\n\nThe Passenger\nWe have provided you with the interface for a Passenger object (within Passenger.h). You must use\nthis Passenger interface, and you may not modify the contents of Passenger.h besides the header\ncomment.\n    You must implement the print function for the Passenger interface within the provided imple-\nmentation file (Passenger.cpp). The Passenger print function should format output as follows:\n[PASSENGER_ID, ARRIVAL->DEPARTURE]\n\nwhere\n   • PASSENGER_ID is the Passenger’s ID (each Passenger receives a unique consecutive id number,\n     starting at 1).\n   • ARRIVAL and DEPARTURE are the station numbers of the arrival and departure stations, respec-\n     tively.\n   Note: The format in which you print must match the above line exactly. Note that there is a space\nbetween ARRIVAL and the preceding comma, and that when each passenger is printed, there should\nbe no additional whitespace outside the square brackets. Also note that any boxes surrounding output\ntext in this document are not to be included in your output - they are just here to help highlight the\ntext.\n\n\nThe PassengerQueue\nYou’re required to write a PassengerQueue class from scratch that implements exactly the following\ninterface:\n   • Passenger PassengerQueue::front()\n     Returns, but does not remove, the element at the front of the queue. You may throw an error if\n     this function is called on an empty queue, but you are not required to do so.\n   • void PassengerQueue::dequeue()\n     Removes the element at the front of the queue. You may throw an error if this function is called\n     on an empty queue, but you are not required to do so.\n   • void PassengerQueue::enqueue(const Passenger &passenger)\n     Inserts a new passenger at the end of the queue.\n   • int PassengerQueue::size()\n     Returns the number of elements in the queue.\n   • void PassengerQueue::print(std::ostream &output)\n     Prints each Passenger in the PassengerQueue to the given output stream from front to back,\n     with no spaces in between and no trailing newline. For example:\n     [1, 1->2][2, 1->3][3, 2->3][4, 2->3]\n\n\n    Make sure your PassengerQueue interface matches the interface listed above exactly. You may\nnot add any other public functions. You must use either std::vector or std::list to implement\nthis class.\n    Note: By default, C++ will define a nullary constructor and the Big Three for you.\n    The code for your Passenger and PassengerQueue classes will be due at the end of week one,\nalong with your design checkoff.\n\n\nThe Train and The Stations\nAs stated in the program overview, you are required to implement your train as a list of PassengerQueue\ninstances (each element of the list is a PassengerQueue). Upon boarding the train, each passenger\nis organized into a PassengerQueue based on their destination. See the image below for a visual\nrepresentation of the Train.\n   You may find that you will need to represent “lists” of various data types. For this, we require\nthat you use std::vector or std::list, since it will greatly reduce how much code you’ll need to\nwrite/rework, although you may need to do a little reading before you get started.\n\f    The std::vector and std::list documentation on https://www.cplusplus.com is a great re-\nsource. If you feel that this reference is too verbose for your taste, feel free to seek out additional\nresources. As always, any material that you use (including reused code from this class) should be\nnoted in the Acknowledgements section of your README.\nProgram Flow\n\nRunning From the Command Line\nYou will write a program called MetroSim that accepts either 2 or 3 command-line arguments (in\naddition to the program name), like this:\n./MetroSim stationsFile outputFile [commandsFile]\n\nwhere:\n   • stationsFile is an input file containing names of the Stations, one per line\n\n   • outputFile is the file to send simulator output to\n\n   • commandsFile (optional) is a second input file containing commands to execute. If this parameter\n     is not given, then you should read input from std::cin. Note: it’s a common convention to\n     denote optional parameters by putting them in square brackets.\n    If the program is invoked with a different number of parameters you should quit execution by\nreturning EXIT_FAILURE after printing the following message to std::cerr:\nUsage: ./MetroSim stationsFile outputFile [commandsFile]\nInitialization\nIn the initialization phase you will open the stationsFile and process any Stations you find. The\nstationsFile is in plain text, with one Station name per line. You may assume the stationsFile\nhas at least two Stations, and each Station’s name is a string of at least one character. Station\nnames may be more than one word, e. g., “South Station”.\n     Note: do not worry about malformed files. We will not test your program with empty Station\nfiles or files with duplicate Station names, etc. Just program assuming any input files are correctly\nformatted. You do, however, have to handle cases in which a file cannot be opened (see below for the\nspecific message and behavior).\n     After you have finished processing the stationsFile, print the Stations you have just read\n(output specifications are below). Remember to place the Train at the first Station. Initially, there\nare no Passengers in the Train or at any Station.\n     If your program cannot open any of the provided file(s), you should quit by returning EXIT_FAILURE\nand print the following error message to std::cerr\nError: could not open file FILENAME\n\n\nwhere FILENAME is the name of the file that could not be opened.\n\n    We have given you sample Station and command files (stations.txt and test_commands.txt,\nrespectively). We will test your code with others, and you should make other similar files for your\nown testing, e.g., on a shorter list of Stations or with a sequence of commands that causes particular\ncode in your program to run for test purposes.\n\n\nControlling the Simulation\nMetroSim will accept input from either a commandsFile that contains a list of commands, or from\nstd::cin if no commandsFile was given.\n   Commands are case sensitive. You may assume input data is valid. (e.g., a Passenger will never\nwant to go to a Station with a negative number, etc. . . ). Your program can do anything in such\ncases (segfault, quit, be angry, etc.).\n   Your program will prompt on std::cout for a command by printing the text \"Command? \"), and\nthen will read a command in and process it. Your code will handle the following commands:\n\n   • p ARRIVAL DEPARTURE\n\n        ◦ The command p ARRIVAL DEPARTURE adds a new Passenger to the simulation who boards\n          at the ARRIVAL Station and departs at the DEPARTURE Station. ARRIVAL and DEPARTURE\n          are specified by a number (note that the first Station is Station 0).\n        ◦ Passengers are enqueued at the ARRIVAL Station.\n        ◦ Passengers should get consecutive IDs assigned in the order they arrive starting with the\n          number 1 (not 0). I. e., the first Passenger to ever arrive will have ID 1, the second one\n          ID 2, and so on.\n\n   • m m (metro move)\n\n        ◦ The command m m moves the Train from the current Station to the next one in the line.\n          The train should move to the first Station if it is currently at the last Station.\n        ◦ As the train leaves a Station, all Passengers at the departing Station will get on the\n          train, regardless of which Station the Passengers are going to. They board in the same\n          order as they arrived at that Station.\n        ◦ When the Train arrives at a Station, any Passengers whose final destination is that\n          Station will exit the Train and the Station—you can remove them from your simulator.\n          Exiting passengers will not be included in the next state of the simulation printed to\n          std::cout (i.e., passengers exit then we print the state), however, their exit will be logged\n          in the output file...\n        ◦ For each Passenger that exits at a Station, the following line should be written to the\n          output file (not std::cout), followed by a single newline:\n          Passenger ID left train at station STATION_NAME\n\n          replacing ID and STATION_NAME with that Passenger’s ID and the Station’s name, respec-\n          tively.\n        ◦ Note: You may notice that the list of Stations is circular; that is, when the train reaches\n          the bottom of the list, it returns to the top. We recognize that you have recently learned\n          about a particular circular data structure, but it’s up to you to determine whether it’s\n\fCONTENTS                                                                                             9\n\n\n          necessary to use. Be sure to consider the use cases of the data structures you implement\n          and whether they apply to the program you build. (Feel free to check in with a TA if you’re\n          confused about this note!)\n\n   • m f (metro finish)\n\n        ◦ The command m f should terminate the simulation, as described in the Ending the Sim-\n          ulation section.\n\n\nPrinting the State of the Simulation\nYou should print the state of the simulation (described below) after each command that runs, according\nto the following format:\n\n  1. Print the text “Passengers on the train:” followed by a space, followed by a curly brackets\n     enclosed list of passengers on the train, followed by a newline.\n\n  2. For each station on the train line, print:\n\n      (a) TRAIN: followed by a space if the train is currently at that Station, otherwise print seven\n          spaces.\n      (b) The Station number enclosed in square brackets, followed by a space.\n      (c) The Station name, followed by a space\n      (d) A curly brackets enclosed list of the passengers currently waiting at the Station, followed\n          by a newline.\n\nWhenever you print a Passenger, you should follow the format described in The Passenger section\nabove.\n   Example output for train line with 4 Stations, where the Train is currently at Station 1:\nPassengers on the train: {[1, 0->2][2, 0->3]}\n      [0] station_0 {}\nTRAIN: [1] station_1 {}\n      [2] station_2 {[3, 2->3][4, 2->3]}\n      [3] station_3 {}\n\nNote that Passengers on the Train are in ascending order based on the destination Station. If\nthere’s a tie, the Passenger that boarded the train first will precede the Passenger that boarded\nafterwards.\n    You can assume that each Station’s name has at least one character, and that there will be at\nleast two Stations provided.\n    Note: follow the format exactly, including spaces. We strongly encourage you to run the diff\ncommand to compare the output of your solution with that of the reference implementation. Refer to\nthe Testing section for more information.\n\n\nEnding the Simulation\nIf your program runs out of commands in the input (end of file is reached) or the command m f is given,\nyour program should print the following text to std::cout, followed by a single newline and terminate:\n\nThanks for playing MetroSim. Have a nice day!\n\fAlways remember to deallocate all previously heap-allocated memory and close all previously opened\nfiles before your program terminates!\n\n\nSpecial Note: File Input vs. std::cin\nWhen you look at your program’s output, be aware that it will look differently depending on whether\nthe input comes from std::cin or from a commands file. When a user types at the terminal, there\nwill be a newline when they press “enter” to enter input, but no newline will be there if you take input\nfrom a file. See the examples below.\n\nstd::cin Example\n\nCommand? m m\nPassengers on the train:\n\n\n\nFile Input Example\n\nCommand? Passengers on the train:\n\nWe are aware of this difference (indeed, you will notice that the_MetroSim behaves that way). This\ndifference is expected, and you will not need any code to try to “correct” this.\n\n",
    "             CS 15 Project 3: zap\n\nOverview\n\nIntroduction\nCompression is the process of reducing the number of bits needed to represent some data. We rely on\nit all the time: when we stream music and movies, talk to someone on Zoom, or even access a web\npage. It’s likely that you’ve compressed data before into a .zip file — maybe to send that data to\nsomeone via email, or maybe just to save some space on your hard drive.\n    For this assignment, you will be writing your own compression program called zap! Your pro-\ngram will specifically be used for compressing and decompressing text files using the Huffman coding\nalgorithm.\n\n\nRunning zap\nzap can be run in just two ways: you can zap (compress) a file, or unzap (decompress) a file. To zap,\nfrom the command line run:\n./zap zap inputFile outputFile\n\n    This will take the ASCII text file named inputFile, compress it using the Huffman coding algo-\nrithm, and store the result in a file named outputFile. It will also print to cout a message that looks\nas follows:\n    Success! Encoded given text using N bits.\nwhere N is the size in bits of the encoded text.\n    To unzap, simply run:\n./zap unzap inputFile outputFile\n\n   This will take the previously zapped file inputFile, decompress it, and store the resulting ASCII\ntext in outputFile. It will not print anything to cout.\n   And that’s it! There are no other ways to run zap, and unlike previous assignments, there is no\ncommand loop for this program.\n   An unzapped file’s contents should be identical to the originally zapped file, e.g., if you run\n./zap zap shakespeare.txt shake.zap\n./zap unzap shake.zap new_shakespeare.txt\n\nthen the files shakespeare.txt and new_shakespeare.txt should be identical — you can use diff\nto confirm this.\n    If you run zap incorrectly, either by using the wrong number of command line arguments or by\nproviding a first argument other than “zap” or “unzap”, then zap will print the following usage message\nto cerr:\n    Usage: ./zap [zap | unzap] inputFile outputFile\nthen return EXIT_FAILURE.\n   If you provide the name of an input file that cannot be opened, then your encoder function, or\none of its helpers, should throw a runtime_error with the error message:\nUnable to open file FILENAME\nwhere FILENAME is the invalid input file name, and the error message does not end with a newline.\nThe encoder function is described in detail below. If a user specifies an incorrect file in an invalid\ncommand, the invalid command error takes precedence.\n\n\nProgram structure\nYour program should include at least the following files:\n\n   • HuffmanCoder.h and HuffmanCoder.cpp. These files respectively define the interface and im-\n     plementation of the HuffmanCoder class, which comprises the main logic of the Huffman coding\n     algorithm. The class should have the following two public functions:\n     void encoder(const std::string &input_file, const std::string &output_file)\n\n\n     encoder takes a text file named input_file, compresses its text, and stores the result in a file\n     named output_file.\n     void decoder(const std::string &input_file, const std::string &output_file)\n\n\n     decoder takes a zapped file named input_file, decompresses it, and stores the resulting text\n     in a file named output_file.\n     You can optionally add a public constructor and destructor to the HuffmanCoder class, but you\n     are not required to do so. Any other functions that you add to this class must be private.\n\n   • main.cpp. This file includes your main function. It should process the command line arguments\n     (ensuring they are valid), and appropriately call either the encoder or decoder function of the\n     HuffmanCoder class.\n\n   • HuffmanTreeNode.h, ZapUtil.h, and their corresponding .o files: these files are provided by\n     us, and will be discussed in greater detail later in the spec.\n\n   You can choose to add any other classes/files to your program as you see fit.\n\n\nStarter Files\nTo copy the starter files, run the following command on the server:\n/comp/15/files/proj_zap/setup\n\nNote that you should not run cp.\n    In addition to the files mentioned above, a few more files are part of the starter code: ZapUtil.h,\nZapUtil.o, ZapUtilExample.cpp, and bad_zap_file. These files will not be part of your final\nprogram. Rather, we give them to you because they will be useful when testing your code. We\ndescribe them in detail in the Testing section on page 10 below.\n    Sometimes strange things happen with the provided object (.o) files. For example, students may\naccidentally try to re-compile the files or add incorrect (and unnecessary) Makefile rules for them. If\nyou see something weird going on with any of the provided .o files, copy the original files back into\nyour directory with:\n\ncp /comp/15/files/proj_zap/*.o ./\n\nThis is generally the first thing a TA would try.\nEncoder\n\n    There are two primary components of zap: the encoder, which encodes a given ASCII text file into\ncompressed binary code, and the decoder, which takes the compressed binary code and turns it back\ninto text.\n    We begin by discussing the encoder, the more involved of these components. The encoder comprises\nthe following stages:\n  (1) Counting character frequencies in the given text.\n\n (2) Building the Huffman tree.\n\n (3) Using the tree to generate character encodings.\n\n (4) Using the generated encodings to encode the given text in binary.\n\n (5) Serializing the Huffman tree.\n\n (6) Saving the serialized tree and encoded text in a file.\n\n    Each of these stages is discussed in greater detail below. How you implement this functionality is\nup to you. At a minimum, each stage should be placed in its own function—those functions may in\nturn be broken down into smaller functions. They may also be placed in or make use of other classes\nif you so choose.\n    Note that it is impossible to compress an empty file any further. In the case that the user asks\nyou to compress an empty file, your program should just print to stdout:\nFILENAME is empty and cannot be compressed.\nCounting Character Frequencies\nRecall that the Huffman algorithm compresses data by encoding more frequently occurring characters\nusing fewer bits. Thus, the first thing you must do is count the number of occurrences of each character\nin the given text. This count should include whitespace and punctuation characters, and it should\nseparately count different casings of a letter. For example, given the following two-line text:\nApple apple.\nBanana?\n\nThe counts you come up with should be as follows:\n\fCONTENTS                                                                                            5\n\n\n                                                ‘A’    1\n                                                ‘p’    4\n                                                 ‘l’   2\n                                                 ‘e’   2\n                                                 ‘’    1\n                                               ‘\\n’    1\n                                                ‘a’    4\n                                                ‘B’    1\n                                                ‘n’    2\n                                                 ‘?’   1\n                                                 ‘.’   1\n\n   Notice that the counts include whitespace characters.\n   How you store/represent these counts is up to you. You are welcome to use C++’s std::map or\nstd::unordered_map libraries. Alternatively, given that there are just 256 possible values of a char,\nyou may find it easy to represent counts using a more familiar data structure.\n\n\nBuilding the Huffman Tree\nOnce you have character counts, you can build your Huffman code tree. Recall that this is a binary\ntree where:\n\n   • Leaves correspond to characters.\n\n   • On the path from the root to a leaf, each left turn denotes a ‘0’ in a character’s code, and each\n     right turn denotes a ‘1’.\n\n   • Characters that occur less frequently should be further from the root, and characters that occur\n     more frequently should be closer to the root.\n\n   Review the lecture on Huffman coding for a refresher.\n\n   You should build the tree using the HuffmanTreeNode class which we define for you in the pro-\nvided files HuffmanTreeNode.h and HuffmanTreeNode.o. Take a look around the .h file. The\nHuffmanTreeNode class includes the following:\n\n   • A char member variable named val, which contains the character stored in the node. Because\n     internal nodes in a Huffman tree do not store characters, you can assign this field to the null\n     character ‘\\0’ for internal nodes.\n\n   • An int member variable named freq, which stores the character’s frequency for leaf nodes, or\n     the sum of the children frequencies for internal nodes.\n\n   • Two HuffmanTreeNode pointer fields left and right, for pointing to the children nodes.\n\n   • Two constructors which assign the corresponding member variables.\n\n   • A helper function isLeaf().\n\n   • Some getter and setter functions for the member variables.\n\n   You’ll also notice that HuffmanTreeNode.h includes the declaration for a second class named\nNodeComparator. This class defines a comparator function for comparing HuffmanTreeNode in-\nstances, given pointers to two nodes. This will allow you to store pointers-to-HuffmanTreeNodes\n    (HuffmanTreeNode *) in C++’s std::priority_queue data structure. It simply compares the freq\n    fields of the two provided HuffmanTreeNodes.\n        You are highly encouraged to use a std::priority_queue of pointers-to-HuffmanTreeNodes to\n    build your Huffman tree. You can initialize a min-heap priority queue as follows:\n1   priority_queue<HuffmanTreeNode *, vector<HuffmanTreeNode *>, NodeComparator> my_pq;\n\n        This creates a priority queue of HuffmanTreeNode pointers, which will be represented under the\n    hood using a vector, and which uses the comparator function we defined. Using the priority queue\n    is easy — you can review the std::priority_queue documentation here: https://cplusplus.com/\n    reference/queue/priority_queue/.\n        You should also look over the provided starter file minpq_example.cpp for an example of a C++\n    program that uses a min priority queue of HuffmanTreeNode*s.\n        Finally, recall the algorithm for building a Huffman tree:\n      1. Create one HuffmanTreeNode for each character in the text, which stores the character and its\n         frequency.\n\n      2. Until a single tree remains:\n\n            • Pick the two minimum frequency nodes.\n            • Join them together with a parent node that stores the sum of the frequencies of the children.\n\n\n    Generate Character Codes\n    With your Huffman tree built, you can now use it to generate the binary codes for each character.\n    These codes can be represented simply as strings of 0s and 1s. Recall: the code for a character is\n    represented by the path from the root to that character, where each left turn denotes a ‘0’ and each\n    right turn denotes a ‘1’. For example, given the following tree:\n\n\n\n\n                                        Figure 1: Huffman tree example.\n\n\n       You should generate the following codes:\n                                                    a   000\n                                                    b   001\n                                                    e   010\n                                                    f   011\n                                                    c    10\n                                                    d    11\n\n    Once again, how you store character codes is up to you—you will likely want to use the same\nmethod that you used to store character frequencies.\n    Note that in the above strategy, character codes are derived from edges in the tree. In order for\nthere to be edges, there must be at least 2 nodes in the tree. In the event that the input file has only\na single unique character, by the tree building process described earlier, the tree will only contain a\nsingle (leaf) node. You can choose either 0 or 1 to be that character’s character code.\n\n\nEncoding the Text\nWith the character codes, you are now ready to encode the given text into binary. All you need to\ndo is iterate over the original text, look up each character’s code, and append that code to the final\nencoded binary string. For example, given the character codes above, the encoding for the text “cafe”\nwould be the binary string “10000011010”.\n\n\nSerialize the Tree\nWhoever wants to later decode the Huffman encoded text will need access to the original Huffman\ntree. That means that we need a way to save the tree in a file such that it can later be reconstructed.\nThis process of storing a program object for later reconstruction is known as serialization.\n     In our case, we will store the Huffman tree as a string. We can take advantage of the fact that a\nHuffman tree is a full binary tree: a binary tree in which every node has either 0 or 2 children (you\ncan think about why this is the case—if a Huffman tree were not full, we could come up with a more\nefficient encoding).\n     A convenient property of full binary trees is that they can be uniquely represented using a variation\nof a preorder traversal of the tree: first store the current node, then recursively store the left subtree,\nthen recursively store the right subtree. We must also distinguish between internal nodes and leaf\nnodes. Use the following approach for serializing your tree nodes:\n\n   • Internal nodes: these nodes do not store a character. Serialize an internal node as just the\n     character ‘I’, followed by the serialized left subtree, then the serialized right subtree.\n\n   • Leaf nodes: these nodes do store a character. You should represent them using the character\n     ‘L’ followed by the character stored within that node.\n\n   For example, given the Huffman tree in Figure 1, the serialized version of the tree would be:\n\"IIILaLbILeLfILcLd\"\nMake sure you understand how the above serialization was carried out before implementing this step.\nWith this serialized tree, we will later be able to reconstruct the tree when it is read from a file. Note\nthat we did not store character frequencies in the serialized tree. That is because the frequencies are\nnot needed during decoding, they are only needed when first building the tree—so we can safely throw\nthem away.\n\n\nSaving to File\nWe now have the encoded text and the serialized Huffman tree which can be used for decoding. All\nthat we need to do now is save these to a file. However, we don’t want to just save the binary string to\na file. Each ‘0’ and ‘1’ in the binary string is an ASCII character, so it takes up 8 bits of memory—8\ntimes as large as a single 0 or 1 bit!\n\f    Writing actual bits to memory is a more involved process. Luckily, we have taken care of the\ndetails for you. With your starter files, you should have received ZapUtil.h and ZapUtil.o, which\nrespectively contain the interface and compiled implementation of the class. Take a look at the two\npublic functions, readZapFile and writeZapFile, in ZapUtil.h. For this stage, all you need to do\nis provide the target filename, encoded binary string, and serialized tree to writeZapFile, and it will\ncreate the binary file for you.\n    You are now down with the encoding process! Print a message to the user that says:\nSuccess! Encoded given text using N bits.\nwhere N is the size of encoded text. Note: the printed N does not include the size of the serialized\ntree—it is just the size of the encoded text.\n    Make sure to recycle any heap memory before your program terminates.\n    If you are curious to compare the size of your compressed data to the original data, in terminal\nyou can use ls -l to view the size in bytes of all files in your current working directory. Alternatively,\nyou can use ls -lh to view the sizes rounded to the nearest Kilobyte, Megabyte, etc.\n\n\n\n\nDecoder\n\n    Decoding is the more straightforward component of Huffman coding. It involves decompressing\na previously zapped file, and saving the resulting ASCII text to an output file. More precisely, it\ncomprises:\n   1. Reading a zap file to get the serialized tree and encoded binary string.\n\n  2. Deserializing the tree.\n\n  3. Using the tree to decode the binary string into ASCII text\n\n  4. Saving the ASCII text to an output file.\n\n\nReading the zap file\nYou should once again use the provided ZapUtil files, this time to read from a previously saved binary\nfile. Simply call the readZapFile function, providing the filename to read from. This function will\nreturn a pair<string, string>, containing both the serialized tree and the binary string encoding.\nA pair is a special C++ data structure from the <utility> library that stores just two elements.\nYou will need to include <utility> if you declare any pair variables. To access the elements of a\npair, use the member variables .first and .second. Take a look at the C++ documentation for\npair for more information: https://cplusplus.com/reference/utility/pair/pair/.\n\n\nDeserializing the tree\nYou must now deserialize the tree: convert it from its serialized string format back into a tree data\nstructure composed of HuffmanTreeNodes. Use your knowledge of preorder traversals to do this: First\ncreate a HuffmanTreeNode for the current node you are reading in from the serialized string. Then,\n\nif this is a non-leaf node, you should next recursively deserialize the node’s left subtree, then its right\nsubtree. Remember the properties of the serialized tree: ‘I’s denote internal nodes (which do not\ncontain characters), and ‘L’s denote a leaf, and are followed by the character contained within that\nleaf.\n    After deserializing, you should once again have the root HuffmanTreeNode of a valid Huffman tree.\n\n\nDecoding\nUsing this Huffman tree, you can now decode the encoded binary string. Recall the algorithm for\ndoing this: starting at the root of the tree, read in bits one at a time. For each 0, go to the left child,\nand for each 1, go to the right child. Once you reach a leaf node, append the character in that leaf\nnode to the overall decoded message. Then, go back to the root and repeat this process until all bits\nfrom the encoding have been processed.\n    For example, given the tree in Figure 1, and the encoded message 01100010010, you should get\nthe decoded message “face”. Try it by hand and make sure that this is what you get!\n    The last bit you read from the binary encoding should lead you to a leaf—that is, you should never\nfinish reading bits while in the middle of the tree. For example, given the tree in Figure 1, if you were\ngiven the encoded message ‘00101’, something must be wrong!\n    Should this happen, your decoder function, or one of its helpers, should throw a runtime_error\nwith the error message:\nEncoding did not match Huffman tree.\nThis error message should not terminate with a newline.\n    Recall from the character code generation component of the encoding process, the character code\nin a single unique character case does not correspond to an edge in the tree (as a single node tree\nhas no edges). Therefore, you should identify when a compressed file corresponds to a single unique\ncharacter original file and decompress accordingly. Hint: For a single unique character file, your bit\nstring will look something like 0000...0 or 1111...1 for B bits. How can you derive the original file\nusing the character value in the (leaf) root of the deserialized tree and B?\n\n\nSaving to file\nYou should now have the decoded text. Save this text to the output file named on the command line,\nand you’re done! Make sure to recycle any heap memory before your program terminates.\n\n\n",
    "PROJECT ZAP\n\n\nReference Implementation and Testing\n\nTo assist you with implementing and testing your program, we have provided you with the_zap, a\ncompiled reference implementation. You should play around with this implementation to get a feel\nfor how it works, and use it to test your own implementation once it is built.\n    It is important to note one thing: There is an ambiguity in the Huffman coding algorithm which\nmay affect your testing. Specifically, when building the Huffman tree, the algorithm dictates that\nwhen there are more than two minimum frequency nodes, the tie can be broken arbitrarily: any two\nminimum nodes may be picked next. As a result, there may be multiple valid Huffman trees, and\nhence multiple valid Huffman encodings for a particular text. How an encoding ultimately is chosen\nmay rely on unimportant factors, like the order in which HuffmanTreeNodes are added to the priority\nqueue.\n    What this means for you: It is possible that providing the same input text to your program and to\nthe reference implementation will result in two different zap files. Hence, it will not always be possible\nto use diff testing with zap files.\n    Luckily, one property will always hold true: any valid Huffman encoding will always be the same\nsize. Therefore, though the zap file created by your implementation may differ from the reference, the\nsize of the encodings should be the same, and thus the message printed to cout regarding encoding\nsize should always be the same. For example, if the reference prints to cout:\nSuccess! Encoded given text using 25053897 bits.\nthen your program’s output should print the exact same thing. So, you should rely on redirecting the\noutput from cout and cerr to specific files, and diff test those files against the reference’s output.\n    There are other ways to test your program as well. For example, any zap file created by your\nimplementation should be unzap-able by the reference implementation, and vice versa. Try it out:\nzap a file with your implementation, and unzap with the reference. Is the resulting text the same as\nthe original? If not, something has gone wrong.\n    You can also test your own implementation’s encoder against its decoder, for example:\n./zap zap A.txt B.zap\n./zap unzap B.zap C.txt\ndiff A.txt C.txt\n\n     Calling diff above should result in no output—A.txt and C.txt should contain identical contents.\nIf they don’t, you have some debugging to do.\n     As always, beyond diff testing, you should unit test your program early and often. Because\nyou will likely have many private functions to test, you may find it useful to temporarily make these\nfunctions public for testing purposes—just be certain to make them private again before your final\nsubmission.\n     Finally, make sure to submit all testing files you create, whether for unit or diff testing. This\nincludes any new input text files you create to pass to ./zap zap in addition to the provided text\nfiles. You should describe these files and how you used them in your testing in the README (e.g. did\nyou check the stdout of ./zap zap? did you check just the output of ./zap zap or something else?).\n\n\nTesting Utilities\nWith your starter code, you also received a few files that will be useful when testing your program\n(especially your phase one submission). These files are described below.\n\n   • ZapUtil.h and its corresponding .o file: these files are provided by us. Three functions are\n     defined in these files: makeFigure1Tree, printTree, and treeEquals. makeFigure1Tree creates\n     a tree based off of the tree in Figure 1 out of HuffmanTreeNodes. Note that the nodes in this tree\n     are all allocated on the heap. printTree prints a tree of HuffmanTreeNodes in a nice format,\n     level by level with structure and both node values and frequency. Node that the internal node\n     value can be set to non-printable characters, so their value is replaced by the string [] when a\n     tree is printed. treeEquals determines if two trees of HuffmanTreeNodes are equal. Equality\n     can be determined based solely on structure and value, or it can consider frequency as well. For\n     more information about all three of these functions, please read the comments in ZapUtil.h.\n\f   • ZapUtilExample.cpp: this file is provided by us. This file shows you how to use the three\n     functions in ZapUtil.h. It also shows you how to construct a tree from HuffmanTreeNodes\n     using set_left and set_right. This may be useful to you when you’re testing individual\n     functions in your implementation.\n\n   • bad_zap_file: this file is provided by us. This file is an example of a bad compression. That is,\n     if you tried to decode this file, you would end up in the middle of a root to leaf path traversal.\n     This should result in your HuffmanCoder::decoder function throwing a std::runtime_error.\n     This is all discussed in the last two paragraphs of the Decoding section.\n\n\nTesting Data Files\nTo test your solution, we have also provided you with some text files. You can copy them from\n/comp/15/files/proj-zap-test-files/. You should use them to test if your compression size\nmatches the reference solution. The files are:\n\n   • banana.txt contains the text in the example for the count_freqs function in Phase One. This\n     file is 6 bytes.\n\n   • hi.txt contains the text in the example for the count_freqs function in Phase One. This file\n     is 8 bytes.\n\n   • banana_apple.txt contains the text in the example in Counting Character Frequencies. This\n     file is 20 bytes.\n\n   • sentences.txt contains a few sentences from a novel. This file is 225 bytes.\n\n   • all_conll_english.txt contains the 2003 CoNLL English dataset used commonly in Natural\n     Language Processing. This file is about 5 MB.\n\n   • works_of_shakespeare.txt contains the works of William Shakespeare. This file is about 5\n     MB.\n\n   • ecoli.coli contains the E.coli genome made up of the 4 nucleotide bases of DNA. This file is\n     about 5 MB.\n\n\n\n\nMakefile and README\n\nMakefile\nYou must write and submit a Makefile along with your code. When we run make and/or make zap,\nyour Makefile should build your program and produce an executable named zap that we can run.\n\n\n\n\n                                                  11\n\fREADME\nIn addition to your program and testing files, you should submit a README file that includes the\nfollowing sections:\n  A. The title of the assignment and your name.\n  B. The purpose of the program.\n  C. Acknowledgments for any help you received.\n  D. A list of the files that you provided and a short description of what each file is and its purpose.\n  E. Instructions on how to compile and run your program.\n  F. An outline of the data structures and algorithms that you used. Given that this is a data\n     structures class, you need to always discuss the ADT that you used and the data structure\n     that you used to implement it and justify why you used it. There should be a number of data\n     structures for this assignment. Discuss each one, and why it was the correct choice for the\n     task at hand. In addition to discussing the features of the data structure, please include (with\n     some justification/explanation) two other situations/circumstances/problems where you could\n     utilize it. The algorithm overview is always relevant. Please pick a couple interesting/complex\n     algorithms to discuss in the README.\n  G. Details and an explanation of how you tested the various parts of assignment and the program\n     as a whole. You may reference the testing files that you submitted to aid in your explanation.\n   I. Please let us know approximately how many hours you spent working on this project. This\n      should include both weeks one and two.\n   Each of the sections should be clearly delineated and begin with a heading that describes the\ncontent of the section.\n\n\n\n\nSubmitting your work\n\nPhase One\nYou will need to submit two files for phase one:\n   • phaseOne.h\n   • phaseOne.cpp\n    phaseOne.h should contain the declarations of three functions, and phaseOne.cpp should contain\ntheir definitions. These functions are described below.\n    Note: You should not declare or define any classes for this phase! Though we are used to splitting\nup interface/implementation files for classes, in this case you are only declaring and defining functions,\nnot classes.\n    The functions in these files should be the following:\n\n                                                   12\n\fCONTENTS                                                                                             13\n\n\n   • void count_freqs(std::istream &text)\n     This function takes an istream reference text as input (remember, an istream could be various\n     kinds of streams: an ifstream, an istringstream, cin...). It should read in the entire stream\n     and count the number of occurrences of every character. Finally, it should print to cout the\n     number of occurrences of every character. Each character should be printed on its own line using\n     the format:\n     CHAR: NUM\n     For example, if text contains the string BaNana, your function should print to cout:\n     B:   1\n     a:   3\n     N:   1\n     n:   1\n\n\n     The function can print the character counts in any order. Note that your function should count\n     non-alphanumeric characters as well. This could make the format of the output looks strange,\n     especially in the presence of whitespace characters, but that is okay. For example, if text\n     contains:\n     hi hi\n     hi\n\n\n     Your function should print to cout:\n     h: 3\n     i: 3\n      : 1\n\n     : 1\n\n\n     Notice that the newline’s frequency is reported across two lines.\n\n   • std::string serialize_tree(HuffmanTreeNode *root)\n     This function takes a pointer to the root of a Huffman tree as input, and it returns the serialized\n     version of the tree. The tree should be serialized according to the format described earlier.\n\n   • HuffmanTreeNode *deserialize_tree(const std::string &serial_tree)\n     This function goes in the other direction: given a serialized tree as input, it reconstructs the\n     Huffman tree and returns a pointer to its root. Though this function should allocate memory\n     on the heap for the new nodes, for your phase one submission, you don’t need to worry about\n     freeing this memory—our autograder will do it for you.\n\n   You may declare/define additional helper functions in phase one, but you are not required to.\nYou should test your functions thoroughly. How you do so is up to you—you can use the unit_test\nframework, or you can write your own main() function (but you should do so in a separate file, since\nour autograder will use its own mains).\n\nSubmitting Phase 1\nYou will need to submit at least the following files:\n          phaseOne.h, phaseOne.cpp\n          README\n          (... any testing files)\n\fCONTENTS                                                                                           14\n\n\n   You should only include other C++ files if your solutions to the phase 1 functions depend on\nthem. Do not submit HuffmanCoder.cpp for example. You must submit them using Gradescope to\nthe assignment proj_zap_phase1. Submit these files directly, do not try to submit them in a folder.\nYour README does not need to contain everything we normally ask for. For this phase, you can just\nwrite a very brief summary with any information you’d like the grader to see (e.g., if there is a bug\nyou have not been able to fix).\n\n\nPhase Two\nWhen you begin working on your final submission, you will find the functions from phase one useful.\nFor the final submission, you do not need to keep these functions within the phaseOne files, and you\nare welcome to change other properties of the functions as well (their names, type signatures, etc.).\nAt a minimum, you will not want your count_freqs function to print anything to cout. But you will\nwant to reuse the logic within the functions.\n    For this part you will submit all of the files required to compile your zap program, including a\nMakefile. Be sure to include any files you used for testing, including test data that you created. You\nwill need to submit the following files:\n        HuffmanCoder.h, HuffmanCoder.cpp\n        main.cpp\n        Makefile\n        unit_tests.h\n        README\n        (... all the C++ .h, .cpp files that implement your program)\n        (... any testing files)\n\fYou must also submit:\n\n   • Any unit tests you write for your program. This may be done in a file called unit_tests.h,\n     using the unit_test framework that we have used on past assignments. Alternatively, you can\n     create your own testing main functions, e.g., submit a file called Zap_tests.cpp with a main\n     function that calls out to tests. Like HW1 and HW2, this assignment can be easily unit tested,\n     so each step of the encoder() and decoder() should have dedicated tests. Whatever testing\n     files you use, you must submit them!\n\n   • Any .txt files given to encoder() (excluding the command file provided).\n\n   • Note, you only need to include testing input files. You do not need to include output files of any\n     kind (stdout, stderr, or compressed files).\n\n   • A detailed testing description in the README. Since you shouldn’t submit output files, you must\n     describe how you diff tested your program with the reference to check for correctness. How did\n     you test that the zapped file encoder created was correct? What about the file decoder created?\n     Etc.\n\n    You must submit them using Gradescope to the assignment proj_zap.\n    Note: Make sure to submit everything we need to run your program. Maybe copy the files to\nanother directory, type make to try building your program, do a make clean and then submit every-\nthing in the directory. We should be able to use make or make zap to build your program. You do not\nneed to submit any provided files (HuffmanTreeNode.h, HuffmanTreeNode.o, ZapUtil.h, ZapUtil.o).\n\n    Before submitting your work, please make sure your code and documentation (including sections\nof the README) conform to the course style guide.\n\n\n\n\nHelpful Tips\n\n   • At various points in your program, you’ll need to read characters one at a time from a stream.\n     Most likely, you do not want to use the >> operator to do this. This operator skips over\n     whitespace characters—but in order to correctly compress and decompress text, whitespace\n     characters should not be skipped. Instead try using the get() function, which can read any\n     single character from a stream. Here is the documentation for istream’s get() function: https:\n     //cplusplus.com/reference/istream/istream/get/\n\n   • We will only test your program on ASCII text. Recall that modern ASCII encodings use 8 bits\n     to represent up to 256 characters. Moreover, under the hood, C++’s chars are represented using\n     the character’s ASCII integer. That means you can use a char in contexts where an integer is\n     expected, you can cast chars to ints, or you can use the int() constructor to get a char’s\n     ASCII number—e.g., for a char c, the expression int(c) will give you the character’s ASCII\n     number. You may find it useful to leverage this knowledge in your implementation.\n\n\n  • Say you have two string variables named str and other_str. Though they may appear identical,\n    it turns out there is a big difference in the following two lines:\n 1   str += other_str;\n 2   str = str + other_str;\n\n\n     Line 1 appends other_str to the back of str. Line 2 concatenates str and other_str, and\n     stores the result in a completely new place in memory. Line 1 can be significantly more time\n     efficient, especially for larger strings, as it can avoid time spent copying to a new place in memory.\n     You’ll want to keep this in mind as you build out your implementation.\n\n  • Make sure to have VS Code setup properly to not have Windows line breaks and only Linux line\n    breaks. This way, you will avoid introducing Windows line breaks into any text files you create.\n    As a reminder, the instructions on how to do this are here.\n\f"
  ],
  "filenames": [
    "CS15 Admin Page.txt",
    "CS15 Course Schedule.txt",
    "CS15 Style Guide.txt",
    "CS15 website home page.txt",
    "calcyoulater2.txt",
    "gerp2.txt",
    "hw_arraylists.txt",
    "hw_linkedlists.txt",
    "lab_arraylists.txt",
    "lab_avl_trees.txt",
    "lab_debug_circular_buffers.txt",
    "lab_dijkstras_algorithm.txt",
    "lab_dijkstras_algorithm_solution.txt",
    "lab_graph_traversals.txt",
    "lab_hash_tables.txt",
    "lab_heaps.txt",
    "lab_intro.txt",
    "lab_make.txt",
    "lab_recursion.txt",
    "lab_sorting.txt",
    "lab_stacks_queues_circular_buffers.txt",
    "lab_tree_traversals.txt",
    "metrosim2.txt",
    "piazza.txt",
    "proj_calcyoulater.txt",
    "proj_gerp.txt",
    "proj_metrosim-_1_.txt",
    "proj_zap-_1_.txt",
    "zap2.txt"
  ]
}